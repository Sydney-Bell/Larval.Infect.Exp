---
title: "R Notebook"
output: html_notebook
---


```{r}
setwd("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024")
saveRDS(df_with_extremes, file = "df_with_extremes.rds")

#df_with_extremes <- readRDS("df_with_extremes.rds")
#df_subset <- readRDS("df_subset.rds")
```


```{r}
library('ggplot2'); packageVersion('ggplot2') #version 3.5.0
library(dplyr)

setwd("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment")

metadata = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE)
str(metadata)

# Remove rows with missing treatment
metadata <- metadata %>% filter(!is.na(Treatment))

# Convert Timepoint columns to numeric
df <- metadata %>%
  mutate(across(starts_with("Timepoint"), as.numeric))

# Rename FvFm column (column 35)
colnames(df)[35] <- "FvFm"

# Remove blank rows based on key columns
df <- df %>%
  filter(!(is.na(tube.ID) & is.na(Timepoint) & is.na(Temp)))

# Set categorical variable levels
df <- df %>%
  mutate(
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")),
    Family = na_if(Family, ""),
    SymbiontTreatment = na_if(SymbiontTreatment, "")
  ) %>%
  mutate(across(c(Family, SymbiontTreatment), factor)) %>%
  droplevels()

# Temp coding based on Treatment
df <- df %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ as.character(Temp)
  ))

# Create UniqueID
df <- df %>%
  mutate(UniqueID = paste0(Temp, "V", tube.ID))


# Calculate Initial/Final and Percent Change Metrics
epsilon <- 1e-8 # Small number to avoid division by zero

# FvFm
# Calculate FvFminitial and FvFmfinal without dropping rows with NA
df <- df %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    FvFminitial = first(na.omit(FvFm)),  # First non-NA FvFm
    FvFmfinal = last(na.omit(FvFm))      # Last non-NA FvFm
  ) %>%
  ungroup()

# Calculate percent change, skipping division by zero
df <- df %>%
  mutate(PercChange = ifelse(is.na(FvFminitial) | FvFminitial == 0,
                             NA,
                             ((FvFmfinal - FvFminitial) / FvFminitial) * 100))

# Size (Area)
df <- df %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    Sizeinitial = first(na.omit(Area..mm.2.)),
    Sizefinal = last(na.omit(Area..mm.2.)),
    PercChangeSize = ((Sizefinal - Sizeinitial) / (Sizeinitial + epsilon)) * 100
  ) %>%
  ungroup()

#0 = alive
df_with_extremes <- df %>%
  mutate(Status = ifelse(`Alive..Dead..Sampled` == "Alive", 0, 1))

#Long-format Cell Density (From No.Cells1–3)
# Reload full dataset for long-format cell counts
#totaldf <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE, stringsAsFactors = FALSE)

# Convert and reshape
totaldf_long <- df_with_extremes %>%
  mutate(across(starts_with("No.Cells"), as.numeric)) %>%
  pivot_longer(cols = starts_with("No.Cells"),
               names_to = "Cell_Measurement",
               values_to = "Cell_Density") %>%
  filter(!is.na(Cell_Density))

# Clean up factors and drop missing key values
totaldf_long <- totaldf_long %>%
  mutate(across(c(SymbiontTreatment, Family, Treatment, Timepoint), factor)) %>%
  filter(!is.na(SymbiontTreatment), !is.na(Family),
         !is.na(Treatment), !is.na(Timepoint))

# Add Cross column based on ReefMom
totaldf_long <- totaldf_long %>%
  mutate(Cross_2 = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

#Survival Calculation
df_Surv <- totaldf_long %>%
  mutate(
    Percent_Survival_atend = Percent_Survival_atend / 100,
    Dead_Larvae = No.LarvaeInExpected - No.LarvaeInObserved
  ) %>%
  filter(!is.na(No.LarvaeInObserved), !is.na(Dead_Larvae), Dead_Larvae >= 0)

df_Surv <- df_Surv %>%
  mutate(across(c(SymbiontTreatment, Family, Treatment, Timepoint, Replicate), factor))

# Ensure both columns are integers
df_Surv <- df_Surv %>%
  filter(!is.na(No.LarvaeInObserved) & !is.na(Dead_Larvae))  # Remove rows with NA values
# Remove rows where Dead_Larvae is negative
df_Surv <- df_Surv %>%
  filter(Dead_Larvae >= 0)

# Temp coding based on Treatment
df_Surv <- df_Surv %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ as.character(Temp)
  ))

# Cell Density
totaldf_long <- totaldf_long %>%
  filter(!is.na(Cell_Density)) %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    Cellinitial = first(Cell_Density),
    Cellfinal = last(Cell_Density),
    PercChangeCells = ((Cellfinal - Cellinitial) / (Cellinitial + epsilon)) * 100
  ) %>%
  ungroup()

#####################################
#load in cells for exploratory box plots
cells = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/celldensity.csv", header = TRUE)
str(cells)

# Calculate total number of cells per TubeID and Date.Start
total_cells <- cells %>%
  filter(!is.na(Cells.End.Average)) %>%  # Exclude rows with NA in Cells.End.Average
  group_by(TubeID) %>%
  summarise(Cells_End_Average = sum(Cells.End.Average))  # Calculate sum of Cells.End.Average for each TubeID

# Extract tank information from TubeID
cells <- cells %>%
  mutate(tank = ifelse(substr(TubeID, 1, 2) == "T1", "Ambient", "31C"))

# Calculate total number of cells per TubeID, tank, and CellType
total_cells <- cells %>%
  filter(!is.na(Cells.End.Average)) %>%  
  group_by(tank, TubeID, CellType) %>%
  summarise(Cells_End_Average = sum(Cells.End.Average))  

# Make Treatment a factor
cells$Treatment <- factor(cells$Treatment, levels = c("Ambient", "31", "35.5"))
treatment_colors <- c("Ambient" = "green", "31" = "orange", "35.5" = "red")

# Reshape the data so that all 3 cell counts are combined
cells_long <- cells %>%
  pivot_longer(cols = starts_with("No.Cells"), 
               names_to = "Measurement", 
               values_to = "CellDensity",
               values_drop_na = TRUE)
```


```{r}
#Family
# Plot using ggplot2 with a smooth curve, facet by Treatment, and custom layout
plotfam <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(Family))) +
  geom_smooth(method = "loess", se = FALSE) +  # Use loess method for smoothing
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +  # Facet by Treatment with one row
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
plotfam

#plotGen
plotGen <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(SymbiontTreatment))) +
  geom_smooth(method = "loess", se = FALSE) +  # Use loess method for smoothing
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +  # Facet by Treatment with one row
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
plotGen

#ReefMom

plot_raw <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(Culture))) +
  geom_point() +
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
print(plot_raw)


plotCul <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(Culture))) +
  geom_smooth(method = "loess", se = FALSE) +  # Use loess method for smoothing
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +  # Facet by Treatment with one row
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
plotCul


```

## Cell Density: Exploratory Bar Graph
```{r}

# Create a bar graph
ggplot(total_cells, aes(x = TubeID, y = Cells_End_Average)) +
  geom_bar(stat = "identity") +
  labs(x = "Tube ID", y = "Total Number of Cells") +
  theme_minimal()

# Create a bar graph with color by CellType
ggplot(total_cells, aes(x = TubeID, y = Cells_End_Average, fill = CellType)) +
  geom_bar(stat = "identity") +
  labs(x = "Tube ID", y = "Total Number of Cells") +
  theme_minimal()
```
## Cell Density: Exploratory Line Graph
```{r}

# Create a new data frame with start and end points for each TubeID
combined_data <- data.frame(
  Date = c(cells$T.Start, cells$T.End),
  Cells = c(cells$Cells.Start, cells$Cells.End.Average),
  TubeID = rep(cells$TubeID, 2),
  Type = rep(c("Start", "End"), each = nrow(cells))
)

# Plot the line graph
cellden = ggplot(combined_data, aes(x = Date, y = Cells, group = TubeID, color = Type)) +
  geom_line() +
  geom_point() +
  geom_text(data = subset(combined_data, Type == "End"), 
            aes(label = TubeID), vjust = -0.5, hjust = 1.5) +
  labs(x = "Date", y = "Cell Density", color = "Type") +
  theme_minimal()

cellden
#ggsave("celldensity.jpg", plot = cellden)


```
## Cell Density: Boxplot by Cross
```{r}

# Create the box plot
celldenboxplot = ggplot(cells_long, aes(x = Cross, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  labs(title = "Box Plot of Cell Density by Cross and Treatment",
       x = "Cross",
       y = "Cell Density") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = treatment_colors)

ggsave("celldensityboxplot.jpg", plot = boxplot, width = 25, height = 15)
```
## Cell Density: Boxplot by Reef, Cell Type, and Treatment
```{r}
# Create the boxplot
celldenboxplot <- ggplot(cells_long, aes(x = Reef, y = CellDensity, fill = CellType)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +  # separate boxes for each CellType
  facet_wrap(~ Treatment) +
  labs(title = "Cell Density by Reef, Cell Type, and Treatment",
       x = "Reef",
       y = "Cell Density") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )


# Load necessary library
library(stats)

# Perform Kruskal-Wallis test
cells_long$Group <- paste(cells_long$Treatment,
                          cells_long$CellType,
                          sep = ".")


kruskal.test(CellDensity ~ Group, data = cells_long)

#Kruskal-Wallis rank sum test
#data:  CellDensity by Treatment
#Kruskal-Wallis chi-squared = 99.817, df = 5, p-value < 2.2e-16

#Based on this result, you can conclude that there is a statistically significant difference in cell density among the different treatment, cell type, and Reef combinantions (Ambient, 31, and 35.5).

# Example of pairwise Wilcoxon rank-sum test (pairwise comparisons)
pairwise.wilcox.test(cells_long$CellDensity, cells_long$Group, p.adjust.method = "BH")

ggplot(cells_long, aes(x = Group, y = CellDensity)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```
## Cell Density: Kruskal-Wallis test with Treatment
```{r}
# provided a very small p-value (< 2.2e-16), indicating strong evidence against the null hypothesis of normality
shapiro.test(cells_long$CellDensity)
#data is nonparametric

# Load necessary library
library(stats)

# Perform Kruskal-Wallis test
kw_result <- kruskal.test(CellDensity ~ Treatment, data = cells_long)

# Check test result
print(kw_result)

#Kruskal-Wallis rank sum test
#data:  CellDensity by Treatment
#Kruskal-Wallis chi-squared = 90.004, df = 2, p-value < 2.2e-16

#Based on this result, you can conclude that there is a statistically significant difference in cell density among the different treatments (Ambient, 31, and 35.5).

# Example of pairwise Wilcoxon rank-sum test (pairwise comparisons)
pairwise.wilcox.test(cells_long$CellDensity, cells_long$Treatment, p.adjust.method = "bonferroni")

#Ambient vs. 31: The p-value is approximately 1, indicating no significant difference in cell density between Ambient and 31 treatments.
#Ambient vs. 35.5: The adjusted p-value is < 2e-16, indicating a highly significant difference in cell density between Ambient and 35.5 treatments.
#31 vs. 35.5: The adjusted p-value is also < 2e-16, indicating a highly significant difference in cell density between 31 and 35.5 treatments.

```
## Cell Density: Two-Way Repeated Measures ANOVA
2 predictors: Treatment and CellType
```{r}
# 1. Check assumptions 
########### TREATMENT #############
# Convert Treatment to a factor
cells_long$Treatment <- factor(cells_long$Treatment)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$Treatment)

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, Treatment=='Ambient')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='31')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='35.5')$CellDensity)
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############
# Convert CellType to a factor
cells_long$CellType <- factor(cells_long$CellType)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$CellType)

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, CellType=='C')$CellDensity)
shapiro.test(subset(cells_long, CellType=='D')$CellDensity)
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$CellType)
# Bartlett's K-squared = 24.126, df = 1, p-value = 9.024e-07
# NOT HOMOGENOUS

# 2. Assumptions are not met: Try scale transformations

########### TREATMENT #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$Treatment) # square root transformed because we have counts

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, Treatment=='Ambient')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='31')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='35.5')$CellDensity))
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$CellType) # square root transformed because we have counts

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, CellType=='C')$CellDensity))
shapiro.test(sqrt(subset(cells_long, CellType=='D')$CellDensity))
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$CellType)
# Bartlett's K-squared = 4.5066, df = 1, p-value = 0.03377
# HOMOGENOUS

# 3. Do non-parametric test by rank-transforming the data

library(nlme)
rDV<-rank(cells_long$CellDensity)

lme.rank<-lme(fixed = rDV ~ Treatment * CellType, random=~1|Cross, data = cells_long)
celldenanova <- anova (lme.rank)
#                       numDF       denDF      F-value       p-value
# (Intercept)             1         358        518.9960     <0.0001
# Treatment               2         358         64.6619     <0.0001
# CellType                1         358         1.8426      0.1755
# Treatment:CellType      2         358         5.1615      0.0062

plot(CellDensity ~ Treatment*CellType, data = cells_long)

# Treatment: F(2, 358) = 64.6619, p = <0.0001
# CellType: NOT sig
# Interaction: F(2, 358) = 5.1615, p = 0.0062

```
##Cell density box plot
Analyze significant interaction Treatment*CellType
```{r}
interaction.plot(cells_long$CellType, cells_long$Treatment, cells_long$CellDensity, 
                 xlab="CellType", ylab="CellDensity", trace.label="Treatment")

# Example using pairwise comparisons
pairwise.t.test(cells_long$CellDensity, interaction(cells_long$Treatment, cells_long$CellType), p.adjust.method = "bonferroni")
#	Pairwise comparisons using t tests with pooled SD 

#data:  cells_long$CellDensity and interaction(cells_long$Treatment, cells_long$CellType) 

#          Ambient.C 31.C    35.5.C  Ambient.D 31.D   
#31.C      0.05188   -       -       -         -      
#35.5.C    0.00012   1.00000 -       -         -      
#Ambient.D 0.01986   1.00000 1.00000 -         -      
#31.D      1.00000   1.00000 0.03891 1.00000   -      
#35.5.D    0.00012   1.00000 1.00000 1.00000   0.03891

#P value adjustment method: bonferroni 
#install.packages("emmeans")
library(emmeans)
# Fit the linear mixed-effects model
lme.rank <- lme(fixed = rDV ~ Treatment * CellType, random = ~1|Cross, data = cells_long)

# Obtain the estimated marginal means
emm <- emmeans(lme.rank, ~ Treatment * CellType)

# Perform Tukey's post hoc test
tukey_result <- pairs(emm, adjust = "tukey")

# Print the results
print(tukey_result)

# Create boxplot with facets by CellType and colors by Treatment
cells_long$Treatment <- factor(cells_long$Treatment, levels = c("Ambient", "31", "35.5"))


ggplot(cells_long, aes(x = Treatment, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  facet_grid(. ~ CellType) +
  labs(title = "Boxplot of Cell Density by Treatment and Cell Type",
       x = "Treatment",
       y = "Cell Density",
       fill = "Treatment") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = c("Ambient" = "green","31" = "orange", "35.5" = "red"))

```
##Survival Analysis
Cox model: with Treatment and ReefMom
```{r}
#Install package survival
library(survival)
X<-cbind(metadata_clean$Treatment, metadata_clean$SymbiontTreatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox<- coxph (Surv(Timepoint, Status)~ X, method='breslow', data = metadata_clean)
summary(cox)

# Test proportional hazards assumption
ph_test <- cox.zph(cox_model)
print(ph_test)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                       coef exp(coef) se(coef)      z Pr(>|z|)    
#XTreatment         -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#XSymbiontTreatment  0.04804   1.04921  0.06201  0.775  0.43848    
#XReefMom           -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#                   exp(coef) exp(-coef) lower .95 upper .95
#XTreatment            0.7831     1.2770    0.7262    0.8445
#XSymbiontTreatment    1.0492     0.9531    0.9291    1.1848
#XReefMom              0.9588     1.0430    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.83  on 3 df,   p=1e-10
#Wald test            = 48.21  on 3 df,   p=2e-10
#Score (logrank) test = 48.62  on 3 df,   p=2e-10

# Not all predictors are significant so use backward stepwise model selection to remove the most insignificant factor (symbiont treatment)

X2<-cbind(metadata_clean$Treatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox2<- coxph (Surv(Timepoint, Status)~ X2, method='breslow', data = metadata_clean)
summary(cox2)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X2, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                coef exp(coef) se(coef)      z Pr(>|z|)    
#X2Treatment -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#X2ReefMom   -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#            exp(coef) exp(-coef) lower .95 upper .95
#X2Treatment    0.7831      1.277    0.7262    0.8445
#X2ReefMom      0.9588      1.043    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.23  on 2 df,   p=3e-11
#Wald test            = 47.61  on 2 df,   p=5e-11
#Score (logrank) test = 48.02  on 2 df,   p=4e-11

# Compare models
AIC(cox, cox2) #cox2 has the lowest AIC so we keep it

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km <-survfit(Surv(Timepoint,Status)~ Treatment + ReefMom, data = metadata_clean) # do not include interactions
km
summary(km)

# Plot the survival curves
library(survival)
km$strata

# Plot the Kaplan-Meier curve
plot(km, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
#install.packages("survminer")
library(survminer)
require("survival")
ggsurvplot(km)
# Create a combined label for legend
metadata_clean$combined_label <- with(metadata_clean, paste(Treatment, ReefMom, sep = "."))

# Now refit the survival object
km <- survfit(Surv(Timepoint, Status) ~ combined_label, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.ReefMom",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET
# Fit the Kaplan-Meier survival curve
km2 <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom, data = metadata_clean)

ggsurv <- ggsurvplot(km2, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names <- c("coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue"
)

levels(km2$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km2, conf.int = TRUE, 
                     palette = custom_curve_names,  # Custom color palette
                     legend.title = "ReefMom",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
survival_curves_facet_ReefMom <- ggsurv$plot + 
    theme_bw() + 
    facet_wrap(~ Treatment)  # Faceting by Treatment

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_ReefMom.png", plot = survival_curves_facet_ReefMom, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pairs <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + ReefMom, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pairs

# Symbolic number coding
symnum(pairs$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")


#########
# Try interactions just to confirm SymbiontTreatment isn't significant
########

# Fit Cox proportional hazards model with interactions
cox.int <- coxph(Surv(Timepoint, Status) ~ Treatment * SymbiontTreatment * ReefMom, 
             method = 'breslow', data = metadata_clean)

# Display the summary of the model
summary(cox.int)

#SymbiontTreatment is not significant

#########
# Plot original model with SymbiontTreatment for visual
# Final Plot
########
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))
metadata_clean$ReefMom <- factor(metadata_clean$ReefMom,
                                levels = c("BT2", "BT4", "BT8", "Bulk", "TT12", "TT2", "TT6"),  # your original levels
                                labels = c("CC1", "CC2", "CC3", "WW1", "WW2", "WW3", "WW4"))  # new display names

metadata_clean$SymbiontTreatment <- factor(metadata_clean$SymbiontTreatment,
                                          levels = c("C", "D"),  # original levels
                                          labels = c("Cladocopium", "Durusdinium"))  # new display names


# Fit survival by Treatment + ReefMom + SymbiontTreatment
km.symb <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom + SymbiontTreatment, data = metadata_clean)

# Extract Treatment from strata names
strata_names <- names(km.symb$strata)

# Extract Treatment from each strata string
library(stringr)
treatment_in_strata <- str_extract(strata_names, "(?<=Treatment=)[^,]+")

# Create a vector mapping each strata to one of your 3 colors
my_colors_42 <- ifelse(treatment_in_strata == "Ambient", "#3288bd",
                 ifelse(treatment_in_strata == "31", "#fee08b",
                        ifelse(treatment_in_strata == "35.5", "#d53e4f", "black")))

names(my_colors_42) <- strata_names

# Now pass this as palette to ggsurvplot
ggsurv <- ggsurvplot(km.symb,
                     conf.int = TRUE,
                     palette = my_colors_42,
                     legend.title = "Treatment",
                     conf.int.alpha = 0.2)

# Add facets
survival_curves_facet_Symb <- ggsurv$plot +
    theme_bw() +
    facet_grid(ReefMom ~ SymbiontTreatment) + theme(
    strip.background = element_blank(),  # removes the grey background box
    strip.text = element_text(color = "black", face = "bold", size = 12),
    legend.position = "none" # text styling
  )

print(survival_curves_facet_Symb)

# Create a dataframe of p-values to include on the plots
facet_pvals <- metadata_clean %>%
  group_by(ReefMom, SymbiontTreatment) %>%
  summarise(
    p = tryCatch({
      survdiff(Surv(Timepoint, Status) ~ Treatment, data = pick(everything()))$chisq %>%
        {1 - pchisq(., df = n_distinct(Treatment) - 1)}
    }, error = function(e) NA),
    .groups = "drop"
  ) %>%
  mutate(
    label = paste0("p = ", signif(p, 3)),
    x = 0,         # adjust as needed for your plot's x-axis scale
    y = 0.05       # adjust as needed for your plot's y-axis scale
  )

#add p-values to the plot by facet
survival_curves_facet_Symb <- ggsurv$plot +
  facet_grid(ReefMom ~ SymbiontTreatment) +
  theme_bw() +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(color = "black", face = "italic", size = 12),
    legend.position = "none"
  ) +
  geom_text(data = facet_pvals, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, vjust = 0, size = 4)

#save
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_Symb.png", plot = survival_curves_facet_Symb, width = 10, height = 20, dpi = 300)

```
##Survival Analysis
Cox model: with Treatment and Cross_2
```{r}
# Determine the class of the Factors (not the covariates):
class(metadata_clean$Cross_2)
#If any of the factors is not a “factor”, redefine it as a factor:
metadata_clean$Cross_2 <- factor(metadata_clean$Cross_2)
# Check for missing values in the columns used in the model
sum(is.na(metadata_clean$Cross_2))

X3<-cbind(metadata_clean$Treatment, metadata_clean$Cross_2)# if you don’t have covariates, do not include them
# if observations are right censored:
cox3 <- coxph (Surv(Timepoint, Status)~ X3, method='breslow', data = metadata_clean)
summary(cox3)

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km3 <-survfit(Surv(Timepoint,Status)~ Treatment + Cross_2, data = metadata_clean) # do not include interactions
km3
summary(km3)

# Plot the survival curves
km3$strata

plot(km3, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
ggsurvplot(km3)
# Create a combined label for legend
metadata_clean$combined_label2 <- with(metadata_clean, paste(Treatment, Cross_2, sep = "."))

# Now refit the survival object
km4 <- survfit(Surv(Timepoint, Status) ~ combined_label2, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label2))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km4, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.Cross_2",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET

# Fit the Kaplan-Meier survival curve
km5 <- survfit(Surv(Timepoint, Status) ~ Treatment + Cross_2, data = metadata_clean)

summary(km5)

ggsurv <- ggsurvplot(km5, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names2 <- c("aquamarine3", "orange", "aquamarine3", "orange", "aquamarine3", "orange")

levels(km5$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km5, conf.int = TRUE, 
                     palette = custom_curve_names2,  # Custom color palette
                     legend.title = "Source Reef",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
final_plot <- ggsurv$plot + 
              theme_bw() + 
              facet_wrap(~ Treatment)  # Faceting by Treatment

# Save the plot using ggsave
#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_SourceReef.png", plot = final_plot, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + Cross_2, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair

# Symbolic number coding
symnum(pair$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")

# Extract survival probabilities at a specific time, e.g., time = 22
# You can do this using the 'summary()' function with the 'time' argument
surv_summary <- summary(km5, times = 22)

# Print the survival probability at time 50
print(surv_summary$surv)  # This gives the survival probabilities

#at day 22:
# ambient BxB = 0.4891414 +- 0.0836
# ambient TxT = 0.8182818 +- 0.0693
# 31 BxB = 0.1330052 +- 0.0438
# 31 TxT = 0.1398107 +- 0.0406
# 35.5 = 0.0000000 and 0.0000000


```

Survival Analysis
Just Treatment as a variable

```{r}
# Fit the Kaplan-Meier survival curve
km6 <- survfit(Surv(Timepoint, Status) ~ Treatment, data = metadata_clean)

summary(km6)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair2 <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair2
```

#Load in dataset and clean it for GLMMs

```{r}
#install.packages("MCMCglmm")
library(MCMCglmm)
#install.packages("lsmeans")
library(lsmeans)
library(tidyr)
library(dplyr)

#Validate the model
summary(mod.1)
#install.packages("DHARMa")
library(DHARMa)

#The assumptions of linearity and homogeneity of variance for a GLMM are based upon the residuals, so we must extract them and then perform validation
simulationOutput <- simulateResiduals(mod.1, n = 1000)
plot(simulationOutput)
#The Q-Q plot visually shows if the points fall along a straight line, indicating that the data follows the theoretical distribution reasonably well.

#Levene Test for homogenity of variance significant for all variables
plotResiduals(simulationOutput, df_Surv$SymbiontTreatment)
plotResiduals(simulationOutput, df_Surv$Family)
plotResiduals(simulationOutput, df_Surv$Treatment)


```
#HEATMAP WITH SOURCE REEF (CC and WW instead of individial families)

##Fv/Fm with Source Reef
```{r}
#Fv/Fm #################################################### 
library(MCMCglmm)
# Set factor levels
df_with_extremes <- df_with_extremes %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
df_with_extremes$Treatment <- factor(df_with_extremes$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
df_with_extremes$Cross_2 <- factor(df_with_extremes$Cross_2, 
                                     levels = c("BxB", "TxT"))
df_with_extremes$SymbiontTreatment <- factor(df_with_extremes$SymbiontTreatment, 
                                     levels = c("C", "D"))

#df_with_extremes <- df_with_extremes %>%
 # mutate(logPercChange = log1p(PercChange))  # log1p handles 0 and negative % changes better


hist(df$PercChange, breaks = 50)
summary(df$PercChange)

#Set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)


# Fit the model
model3.reef <- MCMCglmm(PercChange ~ SymbiontTreatment * Cross_2 * Treatment, 
                        random = ~ Replicate, 
                        data = df_with_extremes, 
                        family = "gaussian",  
                        prior = prior,
                        nitt = 50000, burnin = 10000, thin = 20)

solution_summary <- summary(model3.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model3.reef$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# Create prediction grid
newdat.reef <- expand.grid(
  SymbiontTreatment = levels(df_with_extremes$SymbiontTreatment),
  Cross_2 = levels(df_with_extremes$Cross_2),
  Treatment = levels(df_with_extremes$Treatment)
)

# Ensure factor levels match
newdat.reef <- newdat.reef %>%
  mutate(across(everything(), ~ factor(.x, levels = levels(df_with_extremes[[cur_column()]]))))

# Generate design matrix
# Model matrix for prediction rows
X_full <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat.reef)
X <- X_full[, names(pmcmc_values), drop = FALSE]  # Make sure columns match

# For each prediction, calculate a "pMCMC-equivalent" value
# This is done by testing whether the *linear combination of coefficients* differs from 0
# using the posterior distribution (model3.reef$Sol)

posterior_preds <- X %*% t(model3.reef$Sol)

newdat.reef$pred_mean <- rowMeans(posterior_preds)
newdat.reef$lower <- apply(posterior_preds, 1, quantile, probs = 0.025)
newdat.reef$upper <- apply(posterior_preds, 1, quantile, probs = 0.975)

# Calculate pMCMC: proportion of posterior samples less than 0 or greater than 0
newdat.reef$pMCMC <- apply(posterior_preds, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance at alpha = 0.05
newdat.reef$significant <- newdat.reef$pMCMC < 0.05


# Create label
newdat.reef$label_combined <- paste0(
  round(as.numeric(as.character(newdat.reef$pred_mean)), 1),
  ifelse(newdat.reef$significant, "*", "")
)

# Make sure pred_mean is numeric for fill
newdat.reef$pred_mean <- as.numeric(as.character(newdat.reef$pred_mean))

#Global mean
# Vector of posterior means across all groups for each MCMC iteration
global_mean_post_subset <- colMeans(posterior_preds)
# Difference: each group's posterior - global mean at each MCMC iteration
diff_matrix_global_subset <- sweep(posterior_preds, 2, global_mean_post_subset, FUN = "-")
# pMCMC: two-tailed probability that the difference ≠ 0
pMCMC_vals <- apply(diff_matrix_global_subset, 1, function(x) {
  mean(x < 0) * 2 * (mean(x < 0) < 0.5) + mean(x > 0) * 2 * (mean(x > 0) < 0.5)
})
diff_summary_global_subset <- as.data.frame(t(apply(diff_matrix_global_subset, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
})))

colnames(diff_summary_global_subset) <- c("mean_global", "lower_global", "upper_global")

diff_summary_global_subset$pMCMC <- pMCMC_vals
diff_summary_global_subset$signif_label_global <- case_when(
  pMCMC_vals < 0.005 ~ "**",
  pMCMC_vals < 0.05  ~ "*",
  TRUE               ~ ""
)

diff_summary_global_subset$label_combined_global <- paste0(
  round(diff_summary_global_subset$mean_global, 2),
  diff_summary_global_subset$signif_label_global
)

diff_summary_global_subset <- as.data.frame(diff_summary_global_subset)
diff_summary_global_subset$significant_vs_global <- with(diff_summary_global_subset, lower_global > 0 | upper_global < 0)

newdat.reef <- cbind(newdat.reef, diff_summary_global_subset)

# Plot predicted means
ggplot(newdat.reef, aes(x = Treatment, y = Cross_2, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted Change") +
  theme_minimal() +
  labs(title = "Predicted Percent Change in Fv/Fm with pMCMC Significance",
       x = "Temperature", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
model_treatment <- MCMCglmm(
  fixed = PercChange ~ Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_symbiont <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_cross2 <- MCMCglmm(
  fixed = PercChange ~ Cross_2,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_R2(model_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_R2(model_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(model_cross2, df_with_extremes, PercChange ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_with_extremes, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_conditional_R2(model_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(model_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(model_cross2, df_with_extremes, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),
  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  )
)

print(results_df)

print(results_df)

print(r2_interaction)
str(r2_interaction)

results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)


```

##Larval Size with Source Reef
```{r}

#Larval Size #####################################

# Ensure factors are ordered
df_with_extremes$Treatment <- factor(df_with_extremes$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
df_with_extremes$Cross_2 <- factor(df_with_extremes$Cross_2, 
                                     levels = c("BxB", "TxT"))
df_with_extremes$SymbiontTreatment <- factor(df_with_extremes$SymbiontTreatment, 
                                     levels = c("C", "D"))

mod.s.reef <- MCMCglmm(PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment, 
                  random = ~ Replicate, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

summary(mod.s.reef)
#DIC: -2345.138 
solution_summary <- summary(mod.s.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(mod.s.reef$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# Create prediction grid
newdat_size_reef <- expand.grid(
  SymbiontTreatment = levels(df_with_extremes$SymbiontTreatment),
  Cross_2 = levels(df_with_extremes$Cross_2),
  Treatment = levels(df_with_extremes$Treatment)
)

# Match factor levels explicitly (good practice)
newdat_size_reef$SymbiontTreatment <- factor(newdat_size_reef$SymbiontTreatment, levels = levels(df_with_extremes$SymbiontTreatment))
newdat_size_reef$Cross_2 <- factor(newdat_size_reef$Cross_2, levels = levels(df_with_extremes$Cross_2))
newdat_size_reef$Treatment <- factor(newdat_size_reef$Treatment, levels = levels(df_with_extremes$Treatment))

# Construct model matrix
X_full_s <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat_size_reef)

# Align columns with posterior samples matrix
X_s <- X_full_s[, colnames(mod.s.reef$Sol), drop = FALSE]

# Generate posterior predictions matrix
pred_matrix_s <- X_s %*% t(mod.s.reef$Sol)  # rows = newdat rows, cols = MCMC samples

# Calculate posterior mean predictions
newdat_size_reef$pred_mean <- rowMeans(pred_matrix_s)

# Calculate 95% credible intervals
newdat_size_reef$lower <- apply(pred_matrix_s, 1, quantile, probs = 0.025)
newdat_size_reef$upper <- apply(pred_matrix_s, 1, quantile, probs = 0.975)

# Calculate pMCMC values: two-tailed test for each posterior distribution
newdat_size_reef$pMCMC <- apply(pred_matrix_s, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance: TRUE if 95% CI excludes zero
newdat_size_reef$significant <- !(newdat_size_reef$lower < 0 & newdat_size_reef$upper > 0)

# Create label with stars for significance
newdat_size_reef$label_combined <- paste0(
  round(newdat_size_reef$pred_mean, 1),
  ifelse(newdat_size_reef$significant, "*", "")
)

#Global
global_mean_post <- colMeans(pred_matrix_s)  # 1 vector of length = n MCMC samples

# Subtract global mean from each group-level posterior draw
diff_matrix_global <- sweep(pred_matrix_s, 2, global_mean_post, FUN = "-")

# pMCMC: two-tailed probability that the difference ≠ 0
pMCMC_vals <- apply(diff_matrix_global, 1, function(x) {
  mean(x < 0) * 2 * (mean(x < 0) < 0.5) + mean(x > 0) * 2 * (mean(x > 0) < 0.5)
})
diff_matrix_global <- as.data.frame(t(apply(diff_matrix_global, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
})))

colnames(diff_matrix_global) <- c("mean_global", "lower_global", "upper_global")

diff_matrix_global$pMCMC <- pMCMC_vals
diff_matrix_global$signif_label_global <- case_when(
  pMCMC_vals < 0.005 ~ "**",
  pMCMC_vals < 0.05  ~ "*",
  TRUE               ~ ""
)
str(diff_matrix_global)


diff_matrix_global$label_combined_global <- paste0(
  round(diff_matrix_global$mean_global, 2),
  diff_matrix_global$signif_label_global
)

diff_matrix_global <- as.data.frame(diff_matrix_global)
diff_matrix_global$significant_vs_global <- with(diff_matrix_global, lower_global > 0 | upper_global < 0)

newdat_size_reef <- cbind(newdat_size_reef, diff_matrix_global)


# Plot predicted larval size changes with significance
ggplot(newdat_size_reef, aes(x = Treatment, y = Cross_2, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted Change in Size (%)") +
  theme_minimal() +
  labs(title = "Predicted Percent Change in Larval Size",
       x = "Treatment", y = "Host Genotype")

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_size_treatment <- MCMCglmm(PercChangeSize ~ Treatment, 
                          random = ~ Replicate , 
                          data = df_with_extremes, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont <- MCMCglmm(PercChangeSize ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = df_with_extremes, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family <- MCMCglmm(PercChangeSize ~ Cross_2, 
                       random = ~ Replicate , 
                       data = df_with_extremes, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_R2(mod_size_treatment, df_with_extremes, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_size_symbiont, df_with_extremes, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_size_family, df_with_extremes, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeSize ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_with_extremes, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_size_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_size_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_size_family, df_with_extremes, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

```

##Cell Density with Source Reef
```{r}
#Cell Density ############################################

# Model and plot excluding 35.5 treatment level

# Ensure factors are ordered
totaldf_long$Treatment <- factor(totaldf_long$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
totaldf_long$Cross_2 <- factor(totaldf_long$Cross_2, 
                                     levels = c("CC", "WW"))
totaldf_long$SymbiontTreatment <- factor(totaldf_long$SymbiontTreatment, 
                                     levels = c("C", "D"))
totaldf_long <- totaldf_long %>%
  mutate(Timepoint = as.numeric(Timepoint)) %>%
  arrange(UniqueID, Timepoint)

df_subset <- totaldf_long %>% filter(Treatment != "35.5")
df_subset$Treatment <- droplevels(df_subset$Treatment)

df_subset$logChangeCells <- log(df_subset$PercChangeCells + 1)

#check how many observations per group
table(df_subset$SymbiontTreatment, df_subset$Cross_2, df_subset$Treatment)

model_subset <- MCMCglmm(
  logChangeCells ~ SymbiontTreatment * Cross_2 * Treatment,
  random = ~ Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_subset)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_subset$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

newdat2_subset <- expand.grid(
  SymbiontTreatment = levels(df_subset$SymbiontTreatment),
  Cross_2 = levels(df_subset$Cross_2),
  Treatment = levels(df_subset$Treatment)  # Only Ambient and 31 here
)

newdat2_subset$SymbiontTreatment <- factor(newdat2_subset$SymbiontTreatment, levels = levels(df_subset$SymbiontTreatment))
newdat2_subset$Cross_2 <- factor(newdat2_subset$Cross_2, levels = levels(df_subset$Cross_2))
newdat2_subset$Treatment <- factor(newdat2_subset$Treatment, levels = levels(df_subset$Treatment))

lapply(newdat2_subset[, c("SymbiontTreatment", "Cross_2", "Treatment")], function(x) length(unique(x)))


X_full_subset <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat2_subset)
X_subset <- X_full_subset[, colnames(model_subset$Sol), drop = FALSE]

pred_matrix_subset <- X_subset %*% t(model_subset$Sol)
newdat2_subset$pred_mean <- rowMeans(pred_matrix_subset)
newdat2_subset$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat2_subset$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat2_subset$significant <- !(newdat2_subset$lower < 0 & newdat2_subset$upper > 0)
newdat2_subset$label_combined <- paste0(round(newdat2_subset$pred_mean, 2),
                                       ifelse(newdat2_subset$significant, "*", ""))
# Calculate pMCMC values: two-tailed test for each posterior distribution
newdat2_subset$pMCMC <- apply(pred_matrix_subset, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

#Global mean
# Vector of posterior means across all groups for each MCMC iteration
global_mean_post_subset <- colMeans(pred_matrix_subset)
# Difference: each group's posterior - global mean at each MCMC iteration
diff_matrix_global_subset <- sweep(pred_matrix_subset, 2, global_mean_post_subset, FUN = "-")
# pMCMC: two-tailed probability that the difference ≠ 0
pMCMC_vals <- apply(diff_matrix_global_subset, 1, function(x) {
  mean(x < 0) * 2 * (mean(x < 0) < 0.5) + mean(x > 0) * 2 * (mean(x > 0) < 0.5)
})
diff_summary_global_subset <- as.data.frame(t(apply(diff_matrix_global_subset, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
})))

colnames(diff_summary_global_subset) <- c("mean_global", "lower_global", "upper_global")

diff_summary_global_subset$pMCMC <- pMCMC_vals
diff_summary_global_subset$signif_label_global <- case_when(
  pMCMC_vals < 0.005 ~ "**",
  pMCMC_vals < 0.05  ~ "*",
  TRUE               ~ ""
)

diff_summary_global_subset$label_combined_global <- paste0(
  round(diff_summary_global_subset$mean_global, 2),
  diff_summary_global_subset$signif_label_global
)

diff_summary_global_subset <- as.data.frame(diff_summary_global_subset)
diff_summary_global_subset$significant_vs_global <- with(diff_summary_global_subset, lower_global > 0 | upper_global < 0)

newdat2_subset <- cbind(newdat2_subset, diff_summary_global_subset)

ggplot(newdat2_subset, aes(x = Treatment, y = Cross_2, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted cell change %") +
  theme_minimal() +
  labs(title = "Predicted Change in Cell Density (No 35.5)",
       x = "Treatment", y = "Host Genotype")



#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_cells_treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = df_subset, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cells_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = df_subset, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cells_family <- MCMCglmm(PercChangeCells ~ Cross_2, 
                       random = ~ Replicate , 
                       data = df_subset, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_subset, full_formula)
r2_treatment <- calc_marginal_R2(mod_cells_treatment, df_subset, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_cells_symbiont, df_subset, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_cells_family, df_subset, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeCells ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_subset, PercChangeCells ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_subset, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_cells_treatment, df_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_cells_symbiont, df_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_cells_family, df_subset, PercChangeCells ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)


```
##Survival GLMM with glmmTMB package and Source Reef
```{r}
# Load libraries
library(dplyr)
library(tidyr)
library(MASS)
library(nlme)
library(emmeans)
library(ggplot2)

# Step 1: Prepare long-format dataset
df_long <- df_Surv %>%
  rowwise() %>%
  mutate(
    Survived = list(c(rep(1, No.LarvaeInObserved), rep(0, Dead_Larvae))),
    LarvaID = list(seq_len(No.LarvaeInObserved + Dead_Larvae))
  ) %>%
  unnest(cols = c(Survived, LarvaID)) %>%
  ungroup() %>%
  mutate(
    symbiont = factor(SymbiontTreatment, levels = c("C", "D")),
    host = factor(Cross_2, levels = c("BxB", "TxT")),
    temperature = factor(Treatment, levels = c("Ambient", "31", "35.5")),
    timepoint = as.factor(Timepoint),
    rep = as.factor(Replicate)
  )

df_trimmed <- df_long %>%
  filter(!(temperature == "35.5" & as.numeric(as.character(timepoint)) > 6))
df_trimmed <- readRDS("df_trimmed.rds")

# Step 2: Fit binomial GLMM
model <- glmmPQL(
  fixed = Survived ~ symbiont * host * temperature,
  random = ~1 | timepoint,
  family = binomial,
  data = df_trimmed
)

summary(model)

#Check model fit
# Residual plot
plot(model)
# Residual deviance / degrees of freedom
deviance <- sum(residuals(model, type = "pearson")^2)
df <- df.residual(model)
dispersion <- deviance / df
dispersion  # Should be close to 1 but is 0

#Tried other models
#1
glm_quasi <- glm(cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature * Timepoint, 
                 data = df_long, 
                 family = quasibinomial())
summary(glm_quasi)

deviance(glm_quasi) / df.residual(glm_quasi)

#2
glm_quasi2 <- glm(cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature, 
                 data = df_trimmed, 
                 family = quasibinomial())
summary(glm_quasi)

#4
mod_survival <- glmmTMB(
  cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature + (1 | Timepoint) +
  (1 | Replicate),
  family = binomial,
  control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000)),
  data = df_trimmed
)
library(DHARMa)
sim_res <- simulateResiduals(mod_survival)
plot(sim_res)
testDispersion(sim_res)
testOutliers(sim_res, type = "bootstrap")

#5
mod_betabin <- glmmTMB( Survived ~ symbiont * host * temperature + 
    (1 | Timepoint / Replicate),
  family = binomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin)
plot(sim_res_beta)
testDispersion(sim_res_beta)

#6
mod_betabin <- glmmTMB( Survived ~ symbiont * host * temperature + 
    (1 | Timepoint / Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin)
plot(sim_res_beta)
testDispersion(sim_res_beta)

#7
#This is the best --> final model
#Can flag and report this in your methods/results as a treatment with high variance and model misfit, possibly due to near-complete mortality or low replicate counts.
library(splines)
mod_betabin2 <- glmmTMB(Survived ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin2)
plot(sim_res_beta)
testDispersion(sim_res_beta)

# Add residuals back to your dataset
df_trimmed$DHARMa_resid <- residuals(sim_res_beta)

# You can also extract standardized residuals explicitly if needed
df_trimmed$DHARMa_resid_std <- residuals(sim_res_beta, type = "scaled")

# Load ggplot2
library(ggplot2)

# Plot residuals by temperature
ggplot(df_trimmed, aes(x = predict(mod_betabin2, type = "response"),
                       y = DHARMa_resid_std)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  facet_wrap(~ temperature) +
  theme_minimal() +
  ylab("Standardized Residuals") +
  xlab("Fitted Values") +
  ggtitle("Residuals vs. Fitted Values by Temperature")

plotResiduals(sim_res_beta, form = df_trimmed$temperature)
plotResiduals(sim_res_beta, form = predict(mod_betabin2, type = "response"))

outliers <- which(sim_res_beta$outliers == TRUE)
df_trimmed[outliers, ]

res_df <- data.frame(
  residuals = sim_res_beta$scaledResiduals,
  fitted = sim_res_beta$fittedPredictedResponse,
  row = 1:nrow(df_trimmed)
)

# Join residuals with original data
res_df_full <- cbind(df_trimmed, res_df)

# View the most extreme residuals (positive or negative)
res_df_full %>%
  dplyr::arrange(desc(abs(residuals))) %>%
  dplyr::select(row, residuals, fitted, temperature, symbiont, host, timepoint, everything()) %>%
  head(10)

library(ggplot2)

ggplot(res_df_full, aes(x = temperature, y = residuals, color = temperature)) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(title = "DHARMa Residuals by Temperature Treatment")


#8
#nope, convergence warning
mod_groupdisp <- glmmTMB(Survived ~ symbiont * host * temperature + 
                           ns(as.numeric(timepoint), df = 4) + 
                           (1 | Replicate),
                         dispformula = ~ temperature,  # group-wise dispersion
                         family = betabinomial(link = "logit"),
                         data = df_trimmed)
anova(mod_betabin2, mod_groupdisp)

# Step 3: Estimated marginal means (EMMs)
emm <- emmeans(mod_betabin2, specs = ~ ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4))
emm_df <- as.data.frame(test(emm, null = 0))

# Add significance stars and clean labels
emm_df <- emm_df %>%
  mutate(
    signif_label = case_when(
      p.value < 0.005 ~ "**",
      p.value < 0.05  ~ "*",
      TRUE            ~ ""
    ),
    label_combined = paste0(round(emmean, 2), signif_label),
    temperature = factor(temperature, levels = c("Ambient", "31", "35.5")),
    host = factor(host, levels = c("BxB", "TxT")),
    symbiont = factor(symbiont, levels = c("C", "D"))
  )

emm_simple <- emmeans(mod_betabin2, specs = ~ symbiont * host * temperature, 
                      model = "response")  # if you want on response scale
emm_df <- as.data.frame(emm_simple)
n <- nrow(emm_df)

contrast_mat <- diag(n) - matrix(1 / n, n, n)
contrast_mat_named <- list("vs_global_mean" = contrast_mat)

contrasts_vs_global <- contrast(emm_simple, method = contrast_mat_named)

summary_contrasts <- summary(contrasts_vs_global, infer = TRUE)

summary_contrasts_df <- summary_contrasts %>%
  as.data.frame() %>%
  mutate(
    signif_label = case_when(
      p.value < 0.005 ~ "**",
      p.value < 0.05  ~ "*",
      TRUE            ~ ""
    ),
    label_combined = paste0(round(estimate, 2), signif_label)
  )

print(summary_contrasts_df)

# Your contrast summary as a data frame
contrast_df <- summary_contrasts_df

# Rename the key columns in the contrast summary
contrast_df <- contrast_df %>%
  rename(
    mean_global = estimate,
    lower_global = asymp.LCL,
    upper_global = asymp.UCL
  )

# The emmeans levels
emm_levels <- emm_df %>% dplyr::select(symbiont, host, temperature)

# Combine
combined_results <- bind_cols(emm_levels, contrast_df)

print(combined_results)

emm_df <- bind_cols(emm_df, combined_results)

# View the output
print(emm_df)


# Step 4: Plot heatmap
ggplot(emm_df, aes(x = temperature, y = host, fill = emmean)) +
  geom_tile(color = "black") +
  geom_text(aes(label = label_combined), size = 4, color = "white") +
  facet_wrap(~ symbiont) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    name = "Log-odds\nSurvival"
  ) +
  labs(x = "Temperature Treatment", y = "Host Genotype",
       title = "Predicted Log-Odds of Survival with Significance") +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text = element_text(size = 10)
  )


# Option 1: Using sjstats
install.packages("sjstats")
install.packages("performance")
library(sjstats)
library(performance)
library(glmmTMB)
library(splines)
library(tibble)


mod_betabin2 <- glmmTMB(Survived ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
# Get marginal R² from full model
r2_full <- r2(mod_betabin2)$R2_marginal

# Fit reduced models — one fixed effect at a time (including ns(timepoint) and random intercept)
mod_symbiont <- glmmTMB(Survived ~ symbiont + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                    family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_symbiont)

mod_host <- glmmTMB(Survived ~ host + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_host)

mod_temp <- glmmTMB(Survived ~ temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_temp)

# Extract marginal and conditional R2
r2_full <- r2(mod_betabin2)
r2_symbiont <- r2(mod_symbiont)
r2_host     <- r2(mod_host)
r2_temp     <- r2(mod_temp)

# Calculate ΔR² for each effect
delta_symbiont <- r2_full$R2_marginal - r2_symbiont$R2_marginal
delta_host     <- r2_full$R2_marginal - r2_host$R2_marginal
delta_temp     <- r2_full$R2_marginal - r2_temp$R2_marginal

# Total ΔR² across all reduced models
total_delta <- delta_symbiont + delta_host + delta_temp

# Relative % contribution of each fixed effect
rel_contrib_symbiont <- 100 * delta_symbiont / total_delta
rel_contrib_host     <- 100 * delta_host     / total_delta
rel_contrib_temp     <- 100 * delta_temp     / total_delta


# Create summary table
summary_df <- tibble(
  Model = c("Full", "Symbiont-only", "Host-only", "Temperature-only"),
  R2_marginal = c(r2_full$R2_marginal, r2_symbiont$R2_marginal, r2_host$R2_marginal, r2_temp$R2_marginal),
  R2_conditional = c(r2_full$R2_conditional, r2_symbiont$R2_conditional, r2_host$R2_conditional, r2_temp$R2_conditional),
  Relative_Contribution = c(NA, rel_contrib_symbiont, rel_contrib_host, rel_contrib_temp)
)

print(summary_df)

# Save results
write.csv(summary_df, "glmmTMB_relative_r2.csv", row.names = FALSE)
saveRDS(summary_df, "glmmTMB_relative_r2.rds")
```
Make a "mega heatmap" with all 4 traits using CROSS_2
```{r}
newdat_size_reef$Trait <- "Larval Size"
newdat.reef$Trait <- "Fv/Fm"
newdat2_subset$Trait <- "Cell Density"
emm_df$Trait <- "Survival"
newdat_perc$Trait <- "Acquisition"

emm_df <- emm_df %>%
  rename(
    mean_global = mean_global,     # Use mean_prob as prediction
    label_combined_global = label_combined)

colnames(emm_df)[1:3] <- c("SymbiontTreatment", "Cross_2", "Treatment")

#emm_df$significant <- emm_df$p.value < 0.05

colnames(newdat_size_reef)[13]   <- "pMCMC_global"
colnames(newdat.reef)[13]   <- "pMCMC_global"
colnames(newdat2_subset)[13]   <- "pMCMC_global"
emm_df           <- emm_df %>% rename(pMCMC_global = p.value)
colnames(newdat_perc)[13]   <- "pMCMC_global"

newdat_perc <- newdat_perc %>%
  rename(Cross_2 = Cross)

newdat_perc <- newdat_perc %>%
  mutate(Cross_2 = recode(Cross_2,
                          "WW" = "TxT",
                          "CC" = "BxB"))

newdat2_subset <- newdat2_subset %>%
  mutate(Cross_2 = recode(Cross_2,
                          "WW" = "TxT",
                          "CC" = "BxB"))

big_heatmap_df <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

ggplot(big_heatmap_df, aes(x = Treatment, y = Cross_2, fill = mean_global)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined_global), color = "black", size = 3) +
  facet_grid(Trait ~ SymbiontTreatment) +
  scale_fill_gradient2(
    name = "Predicted Value",
    low = "blue",      # for negative values
    mid = "white",     # for zero
    high = "red",      # for positive values
    midpoint = 0       # center the scale at zero
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Predicted Trait Responses by Treatment and Symbiont",
    x = "Treatment", y = "Family"
  )


```

Log transformed big heatmap
```{r}
signed_log <- function(x) {
  sign(x) * log1p(abs(x))
}

newdat.reef$mean_global <- signed_log(newdat.reef$mean_global)
newdat_size_reef$mean_global <- signed_log(newdat_size_reef$mean_global)
newdat2_subset$mean_global <- signed_log(newdat2_subset$mean_global)  # Cell density, all positive 
newdat_perc$mean_global <- signed_log(newdat_perc$mean_global) 
# emm_df$pred_mean left as is (survival log-odds)

big_heatmap_df_log <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

# Combine Treatment and SymbiontTreatment into one factor for the x-axis ordering
big_heatmap_df_log <- big_heatmap_df_log %>%
  mutate(
    Treatment_Symbiont = factor(paste(Treatment, SymbiontTreatment, sep = "_"),
                                levels = c(
                                  "Ambient_C", "Ambient_D",
                                  "31_C", "31_D",
                                  "35.5_C", "35.5_D"
                                ))
  )

# Round to 2 decimals and combine with significance
#big_heatmap_df_log <- big_heatmap_df_log %>%
#  mutate(
#label_combined_global2 = ifelse(
#      is.na(mean_global),
#      "",  # leave blank for missing cells
#      paste0(round(mean_global, 0), "\n", signif_label_global)
#    )
#  )

# Compute 5th and 95th percentile of mean_global across the whole dataset
lims <- quantile(big_heatmap_df_log$mean_global, probs = c(0.05, 0.95), na.rm = TRUE)

mega_heatmap <- ggplot(big_heatmap_df_log, aes(x = Treatment_Symbiont, y = Cross_2, fill = mean_global)) +
  geom_tile(color = "black") +
  geom_text(aes(label = label_combined_global), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0 ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Predicted Trait Responses by Treatment and Symbiont",
    x = "Treatment and Symbiont",
    y = "Family"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

mega_heatmap

#ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap.png", plot = mega_heatmap, width = 7, height = 5, dpi = 300)

library(dplyr)

# Normalize within each Trait
big_heatmap_df_log_scaled <- big_heatmap_df_log %>%
 # group_by(Trait) %>%
  mutate(scaled_mean = scale(mean_global)) %>%
 # ungroup() %>%
  # Create a logical column 'significant' based on presence of '*' in label_combined_global
  mutate(significant = str_detect(label_combined_global, "\\*+")) %>%
  # Only fill significant cells, else NA (white)
  mutate(scaled_mean_sig = ifelse(significant, mean_global, NA)) %>%
  # Only label significant cells (optional)
  mutate(label_sig = ifelse(significant, label_combined_global, NA))

mega_heatmap_sig <- ggplot(big_heatmap_df_log_scaled, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = scaled_mean_sig), color = "black") +
  geom_text(aes(label = label_combined_global), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Scaled Mean\n(Fold Change)",
    low = "#3288bd", mid = "white", high = "red", midpoint = 0,
    na.value = "white"
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses by Treatment and Symbiont",
    x = "Treatment and Symbiont",
    y = "Family"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

mega_heatmap_sig

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap_global_mean_percentages.png", plot = mega_heatmap_sig, width = 7, height = 5, dpi = 300)

```
### FINAL HEAT MAP
```{r}
# Store original (untransformed) means before transformation
newdat.reef$raw_mean <- newdat.reef$mean_global
newdat_size_reef$raw_mean <- newdat_size_reef$mean_global
newdat2_subset$raw_mean <- newdat2_subset$mean_global
newdat_perc$raw_mean <- newdat_perc$mean_global

# Now apply signed log to mean_global for coloring
newdat.reef$mean_global <- signed_log(newdat.reef$mean_global)
newdat_size_reef$mean_global <- signed_log(newdat_size_reef$mean_global)
newdat2_subset$mean_global <- signed_log(newdat2_subset$mean_global)
newdat_perc$mean_global <- signed_log(newdat_perc$mean_global)

big_heatmap_df_log2 <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

# Create a new column where only significant cells retain their mean value
big_heatmap_df_log2 <- big_heatmap_df_log2 %>%
  mutate(
    significant = str_detect(label_combined_global, "\\*+"),
    scaled_mean_sig = ifelse(significant, mean_global, NA),
    # Show label in ALL cells regardless of significance
    label_sig = label_combined_global  # <- Don't NA-out nonsignificant cells
  )


# Combine Treatment and SymbiontTreatment into one factor for the x-axis ordering
big_heatmap_df_sigonly <- big_heatmap_df_log2 %>%
  mutate(
    Treatment_Symbiont = factor(paste(Treatment, SymbiontTreatment, sep = "_"),
                                levels = c(
                                  "Ambient_C", "Ambient_D",
                                  "31_C", "31_D",
                                  "35.5_C", "35.5_D"
                                ))
  )


# Plot: only significant cells are colored, others are white
mega_heatmap_sigonly <- ggplot(big_heatmap_df_sigonly, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = scaled_mean_sig), color = "black") +
  geom_text(aes(label = label_sig), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0,
    na.value = "white"  # non-significant cells will be white
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses by Treatment and Symbiont",
    x = "Treatment and Symbiont",
    y = "Family"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

mega_heatmap_sigonly

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap_global_mean_FINAL.png", plot = mega_heatmap_sigonly, width = 7, height = 5, dpi = 300)
```
## Fv/Fm: Exploratory Box Plot
```{r}
library(ggplot2)

ggplot(df_with_extremes, aes(x = interaction(Treatment, Cross_2, SymbiontTreatment), 
                             y = FvFmfinal, 
                             fill = SymbiontTreatment)) +
  geom_boxplot() +
  labs(x = "Treatment x Cross x Symbiont", y = "Final Fv/Fm", 
       title = "Final Fv/Fm by Treatment, Cross, and Symbiont") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


ggplot(df_with_extremes, aes(x = interaction(Treatment, Cross_2, SymbiontTreatment), 
                             y = FvFminitial, 
                             fill = SymbiontTreatment)) +
  geom_boxplot() +
  labs(x = "Treatment x Cross x Symbiont", y = "Final Fv/Fm", 
       title = "Initial Fv/Fm by Treatment, Cross, and Symbiont") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

Survivors Only: Fv/Fm
```{r}
#Fv/Fm #################################################### 
library(MCMCglmm)
library(dplyr)

#subset to survivors
subset_df <- df_with_extremes %>%
  filter(Timepoint == 22, Percent_Survival_atend > 0)

# Set factor levels
subset_df <- subset_df %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
subset_df$Treatment <- factor(subset_df$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df$Cross_2 <- factor(subset_df$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df$SymbiontTreatment <- factor(subset_df$SymbiontTreatment, 
                                     levels = c("C", "D"))

#Set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)


# Fit the model
model3.reef <- MCMCglmm(PercChange ~ SymbiontTreatment * Cross_2 * Treatment, 
                        random = ~ Replicate, 
                        data = subset_df, 
                        family = "gaussian",  
                        prior = prior,
                        nitt = 50000, burnin = 10000, thin = 20)

solution_summary <- summary(model3.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model3.reef$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# Create prediction grid
newdat.reef <- expand.grid(
  SymbiontTreatment = levels(subset_df$SymbiontTreatment),
  Cross_2 = levels(subset_df$Cross_2),
  Treatment = levels(subset_df$Treatment)
)

# Ensure factor levels match
newdat.reef <- newdat.reef %>%
  mutate(across(everything(), ~ factor(.x, levels = levels(subset_df[[cur_column()]]))))

# Generate design matrix
# Model matrix for prediction rows
X_full <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat.reef)
X <- X_full[, names(pmcmc_values), drop = FALSE]  # Make sure columns match

# For each prediction, calculate a "pMCMC-equivalent" value
# This is done by testing whether the *linear combination of coefficients* differs from 0
# using the posterior distribution (model3.reef$Sol)

posterior_preds <- X %*% t(model3.reef$Sol)

newdat.reef$pred_mean <- rowMeans(posterior_preds)
newdat.reef$lower <- apply(posterior_preds, 1, quantile, probs = 0.025)
newdat.reef$upper <- apply(posterior_preds, 1, quantile, probs = 0.975)

# Calculate pMCMC: proportion of posterior samples less than 0 or greater than 0
newdat.reef$pMCMC <- apply(posterior_preds, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance at alpha = 0.05
newdat.reef$significant <- newdat.reef$pMCMC < 0.05


# Create label
newdat.reef$label_combined <- paste0(
  round(as.numeric(as.character(newdat.reef$pred_mean)), 1),
  ifelse(newdat.reef$significant, "*", "")
)

# Make sure pred_mean is numeric for fill
newdat.reef$pred_mean <- as.numeric(as.character(newdat.reef$pred_mean))

# Plot predicted means
ggplot(newdat.reef, aes(x = Treatment, y = Cross_2, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted Change") +
  theme_minimal() +
  labs(title = "Predicted Percent Change in Fv/Fm with pMCMC Significance",
       x = "Temperature", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
model_treatment <- MCMCglmm(
  fixed = PercChange ~ Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_symbiont <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_cross2 <- MCMCglmm(
  fixed = PercChange ~ Cross_2,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_R2(model_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_R2(model_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(model_cross2, subset_df, PercChange ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_conditional_R2(model_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(model_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(model_cross2, subset_df, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),
  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  )
)

print(results_df)

results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)
```
Cell Density and Surival
```{r}
#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

#subset to survivors
subset_df_cells <- df_subset %>%
  filter(Timepoint == 22, Percent_Survival_atend > 0)

# Set factor levels
subset_df_cells <- subset_df_cells %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
subset_df_cells$Treatment <- factor(subset_df_cells$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df_cells$Cross_2 <- factor(subset_df_cells$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df_cells$SymbiontTreatment <- factor(subset_df_cells$SymbiontTreatment, 
                                     levels = c("C", "D"))


# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_cells_treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = subset_df_cells, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cells_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = subset_df_cells, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cells_family <- MCMCglmm(PercChangeCells ~ Cross_2, 
                       random = ~ Replicate , 
                       data = subset_df_cells, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df_cells, full_formula)
r2_treatment <- calc_marginal_R2(mod_cells_treatment, subset_df_cells, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_cells_symbiont, subset_df_cells, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_cells_family, subset_df_cells, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeCells ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df_cells, PercChangeCells ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df_cells, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_cells_treatment, subset_df_cells, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_cells_symbiont, subset_df_cells, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_cells_family, subset_df_cells, PercChangeCells ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)


```
Larval Size with Survivors only
```{r}
#Larval Size #####################################

# Ensure factors are ordered
subset_df$Treatment <- factor(subset_df$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df$Cross_2 <- factor(subset_df$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df$SymbiontTreatment <- factor(subset_df$SymbiontTreatment, 
                                     levels = c("C", "D"))

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_size_treatment <- MCMCglmm(PercChangeSize ~ Treatment, 
                          random = ~ Replicate , 
                          data = subset_df, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont <- MCMCglmm(PercChangeSize ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = subset_df, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family <- MCMCglmm(PercChangeSize ~ Cross_2, 
                       random = ~ Replicate , 
                       data = subset_df, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_R2(mod_size_treatment, subset_df, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_size_symbiont, subset_df, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_size_family, subset_df, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeSize ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_size_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_size_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_size_family, subset_df, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

library(readr)

tantabiddi_data <- read_csv(url_tantabiddi)
head(tantabiddi_data)

```

##Get temp data
```{r}
install.packages("rerddap")
library(rerddap)
library(httr)
library(readr)
library(utils)

library(rerddap)

dataset_id <- "NOAA_DHW_monthly"

# Info object
sstInfo <- info(dataset_id)

# Define bounding box around Tantabiddi, ~0.02° (~2 km)
lat_range <- c(-21.95, -21.93)
lon_range <- c(113.95, 113.97)

# Date range (dataset starts 1985-01-16)
time_range <- c("1985-01-16", "2024-12-16")

# Grab SST variable ('sst' per dataset docs)
tantabiddi_sst <- griddap(sstInfo,
                          latitude = lat_range,
                          longitude = lon_range,
                          fields = "sea_surface_temperature")

# Brubdjoo coordinates ~ -23.63 S, 113.88 E
brubdjoo_sst <- griddap(sstInfo,
  latitude = c(-22.9744, -22.9244),
  longitude = c(113.7525, 113.8025),
  fields = "sea_surface_temperature"
)

tantabiddi_data <- tantabiddi_sst$data
bruboodjoo_data <- brubdjoo_sst$data

library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)

# Add a site column
tantabiddi_data <- tantabiddi_data %>% mutate(site = "Tantabiddi")
bruboodjoo_data  <- bruboodjoo_data  %>% mutate(site = "Bruboodjoo")

# Combine data
all_data <- bind_rows(tantabiddi_data, bruboodjoo_data)

# Convert time to Date
all_data <- all_data %>%
  mutate(time = as.Date(time))

# Extract year and month
all_data <- all_data %>%
  mutate(year = year(time),
         month = month(time, label = TRUE, abbr = TRUE))

# Average SST over lat/lon for each site x time
site_monthly <- all_data %>%
  group_by(site, time) %>%
  summarize(mean_sst = mean(sea_surface_temperature, na.rm = TRUE), .groups = "drop")

# Calculate mean monthly SST (averaged across years) for each site
mean_monthly <- site_monthly %>%
  mutate(month = month(time)) %>%
  group_by(site, month) %>%
  summarize(mean_sst = mean(mean_sst, na.rm = TRUE), .groups = "drop")

# Calculate mean annual SST for each site and year
mean_annual <- site_monthly %>%
  mutate(year = year(time)) %>%
  group_by(site, year) %>%
  summarize(mean_sst = mean(mean_sst, na.rm = TRUE), .groups = "drop")

ggplot(mean_monthly, aes(x = month, y = mean_sst, color = site, group = site)) +
  geom_line(size = 1.2) +
  geom_point() +
  labs(title = "Mean Monthly SST (1985–2024)",
       x = "Month",
       y = "SST (°C)",
       color = "Site") +
  theme_minimal()

# Add site column
tantabiddi <- tantabiddi_sst$data %>% mutate(site = "Tantabiddi")
bruboodjoo <- brubdjoo_sst$data %>% mutate(site = "Bruboodjoo")


# Ensure time is Date format
all_sst <- all_sst %>%
  mutate(
    time = as.Date(time),
    year = year(time),
    month = month(time, label = TRUE, abbr = TRUE),
    month_num = month(time)
  )

monthly_per_year <- all_sst %>%
  group_by(site, year, month, month_num) %>%
  summarise(
    monthly_mean = mean(sea_surface_temperature, na.rm = TRUE),
    .groups = "drop"
  )

monthly_summary <- monthly_per_year %>%
  group_by(site, month, month_num) %>%
  summarise(
    mean_sst = mean(monthly_mean, na.rm = TRUE),
    sd_sst = sd(monthly_mean, na.rm = TRUE),
    se_sst = sd_sst / sqrt(n()),
    .groups = "drop"
  )

overall_mean_sst <- all_sst %>%
  group_by(site) %>%
  summarise(overall_mean = mean(sea_surface_temperature, na.rm = TRUE))


plot_monthly_sst <- ggplot(monthly_summary, aes(x = reorder(month, month_num), y = mean_sst, color = site, group = site)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_sst - se_sst, ymax = mean_sst + se_sst), width = 0.2) +
  geom_hline(data = overall_mean_sst, aes(yintercept = overall_mean, color = site), linetype = "dashed") +
  scale_color_manual(
  values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")  
  )+ 
  labs(
    title = "Mean Monthly SST with Error Bars (1985–2025)",
    x = "Month",
    y = "SST (°C)",
    color = "Site"
  ) +
  theme_minimal()

#Annual mean plots
annual_means <- all_sst %>%
  mutate(year = lubridate::year(time)) %>%
  filter(year < 2025) %>%  # remove partial year
  group_by(site, year) %>%
  summarise(mean_annual_sst = mean(sea_surface_temperature, na.rm = TRUE), .groups = "drop")

plot_annual_sst <- ggplot(annual_means, aes(x = site, y = mean_annual_sst, fill = site)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  geom_jitter(width = 0.1, alpha = 0.4) +  # optional: show individual years
  geom_boxplot(width = 0.1, outlier.shape = NA, color = "black", fill = "white") +  # optional: summary inside violin
  scale_fill_manual(values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")) +
  labs(
    title = "Mean Annual SST (1985–2025)",
    x = "Site",
    y = "Mean Annual SST (°C)"
  ) +
  theme_minimal()


```

## Site Map
```{r}
# Load required libraries
#install.packages("rnaturalearth")
#install.packages("rnaturalearthdata")
#install.packages("ggspatial")
library(rnaturalearth)
library(rnaturalearthdata)
library(ggplot2)
library(dplyr)
library(sf)
library(ggspatial)

# Load world map and ocean shapefiles
worldmap <- st_as_sf(ne_countries(scale = "medium", returnclass = "sf"))
ocean_data <- st_as_sf(ne_download(scale = "medium", type = "ocean", category = "physical"))

# Define map extent for Ningaloo Reef
lon_bounds <- c(112, 115)
lat_bounds <- c(-25, -20)

# Create data frame for site coordinates
sites <- data.frame(
  site = factor(c("Tantabiddi", "Bruboodjoo"), levels = c("Tantabiddi", "Bruboodjoo")),
  lon = c(113.957373, 113.777517),
  lat = c(-21.918595, -22.949383)
)

# Convert to sf object
sites_sf <- st_as_sf(sites, coords = c("lon", "lat"), crs = 4326)

# Install if you haven't already
if (!requireNamespace("remotes")) install.packages("remotes")
remotes::install_github("ropensci/rnaturalearthhires")

# Load countries at scale 10 (highest detail)
worldmap_hi <- ne_countries(scale = 10, returnclass = "sf")

australia <- worldmap_hi %>% dplyr::filter(admin == "Australia")

ocean <- ne_download(scale = 10, type = "ocean", category = "physical", returnclass = "sf")

# Read the shapefile (adjust path and file name as needed)
reef_layer <- st_read("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/worldheritagemarineprogramme.shp")

st_crs(reef_layer)  # check current CRS
reef_layer <- st_transform(reef_layer, crs = 4326)  # reproject if needed


ningaloo <- ggplot() +
  # 1. Ocean background — goes in the back
  geom_sf(data = ocean, fill = "aliceblue", color = NA) +

  # 2. Reef layer — now on top of ocean
  geom_sf(data = reef_layer, fill = "lightgreen", color = NA, alpha = 0.6) +

  # 3. Land on top of reef + ocean
  geom_sf(data = australia, fill = "cornsilk", color = "black") +

  # 4. Site points on top of everything
  geom_sf(data = sites_sf, aes(color = site), size = 3) +

  # Zoom to Ningaloo
  coord_sf(xlim = c(113, 115), ylim = c(-24, -21), expand = FALSE) +

  # Site colors and legend
  scale_color_manual(
    name = "Collection Site",
    values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")
  ) +
  annotation_north_arrow(
  location = "tr",         # "tr" = top right
  which_north = "true",    # "true" = geographic north
  style = north_arrow_fancy_orienteering,  # or choose other styles
  height = unit(1.2, "cm"),
  width = unit(1.2, "cm")
) +

  theme_minimal() +
  theme(
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA),
    axis.text = element_text(color = "black"),
    axis.title = element_text(color = "black")
  ) +
  xlab("Longitude") +
  ylab("Latitude")

ggsave("Ningaloo_Map.png", plot = ningaloo, device = "png")
```
## Combine plots
```{r}
library(patchwork)

combined_plot <- 
  ningaloo + 
  plot_monthly_sst + 
  plot_annual_sst + 
  plot_layout(ncol = 3, guides = "collect") & 
  theme(legend.position = "bottom")

combined_plot

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Ningaloo_Site_Map_SST.png", plot = combined_plot, device = "png", width = 10, height = 5, dpi = 300)
```
##Save environment
```{r}
save.image(file = "C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/my_environment_13_6_25.RData")
```

