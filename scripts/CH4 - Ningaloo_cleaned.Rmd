---
title: "R Notebook"
output: html_notebook
---

Load necessary packages and functions

```{r}
library('ggplot2'); packageVersion('ggplot2') #version 3.5.0
library(dplyr)
library(tidyr)
library(stats)
library(nlme)
library(glmmTMB)
library(DHARMa)
library(MCMCglmm)
library(coda)
library(parallel)
library(emmeans)
install.packages("tidybayes")
library(tidybayes)

```

Cell Density Boxplot

```{r}
setwd("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment")
cells <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/celldensity.csv", header = TRUE)
str(cells)

# Make Treatment a factor
cells$Treatment <- factor(cells$Treatment, levels = c("Ambient", "31", "35.5"))
treatment_colors <- c("Ambient" = "green", "31" = "orange", "35.5" = "red")

# Reshape the data so that all 3 cell counts are combined
cells_long <- cells %>%
  pivot_longer(cols = starts_with("No.Cells"), 
               names_to = "Measurement", 
               values_to = "CellDensity",
               values_drop_na = TRUE)

# Create the box plot
celldenboxplot = ggplot(cells_long, aes(x = Cross, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  labs(title = "Box Plot of Cell Density by Cross and Treatment",
       x = "Cross",
       y = "Cell Density") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = treatment_colors)

ggsave("celldensityboxplot_family.jpg", plot = celldenboxplot, width = 25, height = 15)

#Stats for Cell Density

# provided a very small p-value (< 2.2e-16), indicating strong evidence against the null hypothesis of normality
shapiro.test(cells_long$CellDensity)
#data is nonparametric

# Perform Kruskal-Wallis test
kw_result <- kruskal.test(CellDensity ~ Treatment, data = cells_long)

# Check test result
print(kw_result)

#Kruskal-Wallis rank sum test
#data:  CellDensity by Treatment
#Kruskal-Wallis chi-squared = 90.004, df = 2, p-value < 2.2e-16

#Based on this result, you can conclude that there is a statistically significant difference in cell density among the different treatments (Ambient, 31, and 35.5).

# Example of pairwise Wilcoxon rank-sum test (pairwise comparisons)
pairwise.wilcox.test(cells_long$CellDensity, cells_long$Treatment, p.adjust.method = "bonferroni")

#Ambient vs. 31: The p-value is approximately 1, indicating no significant difference in cell density between Ambient and 31 treatments.
#Ambient vs. 35.5: The adjusted p-value is < 2e-16, indicating a highly significant difference in cell density between Ambient and 35.5 treatments.
#31 vs. 35.5: The adjusted p-value is also < 2e-16, indicating a highly significant difference in cell density between 31 and 35.5 treatments.

```

Cell Density Plot
```{r}
# Pivot longer to separate T.Start and T.End into separate rows for each TubeID
cells_long <- cells %>%
  select(-starts_with("No.Cells")) %>%  # Remove No.Cells columns to avoid extra points
  pivot_longer(
    cols = c(Cells.Start, Cells.End.Average),  # Only reshaping Cells.Start and Cells.End.Average
    names_to = "TimePoint",  # New column for TimePoint
    values_to = "CellDensity"  # Cell density values will go into this column
  ) %>%
  mutate(
    TimePoint = case_when(
      TimePoint == "Cells.Start" ~ "T.Start",  # Rename for clarity
      TimePoint == "Cells.End.Average" ~ "T.End"
    ),
    DayNumber = case_when(
      TimePoint == "T.Start" ~ T.Start,  # Start day
      TimePoint == "T.End" ~ T.End  # End day
    ),
    CellDensity = as.numeric(CellDensity)  # Ensure numeric values
  )

# Check the structure of the reshaped data
str(cells_long)

# Filter for only TubeIDs that have both DayNumber 0 and 23
cells_long_filtered <- cells_long %>%
  filter(DayNumber %in% c(0, 23)) %>%
  group_by(TubeID) %>%
  filter(all(c(0, 23) %in% DayNumber)) %>%  # Ensure both DayNumber 0 and 23 are present
  ungroup()  # Ungroup the data

# Step 2: Summarize data for surviving larvae by ReefMom, SymbiontTreatment, and TREATMENT
summary_df_cells <- cells_long_filtered %>%
  group_by(DayNumber, Treatment, Cross, CellType) %>%
  summarize(CellDensity = mean(CellDensity, na.rm = TRUE), .groups = "drop")

# Custom color palette for Cross
custom_ReefMom_colors <- c("coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue")

# Plot cell density across timepoints
ggplot(summary_df_cells, aes(x = DayNumber, y = CellDensity, color = Cross, shape = CellType)) +
  geom_point(alpha = 0.8, size = 3) +
  geom_line(aes(group = interaction(Cross, CellType)), alpha = 0.6) +  
  facet_wrap(~ Treatment) +  # Create separate plots for each TubeID
  scale_color_manual(values = custom_ReefMom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0,2,4,6,8,10,12,14,16,18,20,22),  # Add breaks for specific days
    labels = c("0","2","4","6","8","10","12","14","16","18","20","22")  # Label days
  ) +
  theme_classic() +
  labs(title = "Cell Density by Timepoint for Each TubeID",
       x = "Timepoint",
       y = "Cell Density")

################################

# Pivot longer to separate T.Start and T.End into separate rows for each TubeID
cells_long <- cells %>%
  select(-starts_with("No.Cells")) %>%  # Remove No.Cells columns to avoid extra points
  pivot_longer(
    cols = c(Cells.Start, Cells.End.Average),  # Only reshaping Cells.Start and Cells.End.Average
    names_to = "TimePoint",  # New column for TimePoint
    values_to = "CellDensity"  # Cell density values will go into this column
  ) %>%
  mutate(
    TimePoint = case_when(
      TimePoint == "Cells.Start" ~ "T.Start",  # Rename for clarity
      TimePoint == "Cells.End.Average" ~ "T.End"
    ),
    DayNumber = case_when(
      TimePoint == "T.Start" ~ T.Start,  # Start day
      TimePoint == "T.End" ~ T.End  # End day
    ),
    CellDensity = as.numeric(CellDensity),  # Ensure numeric values
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Ensure all treatments are retained
  )

# Check the structure of the reshaped data
str(cells_long)

# Filter for specific conditions:
# 1. Keep all rows for Treatment = 35.5 with DayNumber = 0
# 2. For other treatments, keep TubeIDs with both DayNumber 0 and 23
cells_long_filtered <- cells_long %>%
  filter(
    (Treatment == "35.5" & DayNumber == 0) |  # Keep Day 0 for Treatment 35.5
    (Treatment != "35.5" & DayNumber %in% c(0, 23))  # For other treatments, keep Day 0 and 23
  ) %>%
  group_by(TubeID) %>%
  filter(
    (Treatment == "35.5" & DayNumber == 0) |  # Ensure Day 0 is always kept for 35.5
    all(c(0, 23) %in% DayNumber)  # Ensure both DayNumber 0 and 23 are present for other treatments
  ) %>%
  ungroup()

# Summarize data for surviving larvae by Treatment, Cross, and CellType
summary_df_cells <- cells_long_filtered %>%
  group_by(DayNumber, Treatment, Cross, CellType, TubeID) %>%
  summarize(CellDensity = mean(CellDensity, na.rm = TRUE), .groups = "drop")

# Verify that all treatments are present
distinct(summary_df_cells, Treatment)

# Custom color palette for Cross
custom_ReefMom_colors <- c("coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue")

# Plot cell density across timepoints
ggplot(summary_df_cells, aes(x = DayNumber, y = CellDensity, color = Cross, shape = CellType)) +
  geom_point(alpha = 0.8, size = 3) +
  geom_line(aes(group = interaction(Cross, CellType)), alpha = 0.6) +  
  facet_wrap(~ Treatment, ncol = 3) +  # Ensure consistent facet layout with empty facets for missing data
  scale_color_manual(values = custom_ReefMom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22),  # Add breaks for specific days
    labels = c("0", "2", "4", "6", "8", "10", "12", "14", "16", "18", "20", "22")  # Label days
  ) +
  theme_classic() +
  labs(
    title = "Cell Density by Timepoint for Each Treatment",
    x = "Timepoint",
    y = "Cell Density"
  )


```

Two-Way Repeated Measures ANOVA
2 predictors: Treatment and CellType

```{r}
# 1. Check assumptions 
########### TREATMENT #############
# Convert Treatment to a factor
cells_long$Treatment <- factor(cells_long$Treatment)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$Treatment)

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, Treatment=='Ambient')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='31')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='35.5')$CellDensity)
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############
# Convert CellType to a factor
cells_long$CellType <- factor(cells_long$CellType)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$CellType)

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, CellType=='C')$CellDensity)
shapiro.test(subset(cells_long, CellType=='D')$CellDensity)
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$CellType)
# Bartlett's K-squared = 24.126, df = 1, p-value = 9.024e-07
# NOT HOMOGENOUS

# 2. Assumptions are not met: Try scale transformations

########### TREATMENT #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$Treatment) # square root transformed because we have counts

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, Treatment=='Ambient')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='31')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='35.5')$CellDensity))
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$CellType) # square root transformed because we have counts

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, CellType=='C')$CellDensity))
shapiro.test(sqrt(subset(cells_long, CellType=='D')$CellDensity))
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$CellType)
# Bartlett's K-squared = 4.5066, df = 1, p-value = 0.03377
# HOMOGENOUS

# 3. Do non-parametric test by rank-transforming the data
rDV<-rank(cells_long$CellDensity)

lme.rank<-lme(fixed = rDV ~ Treatment * CellType, random=~1|Cross, data = cells_long)
celldenanova <- anova (lme.rank)
#                       numDF       denDF      F-value       p-value
# (Intercept)             1         358        518.9960     <0.0001
# Treatment               2         358         64.6619     <0.0001
# CellType                1         358         1.8426      0.1755
# Treatment:CellType      2         358         5.1615      0.0062

plot(CellDensity ~ Treatment*CellType, data = cells_long)

# Treatment: F(2, 358) = 64.6619, p = <0.0001
# CellType: NOT sig
# Interaction: F(2, 358) = 5.1615, p = 0.0062

```

Analyze significant interaction Treatment*CellType

```{r}
interaction.plot(cells_long$CellType, cells_long$Treatment, cells_long$CellDensity, 
                 xlab="CellType", ylab="CellDensity", trace.label="Treatment")

# Example using pairwise comparisons
pairwise.t.test(cells_long$CellDensity, interaction(cells_long$Treatment, cells_long$CellType), p.adjust.method = "bonferroni")
#	Pairwise comparisons using t tests with pooled SD 

#data:  cells_long$CellDensity and interaction(cells_long$Treatment, cells_long$CellType) 

#          Ambient.C 31.C    35.5.C  Ambient.D 31.D   
#31.C      0.05188   -       -       -         -      
#35.5.C    0.00012   1.00000 -       -         -      
#Ambient.D 0.01986   1.00000 1.00000 -         -      
#31.D      1.00000   1.00000 0.03891 1.00000   -      
#35.5.D    0.00012   1.00000 1.00000 1.00000   0.03891

#P value adjustment method: bonferroni 
library(emmeans)
# Fit the linear mixed-effects model
lme.rank <- lme(fixed = rDV ~ Treatment * CellType, random = ~1|Cross, data = cells_long)

# Obtain the estimated marginal means
emm <- emmeans(lme.rank, ~ Treatment * CellType)

# Perform Tukey's post hoc test
tukey_result <- pairs(emm, adjust = "tukey")

# Print the results
print(tukey_result)

# Load necessary libraries
library(ggplot2)

# Create boxplot with facets by CellType and colors by Treatment
cells_long$Treatment <- factor(cells_long$Treatment, levels = c("Ambient", "31", "35.5"))


ggplot(cells_long, aes(x = Treatment, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  facet_grid(. ~ CellType) +
  labs(title = "Boxplot of Cell Density by Treatment and Cell Type",
       x = "Treatment",
       y = "Cell Density",
       fill = "Treatment") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = c("Ambient" = "green","31" = "orange", "35.5" = "red"))

# Contrast for the difference in changes between CellTypes
contrast.emm <- contrast(emm, interaction = "pairwise", method = "revpairwise")
contrast.emm


```

Survival Analysis
Cox model: with Treatment and ReefMom

```{r}
setwd("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment")

metadata = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE)
str(metadata)

# Determine the class of the Factors (not the covariates):
class(metadata$Treatment)
class(metadata$SymbiontTreatment)
class(metadata$ReefMom)
#If any of the factors is not a “factor”, redefine it as a factor:
metadata$Treatment <- factor(metadata$Treatment)
metadata$SymbiontTreatment <- factor(metadata$SymbiontTreatment)
metadata$ReefMom <- factor(metadata$ReefMom)
attach (metadata)

# Create the Status column
# Zero = Alive
metadata$Status <- ifelse(metadata$`Alive, Dead, Sampled` == "Alive", 0, 1)
# Check for missing values in the columns used in the model
sum(is.na(metadata$Timepoint))
sum(is.na(metadata$Status))
sum(is.na(metadata$Treatment))
sum(is.na(metadata$SymbiontTreatment))
sum(is.na(metadata$ReefMom))

# Keep the entire metadata dataset, but filter out rows with NA in specific columns
metadata_clean <- metadata %>%
  filter(!is.na(Timepoint) & !is.na(Status) & !is.na(Treatment) & !is.na(SymbiontTreatment) & !is.na(ReefMom))

# Check the dimensions to ensure you retain all necessary columns
dim(metadata_clean)  # Check number of rows and columns

# Verify the changes
head(metadata)

#Install package survival
library(survival)
X<-cbind(metadata_clean$Treatment, metadata_clean$SymbiontTreatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox<- coxph (Surv(Timepoint, Status)~ X, method='breslow', data = metadata_clean)
summary(cox)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                       coef exp(coef) se(coef)      z Pr(>|z|)    
#XTreatment         -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#XSymbiontTreatment  0.04804   1.04921  0.06201  0.775  0.43848    
#XReefMom           -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#                   exp(coef) exp(-coef) lower .95 upper .95
#XTreatment            0.7831     1.2770    0.7262    0.8445
#XSymbiontTreatment    1.0492     0.9531    0.9291    1.1848
#XReefMom              0.9588     1.0430    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.83  on 3 df,   p=1e-10
#Wald test            = 48.21  on 3 df,   p=2e-10
#Score (logrank) test = 48.62  on 3 df,   p=2e-10

# Not all predictors are significant so use backward stepwise model selection to remove the most insignificant factor (symbiont treatment)

X2<-cbind(metadata_clean$Treatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox2<- coxph (Surv(Timepoint, Status)~ X2, method='breslow', data = metadata_clean)
summary(cox2)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X2, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                coef exp(coef) se(coef)      z Pr(>|z|)    
#X2Treatment -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#X2ReefMom   -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#            exp(coef) exp(-coef) lower .95 upper .95
#X2Treatment    0.7831      1.277    0.7262    0.8445
#X2ReefMom      0.9588      1.043    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.23  on 2 df,   p=3e-11
#Wald test            = 47.61  on 2 df,   p=5e-11
#Score (logrank) test = 48.02  on 2 df,   p=4e-11

# Compare models
AIC(cox, cox2) #cox2 has the lowest AIC so we keep it

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km <-survfit(Surv(Timepoint,Status)~ Treatment + ReefMom, data = metadata_clean) # do not include interactions
km
summary(km)

# Plot the survival curves
library(survival)
km$strata

# Plot the Kaplan-Meier curve
plot(km, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
install.packages("survminer")
library(survminer)
require("survival")
ggsurvplot(km)
# Create a combined label for legend
metadata_clean$combined_label <- with(metadata_clean, paste(Treatment, ReefMom, sep = "."))

# Now refit the survival object
km <- survfit(Surv(Timepoint, Status) ~ combined_label, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.ReefMom",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET
library(survival)

# Fit the Kaplan-Meier survival curve
km2 <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom, data = metadata_clean)

ggsurv <- ggsurvplot(km2, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

library(survival)
library(survminer)
library(dplyr)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names <- c("coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue"
)

levels(km2$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km2, conf.int = TRUE, 
                     palette = custom_curve_names,  # Custom color palette
                     legend.title = "ReefMom",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
survival_curves_facet_ReefMom <- ggsurv$plot + 
    theme_bw() + 
    facet_wrap(~ Treatment)  # Faceting by Treatment

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_ReefMom.png", plot = survival_curves_facet_ReefMom, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pairs <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + ReefMom, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pairs

# Symbolic number coding
symnum(pairs$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")


#########
# Interactions with SymbiontTreatment are significant
########
# Fit Cox proportional hazards model with interactions
cox.int <- coxph(Surv(Timepoint, Status) ~ Treatment * SymbiontTreatment * ReefMom, 
             method = 'breslow', data = metadata_clean)

# Display the summary of the model
summary(cox.int)
cox.zph(cox.int) # use this function to confirm p-values from interactions

#########
# Plot for visual
########
km.symb <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom + SymbiontTreatment, data = metadata_clean)
summary(km.symb)

# Create custom color names for each curve
custom_curve_names2 <- c("coral2","coral2", "orange","orange","darkkhaki","darkkhaki","aquamarine3","aquamarine3","darkred","darkred","darkorchid","darkorchid","blue","blue","coral2","coral2", "orange","orange","darkkhaki","darkkhaki","aquamarine3","aquamarine3","darkred","darkred","darkorchid","darkorchid","blue","blue","coral2","coral2", "orange","orange","darkkhaki","darkkhaki","aquamarine3","aquamarine3","darkred","darkred","darkorchid","darkorchid","blue","blue")
                        
# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km.symb, conf.int = TRUE, 
                     palette = custom_curve_names2,  # Custom color palette
                     legend.title = "ReefMom",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
survival_curves_facet_Symb <- ggsurv$plot + 
    theme_bw() + 
    facet_wrap(~ Treatment + SymbiontTreatment)  # Faceting by Treatment and SymbiontTreatment

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_Symb.png", plot = survival_curves_facet_Symb, width = 20, height = 5, dpi = 300)

#########################
# Extract survival probabilities at a specific time, e.g., time = 22
surv_summary_symb <- summary(km.symb, times = 22)

# Print the survival probability
print(surv_summary_symb$surv)

pairs_symb <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + ReefMom + SymbiontTreatment, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pairs_symb


```

Survival Analysis
Cox model: with Treatment and Cross_2 (source reef)

```{r}
# Determine the class of the Factors (not the covariates):
class(metadata_clean$Cross_2)
#If any of the factors is not a “factor”, redefine it as a factor:
metadata_clean$Cross_2 <- factor(metadata_clean$Cross_2)
# Check for missing values in the columns used in the model
sum(is.na(metadata_clean$Cross_2))

#Install package survival
library(survival)
X3<-cbind(metadata_clean$Treatment, metadata_clean$Cross_2)# if you don’t have covariates, do not include them
# if observations are right censored:
cox3 <- coxph (Surv(Timepoint, Status)~ X3, method='breslow', data = metadata_clean)
summary(cox)

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km3 <-survfit(Surv(Timepoint,Status)~ Treatment + Cross_2, data = metadata_clean) # do not include interactions
km3
summary(km3)

# Plot the survival curves
library(survival)
km3$strata

# Plot the Kaplan-Meier curve
plot(km3, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
install.packages("survminer")
library(survminer)
require("survival")
ggsurvplot(km3)
# Create a combined label for legend
metadata_clean$combined_label2 <- with(metadata_clean, paste(Treatment, Cross_2, sep = "."))

# Now refit the survival object
km4 <- survfit(Surv(Timepoint, Status) ~ combined_label2, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label2))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km4, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.Cross_2",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET
library(survival)

# Fit the Kaplan-Meier survival curve
km5 <- survfit(Surv(Timepoint, Status) ~ Treatment + Cross_2, data = metadata_clean)

summary(km5)

ggsurv <- ggsurvplot(km5, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names2 <- c("aquamarine3", "orange", "aquamarine3", "orange", "aquamarine3", "orange")

levels(km5$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km5, conf.int = TRUE, 
                     palette = custom_curve_names2,  # Custom color palette
                     legend.title = "Source Reef",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
final_plot <- ggsurv$plot + 
              theme_bw() + 
              facet_wrap(~ Treatment)  # Faceting by Treatment

# Save the plot using ggsave
ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_SourceReef.png", plot = final_plot, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + Cross_2, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair

# Symbolic number coding
symnum(pair$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")

# Extract survival probabilities at a specific time, e.g., time = 22
# You can do this using the 'summary()' function with the 'time' argument
surv_summary <- summary(km5, times = 22)

# Print the survival probability at time 50
print(surv_summary$surv)  # This gives the survival probabilities

#at day 22:
# ambient BxB = 0.4891414 +- 0.0836
# ambient TxT = 0.8182818 +- 0.0693
# 31 BxB = 0.1330052 +- 0.0438
# 31 TxT = 0.1398107 +- 0.0406
# 35.5 = 0.0000000 and 0.0000000


```

Survival Analysis
Just Treatment as a variable

```{r}
# Fit the Kaplan-Meier survival curve
km6 <- survfit(Surv(Timepoint, Status) ~ Treatment, data = metadata_clean)

summary(km6)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair2 <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair2
```

Load in Ningaloo metadata and restructure

```{r}
#install.packages("MCMCglmm")
library(MCMCglmm)
#install.packages("lsmeans")
library(emmeans)

totaldf = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE)
str(totaldf)

library(tidyr)

# Convert No.Cells1 to numeric
totaldf$No.Cells1 <- as.numeric(totaldf$No.Cells1)

# Reshape the data to long format so all of the cell densities are in one column
totaldf_long <- totaldf %>%
  pivot_longer(cols = c(No.Cells1, No.Cells2, No.Cells3), 
               names_to = "Cell_Measurement", 
               values_to = "Cell_Density")

# Check the structure of the reshaped data
str(totaldf_long)

# Replace empty strings with NA
totaldf_long$Cell_Density[totaldf_long$Cell_Density == ""] <- NA

# Convert the Cell_Density column to numeric 
totaldf_long$Cell_Density <- as.numeric(totaldf_long$Cell_Density)

# Check for missing values in each of the predictor columns
sum(is.na(totaldf_long$SymbiontTreatment))
sum(is.na(totaldf_long$Family))
sum(is.na(totaldf_long$Treatment))
sum(is.na(totaldf_long$Timepoint))  

# Keep rows up to 8316. After that they are just blank rows that got imported.
totaldf_long_subset <- totaldf_long[1:8316, ]

# Check the structure of the subset data frame
str(totaldf_long_subset)

totaldf_long_clean <- totaldf_long_subset %>%
  filter(!is.na(totaldf_long_subset$SymbiontTreatment) & !is.na(totaldf_long_subset$Family) & !is.na(totaldf_long_subset$Treatment) & !is.na(totaldf_long_subset$Timepoint))

# df is the main dataframe we'll be using
df <- totaldf_long_clean

# Assign Temp values based on Treatment
df_clean <- df %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ NA_character_  # Handle other cases explicitly
  ))

# Create a UniqueID column by combining Temp and tube.ID columns
df_clean$UniqueID <- paste0(df_clean$Temp, "V", df_clean$tube.ID.1)

```

Survival with binomial GLMM (Family) --> glmmTMB --> frequentist method

```{r}
#Check variables in dataset
str(df)
class(df$SymbiontTreatment) #iv
class(df$Family) #iv
class(df$Temp) #iv
class(df$Timepoint) #dv
class(df$Replicate) #dv

#Change categorical variables to factors
df$SymbiontTreatment<-factor(df$SymbiontTreatment)
df$Family<-factor(df$Family)
df$Temp<-factor(df$Temp)
df$Timepoint<-factor(df$Timepoint)
df$Replicate<-factor(df$Replicate)

# Check the levels of your categorical variables
levels(df$SymbiontTreatment)
levels(df$Family)
levels(df$Temp)
levels(df$Timepoint)
levels(df$Replicate)

#We want Temp as T1, T2, T3 for creating a unique tube ID later on. This line of code says that when Treatment = Ambient, Temp will = T1
df <- df %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ as.character(Temp)  # Keep other values unchanged
  ))

#Convert Percent_Survival_atend from percentage (0-100) to decimal (0-1) for a binomial model
df_Surv <- df %>%
  mutate(Percent_Survival_atend = Percent_Survival_atend / 100)
df_Surv <- df_Surv %>%
  mutate(Dead_Larvae = No.LarvaeInExpected - No.LarvaeInObserved)  # Calculate the number of dead larvae for the model weights

# Check for missing values or non-integer counts
summary(df_Surv$No.LarvaeInObserved)
summary(df_Surv$Dead_Larvae)

# Ensure both columns are integers
df_Surv <- df_Surv %>%
  filter(!is.na(No.LarvaeInObserved) & !is.na(Dead_Larvae))  # Remove rows with NA values
# Remove rows where Dead_Larvae is negative
df_Surv <- df_Surv %>%
  filter(Dead_Larvae >= 0)

#Fit the most complex model
#weights will be the number of larvae expected in each vial (No.LarvaeInExpected)
mod.1 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Family * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)

#Start with the most complex (‘full’) model, then drop IV terms one at a time. Compare the AIC scores and select the model with the lowest score.
mod.2 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Family * Temp + 
                   (1|Timepoint),
                 family = binomial, 
                 data = df_Surv)
mod.3 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Family * Temp + 
                 (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.4 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ Family * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.5 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.6 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Family + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.7 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment + Family + Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)

#Select the best model (lowest AIC)
AIC(mod.1, mod.2, mod.3, mod.4, mod.5, mod.6, mod.7)
#mod.1 the fullest model is the best

#Validate the model
summary(mod.1)
install.packages("DHARMa")
library(DHARMa)

#The assumptions of linearity and homogeneity of variance for a GLMM are based upon the residuals, so we must extract them and then perform validation
simulationOutput <- simulateResiduals(mod.1, n = 1000)
plot(simulationOutput)
#The Q-Q plot visually shows if the points fall along a straight line, indicating that the data follows the theoretical distribution reasonably well.

#Levene Test for homogenity of variance significant for all variables
plotResiduals(simulationOutput, df_Surv$SymbiontTreatment)
plotResiduals(simulationOutput, df_Surv$Family)
plotResiduals(simulationOutput, df_Surv$Temp)

#Calculate R^2
install.packages("performance")
library(performance)
r2(mod.1)
#Conditional R2: 0.969
#Marginal R2: 0.502
#The conditional R2 is the variation in the DV explained by the fixed and random factors. The marginal R2 is the variation in the DV explained by the fixed factors alone.

#Post hoc analysis
#We can perform pairwise tests of the categorical IV(s) or interactions in our fitted model using the estimated marginal means.
library(emmeans) #package which extracts the estimated marginal means from a model for post hoc analysis of significant factors

#Interactions: SYmbiontTreatment
emm.mod <- emmeans(mod.1, ~ SymbiontTreatment | Family | Temp)
contrast(emm.mod)
pairs(emm.mod)
plot(emm.mod)
library(ggplot2)
emmip(mod.1, ~ SymbiontTreatment | Family | Temp, "response")+
geom_jitter(aes(x = SymbiontTreatment, y = Percent_Survival_atend, colour = SymbiontTreatment), data = df_Surv)

#Create heat map
emm_df <- as.data.frame(emm.mod)
library(ggplot2)
str(emm_df)

heatmap_plot <- ggplot(emm_df, aes(x = SymbiontTreatment, y = interaction(Family, Temp), fill = emmean)) +
  geom_tile(color = "white") +  # Creates the tiles
  scale_fill_gradient(low = "white", high = "red") +  # Change colors as needed
  labs(title = "Estimated Marginal Means Heatmap",
       x = "Symbiont Treatment",
       y = "Family and Temperature",
       fill = "EMM") +
  theme_minimal()

# Print the heatmap
print(heatmap_plot)

#Interactions: Temp
#The order of the independent variables matters so we will start with Temp (everything else is nested within Temp)
emm.mod1 <- emmeans(mod.1, ~ Temp | Family | SymbiontTreatment, type = "link")
# Convert emms object to data frame
emms_log_odds_df <- as.data.frame(emm.mod1)
# Calculate odds from log-odds by exponentiating the log-odds
emms_log_odds_df$odds <- exp(emms_log_odds_df$emmean)

# Select a baseline group's odds (e.g., the first row)
baseline_odds <- emms_log_odds_df$odds[1]

# Calculate fold change in odds for each group relative to baseline
emms_log_odds_df$fold_change_odds <- emms_log_odds_df$odds / baseline_odds

contrast(emm.mod1)
pairs(emm.mod1)
plot(emm.mod1)
library(ggplot2)
emmip(mod.1, ~ Temp | Family | SymbiontTreatment, "response")+
geom_jitter(aes(x = Temp, y = Percent_Survival_atend, colour = Temp), data = df_Surv)

#Create heat map
emm_df1 <- as.data.frame(emm.mod1)
library(ggplot2)
str(emm_df1)

# Create the heatmap
heatmap_plot <- ggplot(emm_df1, aes(x = Temp, y = interaction(Family, SymbiontTreatment), fill = emmean)) +
  geom_tile(color = "white") +  # Creates the tiles
  scale_fill_gradient(low = "white", high = "red") +  # Change colors as needed
  labs(title = "Estimated Marginal Means Heatmap",
       x = "Temperature",
       y = "Family and Symbiont Treatment",
       fill = "EMM") +
  theme_minimal()

# Print the heatmap
print(heatmap_plot)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_survival.png", plot = heatmap_plot, width = 10, height = 8, dpi = 300)

# Calculate log fold change in odds (log odds ratio)
baseline_log_odds <- emms_log_odds_df$emmean[1]
emms_log_odds_df$log_fold_change_odds <- emms_log_odds_df$emmean - baseline_log_odds

# Plot log fold change in odds (log odds ratio)
# Reorder the Family factor
emms_log_odds_df$Family <- factor(emms_log_odds_df$Family, levels = c("F1", "F2", "F3", "F4", "F6", "F7", "F10"))

heatmap_plot_density2 <- ggplot(emms_log_odds_df, aes(x = Family, y = SymbiontTreatment, fill = log_fold_change_odds)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 1, 
                       name = "Fold Change") +  # Set the midpoint to 1 (neutral fold change)
  facet_wrap(~ Temp) +  # Facet each Family in separate panels
  theme_minimal() +
  labs(title = "Heatmap of Log Fold Change in Larvae Survival by Family",
       x = "Tank Temperature",
       y = "Symbiont Treatment")

# Print the heatmap
print(heatmap_plot_density2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_survival_log.png", plot = heatmap_plot_density2, width = 10, height = 8, dpi = 300)

library(piecewiseSEM)

###########
# Calculate R² values (marginal and conditional) for each variable
###########

#full model
r2_values <- rsquared(mod.1)
# Print the results
print(r2_values)

#Symbiont Treatment
mod.1.Symb <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment + 
                    (1|Timepoint) + (1|Replicate),
                  family = binomial, 
                  data = df_Surv)

r2_values.Symb <- rsquared(mod.1.Symb)
# Print the results
print(r2_values.Symb)
#Percent variance explained
r2_difference.Symb <- r2_values$Conditional - r2_values.Symb$Conditional
#Print results
print(r2_difference.Symb)
# Calculate percentage of variance explained
percent_explained.Symb <- (r2_difference.Symb / r2_values$Conditional) * 100

#Family
mod.1.Family <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ Family + 
                    (1|Timepoint) + (1|Replicate),
                  family = binomial, 
                  data = df_Surv)

r2_values.Family <- rsquared(mod.1.Family)

# Print the results
print(r2_values.Family)
#Percent variance explained
r2_difference.Family <- r2_values$Conditional - r2_values.Family$Conditional
#Print results
print(r2_difference.Family)
# Calculate percentage of variance explained
percent_explained.Family <- (r2_difference.Family / r2_values$Conditional) * 100

#Temp
mod.1.Temp <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ Temp + 
                    (1|Timepoint) + (1|Replicate),
                  family = binomial, 
                  data = df_Surv)

r2_values.Temp <- rsquared(mod.1.Temp)

# Print the results
print(r2_values.Temp)
#Percent variance explained
r2_difference.Temp <- r2_values$Conditional - r2_values.Temp$Conditional
#Print results
print(r2_difference.Temp)
# Calculate percentage of variance explained
percent_explained <- (r2_difference.Temp / r2_values$Conditional) * 100

```

Survival with binomial GLMM (Source Reef) --> glmmTMB

```{r}
#Check variables in dataset
str(df_Surv)
class(df_Surv$SymbiontTreatment) #iv
class(df_Surv$Cross_2) #iv
class(df_Surv$Temp) #iv
class(df_Surv$Timepoint) #dv
class(df_Surv$Replicate) #dv

#Change categorical variables to factors
df_Surv$SymbiontTreatment<-factor(df_Surv$SymbiontTreatment)
df_Surv$Cross_2<-factor(df_Surv$Cross_2)
df_Surv$Temp<-factor(df_Surv$Temp)
df_Surv$Timepoint<-factor(df_Surv$Timepoint)
df_Surv$Replicate<-factor(df_Surv$Replicate)

# Check the levels of your categorical variables
levels(df_Surv$SymbiontTreatment)
levels(df_Surv$Cross_2)
levels(df_Surv$Temp)
levels(df_Surv$Timepoint)
levels(df_Surv$Replicate)

#Fit the most complex model
#weights will be the number of larvae expected in each vial (No.LarvaeInExpected)
mod.8 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Cross_2 * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)

#Start with the most complex (‘full’) model, then drop IV terms one at a time. Compare the AIC scores and select the model with the lowest score.
mod.9 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Cross_2 * Temp + 
                   (1|Timepoint),
                 family = binomial, 
                 data = df_Surv)
mod.10 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Cross_2 * Temp + 
                 (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.11 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ Cross_2 * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.12 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.13 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment * Cross_2 + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)
mod.14 <- glmmTMB(cbind(No.LarvaeInObserved, Dead_Larvae) ~ SymbiontTreatment + Cross_2 + Temp + 
                   (1|Timepoint) + (1|Replicate),
                 family = binomial, 
                 data = df_Surv)

#Select the best model (lowest AIC)
AIC(mod.10, mod.12, mod.13, mod.8, mod.9, mod.14)
#mod.8 the fullest model is the best

#Validate the model
summary(mod.8)

#The assumptions of linearity and homogeneity of variance for a GLMM are based upon the residuals, so we must extract them and then perform validation
simulationOutput2 <- simulateResiduals(mod.8, n = 1000)
plot(simulationOutput2)
#The Q-Q plot visually shows if the points fall along a straight line, indicating that the data follows the theoretical distribution reasonably well.

#Levene Test for homogenity of variance significant for all variables
plotResiduals(simulationOutput2, df_Surv$SymbiontTreatment)
plotResiduals(simulationOutput2, df_Surv$Cross_2)
plotResiduals(simulationOutput2, df_Surv$Temp)

#Calculate R^2
install.packages("performance")
library(performance)
r2(mod.8)
#Conditional R2: 0.960
#Marginal R2: 0.447
#The conditional R2 is the variation in the DV explained by the fixed and random factors. The marginal R2 is the variation in the DV explained by the fixed factors alone.

#Post hoc analysis
#We can perform pairwise tests of the categorical IV(s) or interactions in our fitted model using the estimated marginal means.
library(emmeans) #package which extracts the estimated marginal means from a model for post hoc analysis of significant factors

#Interactions: SYmbiontTreatment
emm.mod2 <- emmeans(mod.8, ~ SymbiontTreatment | Cross_2 | Temp)
contrast(emm.mod2)
pairs(emm.mod2)
plot(emm.mod2)
emmip(mod.8, ~ SymbiontTreatment | Cross_2 | Temp, "response")+
geom_jitter(aes(x = SymbiontTreatment, y = Percent_Survival_atend, colour = SymbiontTreatment), data = df_Surv)

#Create heat map
emm_df <- as.data.frame(emm.mod)
str(emm_df)
heatmap_plot <- ggplot(emm_df, aes(x = SymbiontTreatment, y = interaction(Cross_2, Temp), fill = emmean)) +
  geom_tile(color = "white") +  # Creates the tiles
  scale_fill_gradient(low = "white", high = "blue") +  # Change colors as needed
  labs(title = "Estimated Marginal Means Heatmap",
       x = "Symbiont Treatment",
       y = "Family and Temperature",
       fill = "EMM") +
  theme_minimal()
# Print the heatmap
print(heatmap_plot)

#Interactions: Temp
emm.mod3 <- emmeans(mod.8, ~ Temp | Cross_2 | SymbiontTreatment)
contrast(emm.mod3)
pairs(emm.mod3)
plot(emm.mod3)
emmip(mod.8, ~ Temp | Cross_2 | SymbiontTreatment, "response")+
geom_jitter(aes(x = Temp, y = Percent_Survival_atend, colour = Temp), data = df_Surv)

#Create heat map
emm_df3 <- as.data.frame(emm.mod3)
str(emm_df3)
heatmap_plot_sourcereef <- ggplot(emm_df3, aes(x = Temp, y = interaction(Cross_2, SymbiontTreatment), fill = emmean)) +
  geom_tile(color = "white") +  # Creates the tiles
  scale_fill_gradient(low = "white", high = "blue") +  # Change colors as needed
  labs(title = "Estimated Marginal Means Heatmap",
       x = "Temperature",
       y = "Family and Symbiont Treatment",
       fill = "EMM") +
  theme_minimal()+
  facet_wrap(~ Cross_2, ncol = 1) 
# Print the heatmap
print(heatmap_plot_sourcereef)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_sourcereef_survival.png", plot = heatmap_plot_sourcereef, width = 10, height = 8, dpi = 300)

```

Density with GLMM --> MCMCglmm 
Fold change in cell density

```{r}
#fixed effects: symbiont identity, family cross, temperature treatment
#random effects: replicate, timepoint
df_with_extremes <- df_clean

# Create Cellinitial and Cellfinal columns
df_with_extremes <- df_with_extremes %>%
  filter(!is.na(Cell_Density))

df_with_extremes <- df_with_extremes %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%  # Ensure the dataframe is arranged by Timepoint
  mutate(
    Cellinitial = first(Cell_Density),  # First recorded value of cell density for each UniqueID
    Cellfinal = last(Cell_Density)     # Last recorded value of cell density for each UniqueID
  ) %>%
  ungroup()

# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_with_extremes$PercChangeCells <- ((df_with_extremes$Cellfinal - df_with_extremes$Cellinitial) / 
                                    (df_with_extremes$Cellinitial + epsilon)) * 100

# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5),  # Prior for random effect Replicate
    G2 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

# Fit the model
model2 <- MCMCglmm(PercChangeCells ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate + Timepoint, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

#Gelman-Rubin criterion: objective test to determine whether the obtained samples are good
set.seed(1)
m2 <- mclapply(1:4, function(i) {
  MCMCglmm(PercChangeCells ~ SymbiontTreatment * Family *
             Treatment, 
             random = ~ Replicate + Timepoint, 
             data = df_with_extremes, 
             family = "gaussian",  # Use gaussian for continuous proportions
             prior = prior,
             nitt = 50000,    # Number of MCMC iterations
             burnin = 10000,  # Burn-in period
             thin = 20)
})

m2 <- lapply(m2, function(m) m$Sol)
m2 <- do.call(mcmc.list, m2)

par(mfrow=c(4,2), mar=c(2,2,1,2))
gelman.plot(m2, auto.layout=F)
gelman.diag(m2)
#close to 1 so we can continue

#plot of the posterior means along with 95% credible intervals
plot.estimates2 <- function(model2) {
  # Ensure you have the correct summary
  model_summary2 <- summary(model2)
  
  # Extract and filter the relevant parts of the summary
  params2 <- rownames(model_summary2$solutions)
  relevant_params2 <- params2[grep("^(Intercept|SymbiontTreatment|Family|Treatment)", params2)]
  
  # Extract statistics and quantiles
  statistics2 <- model_summary2$solutions[relevant_params2, c("post.mean", "l-95% CI", "u-95% CI")]
  
  # Prepare data for plotting
  stats_df2 <- data.frame(
    parameter = rownames(statistics2),
    mean = statistics2[, "post.mean"],
    lower = statistics2[, "l-95% CI"],
    upper = statistics2[, "u-95% CI"]
  )
  
  # Plot the results
  library(ggplot2)
  ggplot(stats_df2, aes(x = mean, y = parameter)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Posterior Means and 95% Credible Intervals",
         x = "Posterior Mean",
         y = "Parameter") +
    theme_minimal()
}

#### Check Assumptions ####
# Check trace plots to see if the chains are mixing and if there is convergence
#Check density plots to ensure the posterior distributions resemble a normal distribution
plot(model2$Sol, auto.layout = F)
plot(model2$VCV, auto.layout = F)
# Autocorrelation plots
mcmc_samples2 <- as.mcmc(model2$Sol)
autocorr.plot(mcmc_samples2)

#### Extract Comparisons ####
#Since MCMCglmm models are Bayesian and not directly compatible with emmeans, you need to extract the posterior means and credible intervals manually.

# Extract fixed effects
fixed_effects2 <- model2$Sol

# Extract random effects
random_effects2 <- model2$VCV

# Mean and credible intervals for fixed effects
fixed_means2 <- colMeans(fixed_effects2)
fixed_credible_intervals2 <- t(apply(fixed_effects2, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(fixed_means2)
print(fixed_credible_intervals2)

# Mean and credible intervals for random effects
random_means2 <- colMeans(random_effects2)
random_credible_intervals2 <- t(apply(random_effects2, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(random_means2)
print(random_credible_intervals2)

# Calculate variance components for each predictor
var_fixed2 <- apply(fixed_effects2, 2, var)
var_random2 <- apply(random_effects2, 2, var)

# Total variance (fixed + random)
total_variance2 <- var_fixed2 + var_random2

# Marginal R²
marginal_R2.2 <- var_fixed2 / total_variance2

# Conditional R²
conditional_R2.2 <- (var_fixed2 + var_random2) / total_variance2

# Print R² values
# Marginal R2 describes variance explained by fixed factors alone, and conditional R2 describes variance explained by both fixed and random factors
print(marginal_R2.2)
print(conditional_R2.2)

#################
# Get posterior samples for the fixed effects
posterior_samples2 <- model2$Sol

# Define levels for the factors of interest
SymbiontTreatment_levels <- c("C", "D")
Family_levels <- c("F1", "F10", "F2", "F3", "F4", "F6", "F7")
Treatment_levels <- c("31", "35.5", "Ambient")

# Create a new data frame with all combinations of factors
newdata2 <- expand.grid(SymbiontTreatment = SymbiontTreatment_levels,
                       Family = Family_levels,
                       Treatment = Treatment_levels)

# Model matrix for the new data
X_new2 <- model.matrix(~ SymbiontTreatment * Family * Treatment, data = newdata2)
# Subset X_new2 to remove extra interaction terms
X_new2_aligned <- X_new2[, colnames(posterior_samples2), drop = FALSE]

# Calculate posterior predictions for each combination of factor levels
posterior_predictions2 <- X_new2_aligned %*% t(posterior_samples2)

# Summarize the posterior predictions (mean and 95% credible intervals)
marginal_means2 <- apply(posterior_predictions2, 1, function(x) {
  mean_val <- mean(x)
  lower_ci <- quantile(x, 0.025)
  upper_ci <- quantile(x, 0.975)
  return(c(mean = mean_val, lower = lower_ci, upper = upper_ci))
})

# Bind the summary to the original factor levels
result2 <- cbind(newdata2, t(marginal_means2))

# Display the results
print(result2)

# Get the predicted values for PercChange from the model
predictions2 <- predict(model2, type = "response")

# Combine the predictions with the original dataframe
df_with_extremes$PercChange_Cells <- predictions2

# Create a summary dataframe
heatmap_data <- result2 %>%
  group_by(SymbiontTreatment, Family, Treatment) %>%
  summarise(mean_PercChange_Cells = mean(mean, na.rm = TRUE)) %>%
  ungroup()

# Step 1: Ensure the Treatment levels are ordered
heatmap_data <- heatmap_data %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the heatmap with fold change values displayed on each tile
heatmap_plot_cells <- ggplot(heatmap_data, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChange_Cells)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in Symbiont Cell Density",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_cells)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_cells2_PERCENT.png", plot = heatmap_plot_cells, width = 10, height = 8, dpi = 300)

#Square shapes in heat map
heatmap_plot_cells <- ggplot(heatmap_data, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChange_Cells)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
  geom_text(aes(label = round(mean_PercChange_Cells, 2)), color = "black", size = 2) +  # Add fold change values
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in Symbiont Cell Density",
       x = "Family",
       y = "Symbiont Treatment") +
  coord_fixed(ratio = 1)  # Make the tiles more square-shaped by fixing the aspect ratio

# Display the plot
print(heatmap_plot_cells)

# Set the order of the Family factor levels
# DO THIS FOR ALL PLOTS
heatmap_data$Family <- factor(heatmap_data$Family, levels = c("F1", "F2", "F3", "F4", "F6", "F7", "F10"))

# Now create the heatmap again
heatmap_plot_cells3 <- ggplot(heatmap_data, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChange_Cells)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
 # geom_text(aes(label = round(mean_PercChange_Cells, 2)), color = "black", size = 1) +  # Add fold change values
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in Symbiont Cell Density",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_cells3)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_cells2_PERCENT.png", plot = heatmap_plot_cells3, width = 10, height = 8, dpi = 300)

# Change percent to fold change
heatmap_data$fold_change <- 1 + (heatmap_data$mean_PercChange_Cells / 100)

# Create the heatmap with fold change values
heatmap_plot_cells <- ggplot(heatmap_data, aes(x = Family, y = SymbiontTreatment, fill = fold_change)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 1, 
                       name = "Fold Change") +  # Set the midpoint to 1 (neutral fold change)
  facet_wrap(~ Treatment) +
  geom_text(aes(label = round(fold_change, 2)), color = "black", size = 2) +  # Display fold change on tiles
  theme_minimal() +
  labs(title = "Heatmap of Predicted Fold Change in Symbiont Cell Density",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_cells)

### Modeling variables separate for each health metric to get relative contributions ###

mod_cell_treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate + Timepoint, 
                          data = df_with_extremes, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cell_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate + Timepoint, 
                         data = df_with_extremes, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cell_family <- MCMCglmm(PercChangeCells ~ Family, 
                       random = ~ Replicate + Timepoint, 
                       data = df_with_extremes, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_cell_treatment)    # Check treatment-only model results
summary(mod_cell_symbiont)     # Check symbiont treatment-only model results
summary(mod_cell_family)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values
r2_full <- pseudoR2.MCMCglmm(model2, data = df_with_extremes)
# Print the results
print(r2_full)

# Use the custom pseudoR2 function to get the R² values
r2_values <- pseudoR2.MCMCglmm(mod_cell_treatment, data = df_with_extremes)
# Print the results
print(r2_values)

# Use the custom pseudoR2 function to get the R² values
r2_values2 <- pseudoR2.MCMCglmm(mod_cell_symbiont, data = df_with_extremes)
# Print the results
print(r2_values2)

# Use the custom pseudoR2 function to get the R² values
r2_values3 <- pseudoR2.MCMCglmm(mod_cell_family, data = df_with_extremes)
# Print the results
print(r2_values3)
```

Run cell density with only survivors

```{r}
# Assuming df_with_extremes is your original dataframe

# Step 1: Identify the vials that survived at time point 22
survived_vials <- unique(df_with_extremes$UniqueID[df_with_extremes$Timepoint == 22 & 
                                                 df_with_extremes$Percent_Survival_atend > 0])

# Step 2: Subset the original dataframe to include only those vials at both time points
df_survived <- df_with_extremes[df_with_extremes$UniqueID %in% survived_vials & 
                                  df_with_extremes$Timepoint %in% c(0, 22), ]

# Print the resulting dataframe
print(df_survived)

# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_survived$PercChangeCells_survived <- ((df_survived$Cellfinal - df_survived$Cellinitial) / 
                                    (df_survived$Cellinitial + epsilon)) * 100

# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

# Fit the model
model_cells_surv <- MCMCglmm(PercChangeCells_survived ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate, 
                  data = df_survived, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

### Modeling variables separate for each health metric to get relative contributions ###

mod_cell_treatment2 <- MCMCglmm(PercChangeCells_survived ~ Treatment, 
                          random = ~ Replicate, 
                          data = df_survived, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cell_symbiont2 <- MCMCglmm(PercChangeCells_survived ~ SymbiontTreatment, 
                         random = ~ Replicate, 
                         data = df_survived, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cell_family2 <- MCMCglmm(PercChangeCells_survived ~ Family, 
                       random = ~ Replicate, 
                       data = df_survived, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_cell_treatment2)    # Check treatment-only model results
summary(mod_cell_symbiont2)     # Check symbiont treatment-only model results
summary(mod_cell_family2)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values
r2_full2 <- pseudoR2.MCMCglmm(model_cells_surv, data = df_survived)
# Print the results
print(r2_full2)

# Use the custom pseudoR2 function to get the R² values
r2_values <- pseudoR2.MCMCglmm(mod_cell_treatment2, data = df_survived)
# Print the results
print(r2_values)

# Use the custom pseudoR2 function to get the R² values
r2_values2 <- pseudoR2.MCMCglmm(mod_cell_symbiont2, data = df_survived)
# Print the results
print(r2_values2)

# Use the custom pseudoR2 function to get the R² values
r2_values3 <- pseudoR2.MCMCglmm(mod_cell_family2, data = df_survived)
# Print the results
print(r2_values3)

```

Plot of Fv/Fm over time

```{r}
str(df_clean)

# Load libraries
library(ggplot2)
library(dplyr)

# Filter for alive samples, specific timepoints, and summarize data
df_summary <- totaldf_long %>%
  filter(Status == "0", 
         Timepoint %in% c(1, 4, 22), 
         !is.na(FvFm)) %>%
  group_by(Timepoint, Treatment) %>%
  summarise(
    mean_FvFm = mean(FvFm, na.rm = TRUE),
    se_FvFm = sd(FvFm, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  )

# Create the plot with smoothing
ggplot(df_summary, aes(x = Timepoint, y = mean_FvFm, color = Treatment, group = Treatment)) +
  geom_point(size = 3) + # Add points for averages
  geom_errorbar(aes(ymin = mean_FvFm - se_FvFm, ymax = mean_FvFm + se_FvFm), width = 0.2) + # Add error bars
  geom_smooth(method = "loess", span = 0.5, se = FALSE) + # Smooth line (no confidence intervals)
  labs(
    title = "Fv/Fm Values Over Time (Alive Samples, Timepoints 1, 4, and 22)",
    x = "Timepoint",
    y = "Mean Fv/Fm",
    color = "Treatment"
  ) +
  theme_minimal()

# Load libraries
library(ggplot2)
library(dplyr)

# Filter for alive samples and specific timepoints, and count samples over 0.35
df_count <- totaldf_long %>%
  filter(Status == "0", 
         Timepoint %in% c(1, 4, 22), 
         !is.na(FvFm)) %>%
  group_by(Timepoint, Treatment) %>%
  summarise(
    count_over_35 = sum(FvFm > 0.5, na.rm = TRUE),
    .groups = 'drop'
  )

# Create the bar plot
ggplot(df_count, aes(x = factor(Timepoint), y = count_over_35, fill = Treatment)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Number of Samples with Fv/Fm > 0.5 at Each Timepoint",
    x = "Timepoint",
    y = "Count of Samples",
    fill = "Treatment"
  ) +
  theme_minimal()


```

FvFm with GLMM --> MCMCglmm 
Fold change in FvFm

```{r}
#fixed effects: symbiont identity, family cross, temperature treatment
#random effects: replicate, timepoint
str(df_with_extremes)

# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_with_extremes$PercChangeFvFm <- ((df_with_extremes$FvFmfinal - df_with_extremes$FvFminitial) / 
                                    (df_with_extremes$FvFminitial + epsilon)) * 100


# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5),  # Prior for random effect Replicate
    G2 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

df_with_extremes$PercChangeFvFm[df_with_extremes$PercChangeFvFm == 0] <- 0.0001

# Fit the model
mod.f <- MCMCglmm(PercChangeFvFm ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate + Timepoint, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

#Gelman-Rubin criterion: objective test to determine whether the obtained samples are good
set.seed(1)
m4 <- mclapply(1:4, function(i) {
  MCMCglmm(PercChangeFvFm ~ SymbiontTreatment * Family *
             Treatment, 
             random = ~ Replicate + Timepoint, 
             data = df_with_extremes, 
             family = "gaussian",  # Use gaussian for continuous proportions
             prior = prior,
             nitt = 50000,    # Number of MCMC iterations
             burnin = 10000,  # Burn-in period
             thin = 20)
})

m4 <- lapply(m4, function(m) m$Sol)
m4 <- do.call(mcmc.list, m4)

par(mfrow=c(4,2), mar=c(2,2,1,2))
gelman.plot(m4, auto.layout=F)
gelman.diag(m4)
#close to 1 so we can continue

#plot of the posterior means along with 95% credible intervals
plot.estimates4 <- function(mod.f) {
  # Ensure you have the correct summary
  model_summary4 <- summary(mod.f)
  
  # Extract and filter the relevant parts of the summary
  params4 <- rownames(model_summary4$solutions)
  relevant_params4 <- params4[grep("^(Intercept|SymbiontTreatment|Family|Treatment)", params4)]
  
  # Extract statistics and quantiles
  statistics4 <- model_summary4$solutions[relevant_params4, c("post.mean", "l-95% CI", "u-95% CI")]
  
  # Prepare data for plotting
  stats_df4 <- data.frame(
    parameter = rownames(statistics4),
    mean = statistics2[, "post.mean"],
    lower = statistics2[, "l-95% CI"],
    upper = statistics2[, "u-95% CI"]
  )
  
  # Plot the results
  library(ggplot2)
  ggplot(stats_df4, aes(x = mean, y = parameter)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Posterior Means and 95% Credible Intervals",
         x = "Posterior Mean",
         y = "Parameter") +
    theme_minimal()
}

#### Check Assumptions ####
# Check trace plots to see if the chains are mixing and if there is convergence
#Check density plots to ensure the posterior distributions resemble a normal distribution
plot(mod.f$Sol, auto.layout = F)
plot(mod.f$VCV, auto.layout = F)
# Autocorrelation plots
mcmc_samples4 <- as.mcmc(mod.f$Sol)
autocorr.plot(mcmc_samples4)

#### Extract Comparisons ####
# Extract fixed effects
fixed_effects4 <- mod.f$Sol

# Extract random effects
random_effects4 <- mod.f$VCV

# Mean and credible intervals for fixed effects
fixed_means4 <- colMeans(fixed_effects4)
fixed_credible_intervals4 <- t(apply(fixed_effects4, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(fixed_means4)
print(fixed_credible_intervals4)

# Mean and credible intervals for random effects
random_means4 <- colMeans(random_effects4)
random_credible_intervals4 <- t(apply(random_effects4, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(random_means4)
print(random_credible_intervals4)

# Calculate variance components for each predictor
var_fixed4 <- apply(fixed_effects4, 2, var)
var_random4 <- apply(random_effects4, 2, var)

# Total variance (fixed + random)
total_variance4 <- var_fixed4 + var_random4

# Marginal R²
marginal_R2.4 <- var_fixed4 / total_variance4

# Conditional R²
conditional_R2.4 <- (var_fixed4 + var_random4) / total_variance4

# Print R² values
# Marginal R2 describes variance explained by fixed factors alone, and conditional R2 describes variance explained by both fixed and random factors
print(marginal_R2.4)
print(conditional_R2.4)

#################
# Get posterior samples for the fixed effects
posterior_samples4 <- mod.f$Sol

# Define levels for the factors of interest
SymbiontTreatment_levels <- c("C", "D")
Family_levels <- c("F1", "F10", "F2", "F3", "F4", "F6", "F7")
Treatment_levels <- c("31", "35.5", "Ambient")

# Create a new data frame with all combinations of factors
newdata4 <- expand.grid(SymbiontTreatment = SymbiontTreatment_levels,
                       Family = Family_levels,
                       Treatment = Treatment_levels)

# Model matrix for the new data
X_new4 <- model.matrix(~ SymbiontTreatment * Family * Treatment, data = newdata4)
# Subset X_new2 to remove extra interaction terms
X_new4_aligned <- X_new4[, colnames(posterior_samples4), drop = FALSE]

# Calculate posterior predictions for each combination of factor levels
posterior_predictions4 <- X_new4_aligned %*% t(posterior_samples4)

# Summarize the posterior predictions (mean and 95% credible intervals)
marginal_means4 <- apply(posterior_predictions4, 1, function(x) {
  mean_val <- mean(x)
  lower_ci <- quantile(x, 0.025)
  upper_ci <- quantile(x, 0.975)
  return(c(mean = mean_val, lower = lower_ci, upper = upper_ci))
})

# Bind the summary to the original factor levels
result4 <- cbind(newdata4, t(marginal_means4))

# Display the results
print(result4)

# Get the predicted values for PercChange from the model
predictions4 <- predict(mod.f, type = "response")

# Combine the predictions with the original dataframe
df_with_extremes$PercChangeFvFm <- predictions4

# Create a summary dataframe
heatmap_data4 <- result4 %>%
  group_by(SymbiontTreatment, Family, Treatment) %>%
  summarise(mean_PercChangeFvFm = mean(mean, na.rm = TRUE)) %>%
  ungroup()

# Step 1: Ensure the Treatment levels are ordered
heatmap_data4 <- heatmap_data4 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the heatmap with fold change values displayed on each tile
heatmap_plot_FvFm <- ggplot(heatmap_data4, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChangeFvFm)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in FvFm",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_FvFm)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_FvFm_PERC.png", plot = heatmap_plot_FvFm, width = 10, height = 8, dpi = 300)

# Set the order of the Family factor levels
heatmap_data4$Family <- factor(heatmap_data4$Family, levels = c("F1", "F2", "F3", "F4", "F6", "F7", "F10"))

# Now create the heatmap again
heatmap_plot_FvFm5 <- ggplot(heatmap_data4, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChangeFvFm)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
 # geom_text(aes(label = round(mean_PercChange_Cells, 2)), color = "black", size = 1) +  # Add fold change values
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in FvFm",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_FvFm5)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_FvFm_PERCENT.png", plot = heatmap_plot_FvFm5, width = 10, height = 8, dpi = 300)

# Change percent to fold change
heatmap_data4$fold_changeFvFm <- 1 + (heatmap_data4$mean_PercChangeFvFm / 100)

# Create the heatmap with fold change values
heatmap_plot_FvFm6 <- ggplot(heatmap_data4, aes(x = Family, y = SymbiontTreatment, fill = fold_changeFvFm)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 1, 
                       name = "Fold Change") +  # Set the midpoint to 1 (neutral fold change)
  facet_wrap(~ Treatment) +
  theme_minimal() +
  labs(title = "Heatmap of Predicted Fold Change in Fv/Fm",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_FvFm6)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_FvFm_foldchange.png", plot = heatmap_plot_FvFm6, width = 10, height = 8, dpi = 300)

#### Modeling variables separate for each health metric to get relative contributions ###

mod_FvFm_treatment <- MCMCglmm(PercChangeFvFm ~ Treatment, 
                          random = ~ Replicate + Timepoint, 
                          data = df_with_extremes, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_FvFm_symbiont <- MCMCglmm(PercChangeFvFm ~ SymbiontTreatment, 
                         random = ~ Replicate + Timepoint, 
                         data = df_with_extremes, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_FvFm_family <- MCMCglmm(PercChangeFvFm ~ Family, 
                       random = ~ Replicate + Timepoint, 
                       data = df_with_extremes, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_FvFm_treatment)    # Check treatment-only model results
summary(mod_FvFm_symbiont)     # Check symbiont treatment-only model results
summary(mod_FvFm_family)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values from the full model
r2_full <- pseudoR2.MCMCglmm(mod.f, data = df_with_extremes)
# Print the results
print(r2_full)

# Use the custom pseudoR2 function to get the R² values from Treatment
r2_values.FvFmtreatment <- pseudoR2.MCMCglmm(mod_FvFm_treatment, data = df_with_extremes)
# Print the results
print(r2_values.FvFmtreatment)

# Use the custom pseudoR2 function to get the R² values from SymbiontTreatment
r2_values.FvFmsymb <- pseudoR2.MCMCglmm(mod_FvFm_symbiont, data = df_with_extremes)
# Print the results
print(r2_values.FvFmsymb)

# Use the custom pseudoR2 function to get the R² values from Family
r2_values.FvFmfam <- pseudoR2.MCMCglmm(mod_FvFm_family, data = df_with_extremes)
# Print the results
print(r2_values.FvFmfam)
```

FvFm with only survivors

```{r}
# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_survived$PercChangeFvFm_survived <- ((df_survived$FvFmfinal - df_survived$FvFminitial) / 
                                    (df_survived$FvFminitial + epsilon)) * 100

# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

# Fit the model
mod.f.surv <- MCMCglmm(PercChangeFvFm_survived ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate, 
                  data = df_survived, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval
#### Modeling variables separate for each health metric to get relative contributions ###

mod_FvFm_treatment2 <- MCMCglmm(PercChangeFvFm_survived ~ Treatment, 
                          random = ~ Replicate, 
                          data = df_survived, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_FvFm_symbiont2 <- MCMCglmm(PercChangeFvFm_survived ~ SymbiontTreatment, 
                         random = ~ Replicate, 
                         data = df_survived, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_FvFm_family2 <- MCMCglmm(PercChangeFvFm_survived ~ Family, 
                       random = ~ Replicate, 
                       data = df_survived, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_FvFm_treatment2)    # Check treatment-only model results
summary(mod_FvFm_symbiont2)     # Check symbiont treatment-only model results
summary(mod_FvFm_family2)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values from the full model
r2_full2 <- pseudoR2.MCMCglmm(mod.f.surv, data = df_survived)
# Print the results
print(r2_full2)

# Use the custom pseudoR2 function to get the R² values from Treatment
r2_values.FvFmtreatment2 <- pseudoR2.MCMCglmm(mod_FvFm_treatment2, data = df_survived)
# Print the results
print(r2_values.FvFmtreatment2)

# Use the custom pseudoR2 function to get the R² values from SymbiontTreatment
r2_values.FvFmsymb2 <- pseudoR2.MCMCglmm(mod_FvFm_symbiont2, data = df_survived)
# Print the results
print(r2_values.FvFmsymb2)

# Use the custom pseudoR2 function to get the R² values from Family
r2_values.FvFmfam2 <- pseudoR2.MCMCglmm(mod_FvFm_family2, data = df_survived)
# Print the results
print(r2_values.FvFmfam2)
```

Fv/Fm - percentage of larvae with symbiont cells

```{r}
ipam <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_iPAM.csv")
str(ipam)

library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)

ipam <- ipam %>%
  # Assign treatment labels
  mutate(TREATMENT = case_when(
    TEMP == 27.5 ~ "T1",
    TEMP == 31 ~ "T2",
    TEMP == 35.5 ~ "T3",
    TRUE ~ NA_character_
  )) %>%
  # Create UniqueID
  mutate(UniqueID = paste0(TREATMENT, "V", VIAL)) %>%
  # Add missing REP rows per UniqueID × TIMEPOINT
  group_by(UniqueID, TIMEPOINT) %>%
  complete(REP = 1:5, fill = list(FvFm = 0)) %>%
  # Fill metadata values downward and upward within group
  fill(TEMP, SYMBIONT_TREATMENT, .direction = "downup") %>%
  ungroup() %>%
  # Recalculate VIAL from UniqueID if still missing
  mutate(
    VIAL = ifelse(is.na(VIAL), as.integer(str_extract(UniqueID, "(?<=V)\\d+")), VIAL),
    TREATMENT = ifelse(is.na(TREATMENT), str_extract(UniqueID, "^T\\d"), TREATMENT)
  ) %>%
  # Add Dates for TIMEPOINTs
  mutate(
    Days = case_when(
      TIMEPOINT == 1 ~ as.Date("2024-04-11"),
      TIMEPOINT == 4 ~ as.Date("2024-04-14"),
      TIMEPOINT == 22 ~ as.Date("2024-05-02"),
      TRUE ~ as.Date(NA)
    )
  )

# Load metadata summary
perc_larvae_summary <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/perc_larvae_summary.csv")

# Make sure TIMEPOINT is the same type in both dataframes (numeric or integer)
perc_larvae_summary <- perc_larvae_summary %>%
  rename(TIMEPOINT = Days) %>%
  rename(UniqueID = rep.ID)
perc_larvae_summary$TIMEPOINT <- as.numeric(perc_larvae_summary$TIMEPOINT)
ipam$TIMEPOINT <- as.numeric(ipam$TIMEPOINT)

# Merge metadata
ipam <- ipam %>%
  left_join(perc_larvae_summary, by = c("UniqueID", "TIMEPOINT"))

#Clean up
ipam <- ipam %>%
  dplyr::select(-POINT, -SYMBIONT_TREATMENT, -PAR, -AVERAGE_FvFm)

#Calculate the percentage of larvae with cells per vial:
epsilon <- 1e-8  # Avoid division by zero

ipam <- ipam %>%
  group_by(UniqueID) %>%
  arrange(TIMEPOINT) %>%
  mutate(
    CellsInitial = first(na.omit(perc.larv)),
    CellsFinal = last(na.omit(perc.larv)),
    PercChangeCells = ((CellsFinal - CellsInitial))
  ) %>%
  ungroup()

#Calculate the percentage of larvae with cells per vial for summary plot. Assuming that FvFm > 0 indicates larvae with cells:
summary_df <- ipam %>%
  group_by(TIMEPOINT, TREATMENT) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100)

#create figure
ggplot(ipam, aes(x = TIMEPOINT, y = PercChangeCells, color = TREATMENT)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage of Larvae with Cells"
  ) +
  theme_minimal() +
  theme(
    text = element_text(size = 14),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  ) +
  scale_color_manual(values = c("T1" = "blue", "T2" = "orange", "T3" = "red"))

#Now we want to view differences in symbiont taxa
# Subset totaldf_long to UniqueID and SymbiontTreatment and remove duplicates
df_clean_subset <- df_clean %>%
  dplyr::select(UniqueID, SymbiontTreatment, ReefMom) %>%
  distinct(UniqueID, .keep_all = TRUE)

# Merge the SymbiontTreatment column from totaldf_long to ipam by UniqueID
ipam_taxa <- ipam %>%
  left_join(df_clean_subset %>% dplyr::select(UniqueID, SymbiontTreatment), by = "UniqueID")

# Summarize data to include SymbiontTreatment
ipam_taxa <- ipam_taxa %>%
  rename(SymbiontTreatment = zoox)

summary_df2 <- ipam_taxa %>%
  group_by(Timepoint, Treatment, SymbiontTreatment) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100, .groups = "drop")

# Define custom colors for SymbiontTreatment
custom_colors <- c("C" = "green", "D" = "red")  # Example: red-orange for "C" and blue for "D"

#make timepoint numeric
summary_df2$Timepoint <- as.numeric(as.character(summary_df2$Timepoint))

#plot
ggplot(summary_df2, aes(x = Timepoint, y = PercentageWithCells, color = SymbiontTreatment)) +
  geom_point(alpha = 0.6, size = 2) +  # Scatter plot
  geom_line(aes(group = SymbiontTreatment), alpha = 0.6) +  # Line connecting points
  facet_wrap(~ Treatment, scales = "fixed") +  # Facets by TREATMENT with free y-axes
  scale_color_manual(values = custom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0,2,4,6,8,10,12,14,16,18,20,22),  # Add breaks for specific days
    labels = c("0","2","4","6","8","10","12","14","16","18","20","22")  # Label days
  ) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage with Cells (%)",
    color = "Symbiont Treatment"
  ) +
  theme_classic() +  # Clean theme
  theme(
    strip.text = element_text(size = 12),  # Facet label size
    axis.text = element_text(size = 10),  # Axis text size
    legend.title = element_text(size = 12),  # Legend title size
    legend.text = element_text(size = 10)   # Legend text size
  )

#Plot only survivors
#gives basically the same output as the original
# Step 1: Identify UniqueIDs present in all three timepoints (1, 4, 22)
filtered_ipam <- ipam %>%
  filter(Timepoint %in% c(1, 4, 22))

# Step 3: Merge SymbiontTreatment for surviving larvae
filtered_ipam <- filtered_ipam %>%
  left_join(df_clean_subset %>% dplyr::select(UniqueID, SymbiontTreatment, ReefMom), by = "UniqueID")

# Step 4: Create the summary dataframe for larvae that survived until timepoint 22
filtered_ipam <- filtered_ipam %>%
  rename(SymbiontTreatment = zoox)

ipam_taxa_survived <- filtered_ipam %>%
  group_by(Timepoint, Treatment, ReefMom, SymbiontTreatment, UniqueID) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100, .groups = "drop")

# Step 6: Map days to numeric day values
summary_df2_survived <- ipam_taxa_survived %>%
  mutate(DayNumber = as.numeric(date_to_day[as.character(Timepoint)]))

# Step 7: Plot the data for only larvae that survived until timepoint 22 and have data for all three timepoints
summary_df2_survived$Timepoint <- as.numeric(as.character(summary_df2_survived$Timepoint))

ggplot(summary_df2_survived, aes(x = Timepoint, y = PercentageWithCells,
                               color = ReefMom, shape = SymbiontTreatment)) +
  geom_point(alpha = 0.6, size = 2) +  # Scatter plot
  geom_line(aes(group = interaction(ReefMom, SymbiontTreatment)), alpha = 0.6) +  # Line connecting points
  facet_wrap(~ Treatment) +  # Facets by TREATMENT
  scale_color_manual(values = custom_ReefMom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22),
    labels = c("0", "2", "4", "6", "8", "10", "12", "14", "16", "18", "20", "22")
  ) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage with Cells (%)",
    color = "ReefMom",
    shape = "Symbiont Treatment"
  ) +
  theme_classic() +
  theme(
    strip.text = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )


#plot with summary stats for Cross
# Add Cross column based on ReefMom
ipam_taxa_survived <- ipam_taxa_survived %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

# Then summarize including Cross instead of ReefMom
summary_stats <- ipam_taxa_survived %>%
  group_by(Timepoint, SymbiontTreatment, Treatment, Cross) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se = sd(PercentageWithCells, na.rm = TRUE) / sqrt(sum(!is.na(PercentageWithCells))),
    ci_lower = mean_pct - qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    ci_upper = mean_pct + qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    .groups = "drop"
  )


plot1_perc <- ggplot(summary_stats, aes(x = Timepoint, y = mean_pct, color = Cross, shape = SymbiontTreatment)) +
  geom_point(size = 3) +
  geom_line(aes(group = SymbiontTreatment), size = 1) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper, group = SymbiontTreatment), width = 0.3) +
  facet_grid(Cross ~ Treatment) +
  scale_color_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Mean Percentage with Cells (%)",
    color = "Population of Origin"
  ) +
  theme_classic()


```

Combine PercentageWithCells and Cell Density
```{r}
# Load patchwork library
library(patchwork)

# Second plot: Cell Density
summary_df_cells <- summary_df_cells %>%
  mutate(Reef = if_else(Cross %in% c("B.T.2xB.T.4", "B.T.4xB.T.2", "B.T.8xB.T.2"), "CC", "WW"))

# Step 1: average within UniqueID first
uniqueID_summary <- summary_df_cells %>%
  group_by(DayNumber, Reef, CellType, Treatment, TubeID) %>%
  summarise(
    mean_CellDensity_perID = mean(CellDensity, na.rm = TRUE),
    .groups = "drop"
  )

# Step 2: summarize across UniqueIDs to get overall group summary stats
summary_df_cells_grouped <- uniqueID_summary %>%
  group_by(DayNumber, Reef, CellType, Treatment) %>%
  summarise(
    mean_CellDensity = mean(mean_CellDensity_perID, na.rm = TRUE),
    sd_CellDensity = sd(mean_CellDensity_perID, na.rm = TRUE),
    n = n(),  # number of unique UniqueIDs
    se = sd_CellDensity / sqrt(n),
    ci_lower = mean_CellDensity - qt(0.975, df = n - 1) * se,
    ci_upper = mean_CellDensity + qt(0.975, df = n - 1) * se,
    .groups = "drop"
  )


custom_Reef_colors <- c("CC" = "blue", "WW" = "red")  # Adjust as needed

plot2 <- ggplot(summary_df_cells_grouped, aes(x = DayNumber, y = mean_CellDensity, color = Reef, shape = CellType)) +
  geom_point(alpha = 0.8, size = 3) +
  geom_line(aes(group = interaction(Reef, CellType)), alpha = 0.6) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper, group = interaction(Reef, CellType)), width = 0.3, alpha = 0.7) +
  facet_grid(Reef ~ Treatment) +
  scale_color_manual(values = custom_Reef_colors) +
  scale_x_continuous(
    breaks = seq(0, 22, by = 2),
    labels = as.character(seq(0, 22, by = 2))
  ) +
  labs(
    title = "Cell Density by Timepoint for Each Cross",
    x = "Days",
    y = "Mean Cell Density",
    color = "Cross",
    shape = "Cell Type"
  ) +
  theme_classic() +
  theme(
    strip.text = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )

summary_df_cells_grouped %>%
  group_by(DayNumber, Reef, CellType, Treatment) %>%
  tally()




# Combine plots using patchwork
combined_plot <- plot1_perc / plot2  # Stack vertically
# Alternatively, to place them side by side:
# combined_plot <- plot1 + plot2

# Display combined plot
combined_plot

# Save the combined plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_percentcells_density_by_Reef.png", plot = combined_plot, width = 10, height = 8, dpi = 300)


```

Larval Size GLMM with MCMCglmm
Fold Change
```{r}
#fixed effects: symbiont identity, family cross, temperature treatment
#random effects: replicate, timepoint
str(df_with_extremes)

# Group by UniqueID and calculate initial and final cell densities
df_with_extremes <- df_with_extremes %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%  # Ensure the dataframe is arranged by Timepoint
  mutate(
    Sizeinitial = first(Area..mm.2.),  # First recorded value of cell density for each UniqueID
    Sizefinal = last(Area..mm.2.)      # Last recorded value of cell density for each UniqueID
  ) %>%
  ungroup()

# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_with_extremes$PercChangeSize <- ((df_with_extremes$Sizefinal - df_with_extremes$Sizeinitial) / 
                                    (df_with_extremes$Sizeinitial + epsilon)) * 100

# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5),  # Prior for random effect Replicate
    G2 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

# Fit the model
mod.s <- MCMCglmm(PercChangeSize ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate + Timepoint, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

#Gelman-Rubin criterion: objective test to determine whether the obtained samples are good
set.seed(1)
m5 <- mclapply(1:4, function(i) {
  MCMCglmm(PercChangeSize ~ SymbiontTreatment * Family *
             Treatment, 
             random = ~ Replicate + Timepoint, 
             data = df_with_extremes, 
             family = "gaussian",  # Use gaussian for continuous proportions
             prior = prior,
             nitt = 50000,    # Number of MCMC iterations
             burnin = 10000,  # Burn-in period
             thin = 20)
})

m5 <- lapply(m5, function(m) m$Sol)
m5 <- do.call(mcmc.list, m5)

par(mfrow=c(4,2), mar=c(2,2,1,2))
gelman.plot(m5, auto.layout=F)
gelman.diag(m5)
#close to 1 so we can continue

#plot of the posterior means along with 95% credible intervals
plot.estimates5 <- function(mod.s) {
  # Ensure you have the correct summary
  model_summary5 <- summary(mod.s)
  
  # Extract and filter the relevant parts of the summary
  params5 <- rownames(model_summary5$solutions)
  relevant_params5 <- params5[grep("^(Intercept|SymbiontTreatment|Family|Treatment)", params5)]
  
  # Extract statistics and quantiles
  statistics5 <- model_summary5$solutions[relevant_params5, c("post.mean", "l-95% CI", "u-95% CI")]
  
  # Prepare data for plotting
  stats_df5 <- data.frame(
    parameter = rownames(statistics5),
    mean = statistics5[, "post.mean"],
    lower = statistics5[, "l-95% CI"],
    upper = statistics5[, "u-95% CI"]
  )
  
  # Plot the results
  library(ggplot2)
  ggplot(stats_df5, aes(x = mean, y = parameter)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0.2) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    labs(title = "Posterior Means and 95% Credible Intervals",
         x = "Posterior Mean",
         y = "Parameter") +
    theme_minimal()
}

#### Check Assumptions ####
# Check trace plots to see if the chains are mixing and if there is convergence
#Check density plots to ensure the posterior distributions resemble a normal distribution
plot(mod.s$Sol, auto.layout = F)
plot(mod.s$VCV, auto.layout = F)
# Autocorrelation plots
mcmc_samples5 <- as.mcmc(mod.s$Sol)
autocorr.plot(mcmc_samples5)

#### Extract Comparisons ####
# Extract fixed effects
fixed_effects5 <- mod.s$Sol

# Extract random effects
random_effects5 <- mod.s$VCV

# Mean and credible intervals for fixed effects
fixed_means5 <- colMeans(fixed_effects5)
fixed_credible_intervals5 <- t(apply(fixed_effects5, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(fixed_means5)
print(fixed_credible_intervals5)

# Mean and credible intervals for random effects
random_means5 <- colMeans(random_effects5)
random_credible_intervals5 <- t(apply(random_effects5, 2, quantile, probs = c(0.025, 0.975)))

# Print results
print(random_means5)
print(random_credible_intervals5)

# Calculate variance components for each predictor
var_fixed5 <- apply(fixed_effects5, 2, var)
var_random5 <- apply(random_effects5, 2, var)

# Total variance (fixed + random)
total_variance5 <- var_fixed5 + var_random5

# Marginal R²
marginal_R2.5 <- var_fixed5 / total_variance5

# Conditional R²
conditional_R2.5 <- (var_fixed5 + var_random5) / total_variance5

# Print R² values
# Marginal R2 describes variance explained by fixed factors alone, and conditional R2 describes variance explained by both fixed and random factors
print(marginal_R2.5)
print(conditional_R2.5)

#################
# Get posterior samples for the fixed effects
posterior_samples5 <- mod.s$Sol

# Define levels for the factors of interest
SymbiontTreatment_levels <- c("C", "D")
Family_levels <- c("F1", "F10", "F2", "F3", "F4", "F6", "F7")
Treatment_levels <- c("31", "35.5", "Ambient")

# Create a new data frame with all combinations of factors
newdata5 <- expand.grid(SymbiontTreatment = SymbiontTreatment_levels,
                       Family = Family_levels,
                       Treatment = Treatment_levels)

# Model matrix for the new data
X_new5 <- model.matrix(~ SymbiontTreatment * Family * Treatment, data = newdata5)
# Subset X_new2 to remove extra interaction terms
X_new5_aligned <- X_new5[, colnames(posterior_samples5), drop = FALSE]

# Calculate posterior predictions for each combination of factor levels
posterior_predictions5 <- X_new5_aligned %*% t(posterior_samples5)

# Summarize the posterior predictions (mean and 95% credible intervals)
marginal_means5 <- apply(posterior_predictions5, 1, function(x) {
  mean_val <- mean(x)
  lower_ci <- quantile(x, 0.025)
  upper_ci <- quantile(x, 0.975)
  return(c(mean = mean_val, lower = lower_ci, upper = upper_ci))
})

# Bind the summary to the original factor levels
result5 <- cbind(newdata5, t(marginal_means5))

# Display the results
print(result5)

# Get the predicted values for PercChange from the model
predictions5 <- predict(mod.s, type = "response")

# Combine the predictions with the original dataframe
df_with_extremes$PercChangeSize <- predictions5

# Create a summary dataframe
heatmap_data5 <- result5 %>%
  group_by(SymbiontTreatment, Family, Treatment) %>%
  summarise(mean_PercChangeSize = mean(mean, na.rm = TRUE)) %>%
  ungroup()

# Step 1: Ensure the Treatment levels are ordered
heatmap_data5 <- heatmap_data5 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the heatmap with fold change values displayed on each tile
heatmap_plot_Size <- ggplot(heatmap_data5, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChangeSize)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in Size",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_FvFm)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_Size_PERC.png", plot = heatmap_plot_Size, width = 10, height = 8, dpi = 300)

# Set the order of the Family factor levels
heatmap_data5$Family <- factor(heatmap_data5$Family, levels = c("F1", "F2", "F3", "F4", "F6", "F7", "F10"))

# Now create the heatmap again
heatmap_plot_Size2 <- ggplot(heatmap_data5, aes(x = Family, y = SymbiontTreatment, fill = mean_PercChangeSize)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, 
                       name = "Mean Percent Change") +
  facet_wrap(~ Treatment) +
 # geom_text(aes(label = round(mean_PercChange_Cells, 2)), color = "black", size = 1) +  # Add fold change values
  theme_minimal() +
  labs(title = "Heatmap of Predicted Change in FvFm",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_Size2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_FvFm_PERCENT.png", plot = heatmap_plot_Size2, width = 10, height = 8, dpi = 300)

# Change percent to fold change
heatmap_data5$fold_changeSize <- 1 + (heatmap_data5$mean_PercChangeSize / 100)

# Create the heatmap with fold change values
heatmap_plot_Size3 <- ggplot(heatmap_data5, aes(x = Family, y = SymbiontTreatment, fill = fold_changeSize)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 1, 
                       name = "Fold Change") +  # Set the midpoint to 1 (neutral fold change)
  facet_wrap(~ Treatment) +
  theme_minimal() +
  labs(title = "Heatmap of Predicted Fold Change in Larval Size",
       x = "Family",
       y = "Symbiont Treatment")

# Display the plot
print(heatmap_plot_Size3)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/heatmap_plot_Size_foldchange.png", plot = heatmap_plot_Size3, width = 10, height = 8, dpi = 300)

summary(mod.s)

### Modeling variables separate for each health metric to get relative contributions ###

mod_size_treatment <- MCMCglmm(PercChangeSize ~ Treatment, 
                          random = ~ Replicate + Timepoint, 
                          data = df_with_extremes, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont <- MCMCglmm(PercChangeSize ~ SymbiontTreatment, 
                         random = ~ Replicate + Timepoint, 
                         data = df_with_extremes, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family <- MCMCglmm(PercChangeSize ~ Family, 
                       random = ~ Replicate + Timepoint, 
                       data = df_with_extremes, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_size_treatment)    # Check treatment-only model results
summary(mod_size_symbiont)     # Check symbiont treatment-only model results
summary(mod_size_family)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values from the full model
r2_full <- pseudoR2.MCMCglmm(mod.s, data = df_with_extremes)
# Print the results
print(r2_full)

# Use the custom pseudoR2 function to get the R² values from Treatment
r2_values.sizetreatment <- pseudoR2.MCMCglmm(mod_size_treatment, data = df_with_extremes)
# Print the results
print(r2_values.sizetreatment)

# Use the custom pseudoR2 function to get the R² values from SymbiontTreatment
r2_values.sizesymb <- pseudoR2.MCMCglmm(mod_size_symbiont, data = df_with_extremes)
# Print the results
print(r2_values.sizesymb)

# Use the custom pseudoR2 function to get the R² values from Family
r2_values3 <- pseudoR2.MCMCglmm(mod_size_family, data = df_with_extremes)
# Print the results
print(r2_values3)

#############
# Fit model with Global Intercept Contrast Coding where each treatment (e.g., familial cross × symbiont combination x heat treatment) is compared to the global mean of all treatments
#############
#Make sure variables are factors
df_with_extremes$Treatment <- as.factor(df_with_extremes$Treatment)
df_with_extremes$Family <- as.factor(df_with_extremes$Family)
df_with_extremes$SymbiontTreatment <- as.factor(df_with_extremes$SymbiontTreatment)
# Set sum contrasts for the Treatment, SymbiontTreatment, and Family factors
contrasts(df_with_extremes$Treatment) <- contr.sum(levels(df_with_extremes$Treatment))
contrasts(df_with_extremes$SymbiontTreatment) <- contr.sum(levels(df_with_extremes$SymbiontTreatment))
contrasts(df_with_extremes$Family) <- contr.sum(levels(df_with_extremes$Family))

#original model
mod.s2 <- MCMCglmm(PercChangeSize ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate + Timepoint, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

# Check the contrasts to verify sum contrasts are applied
contrasts(df_with_extremes$Treatment)
contrasts(df_with_extremes$SymbiontTreatment)
contrasts(df_with_extremes$Family)

summary(mod.s2)
```

Run size with only survivors

```{r}
# Assuming df_with_extremes is your original dataframe

# Step 1: Identify the vials that survived at time point 22
survived_vials <- unique(df_with_extremes$UniqueID[df_with_extremes$Timepoint == 22 & 
                                                 df_with_extremes$Percent_Survival_atend > 0])

# Step 2: Subset the original dataframe to include only those vials at both time points
df_survived <- df_with_extremes[df_with_extremes$UniqueID %in% survived_vials & 
                                  df_with_extremes$Timepoint %in% c(0, 22), ]

# Print the resulting dataframe
print(df_survived)

# Convert columns to factors
df_survived$SymbiontTreatment <- as.factor(df_survived$SymbiontTreatment)
df_survived$Family <- as.factor(df_survived$Family)
df_survived$Treatment <- as.factor(df_survived$Treatment)

# Calculate percent change, adding epsilon to initial values to avoid division by zero
epsilon <- 1e-8  # Add a small value to avoid division by zero
df_survived$PercChangeSize_survived <- ((df_survived$SizeT22 - df_survived$SizeT1) / 
                                    (df_survived$Sizeinitial + epsilon)) * 100

# Define the priors
prior <- list(
  R = list(V = 1, nu = 0.002),  # Prior for residual variance
  G = list(
    G1 = list(V = 1, nu = 5)   # Prior for random effect Timepoint
  )
)

# Fit the model
model_size_surv <- MCMCglmm(PercChangeSize_survived ~ SymbiontTreatment * Family * Treatment, 
                  random = ~ Replicate, 
                  data = df_survived, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

### Modeling variables separate for each health metric to get relative contributions ###

mod_size_treatment2 <- MCMCglmm(PercChangeSize_survived ~ Treatment, 
                          random = ~ Replicate, 
                          data = df_survived, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont2 <- MCMCglmm(PercChangeSize_survived ~ SymbiontTreatment, 
                         random = ~ Replicate, 
                         data = df_survived, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family2 <- MCMCglmm(PercChangeSize_survived ~ Family, 
                       random = ~ Replicate, 
                       data = df_survived, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

#Compare models
summary(mod_size_treatment2)    # Check treatment-only model results
summary(mod_size_symbiont2)     # Check symbiont treatment-only model results
summary(mod_size_family2)       # Check family-only model results

# Use the custom pseudoR2 function to get the R² values
r2_full2 <- pseudoR2.MCMCglmm(model_size_surv, data = df_survived)
# Print the results
print(r2_full2)

# Use the custom pseudoR2 function to get the R² values for treatment only
r2_values4 <- pseudoR2.MCMCglmm(mod_size_treatment2, data = df_survived)
# Print the results
print(r2_values4)

# Use the custom pseudoR2 function to get the R² values for symbiont only
r2_values5 <- pseudoR2.MCMCglmm(mod_size_symbiont2, data = df_survived)
# Print the results
print(r2_values5)

# Use the custom pseudoR2 function to get the R² values
r2_values6 <- pseudoR2.MCMCglmm(mod_size_family2, data = df_survived)
# Print the results
print(r2_values6)

######## get p-values ##########
# Perform pairwise comparisons using emmeans with Tukey adjustment
# all interactions
df_survived <- droplevels(df_survived)
# Check available combinations in df_survived
available_combinations <- unique(df_survived[c("SymbiontTreatment", "Family", "Treatment")])

emmeans_results <- emmeans(model_size_surv, 
                             ~ Treatment | SymbiontTreatment + Family, 
                             at = list(
                               SymbiontTreatment = available_combinations$SymbiontTreatment,
                               Family = available_combinations$Family,
                               Treatment = available_combinations$Treatment
                             ))


emmeans_results <- emmeans(model_size_surv, 
                           ~ Treatment | SymbiontTreatment + Family, 
                           data = df_survived)

# Extract posterior draws
emm_draws <- emmeans_results %>%
  contrast(method = "pairwise") %>%
  gather_emmeans_draws()

# Calculate Bayesian p-values for each contrast
p_values <- emm_draws %>%
  group_by(contrast) %>%
  summarize(
    p_value = min(mean(.value > 0), mean(.value < 0)) * 2
  )

print(p_values)

# Calculate estimated marginal means for Treatment while averaging over Family
emms <- emmeans(model_size_surv, ~ Treatment * SymbiontTreatment, data = df_survived)
# Extract posterior draws
emm_draws <- emms %>%
  contrast(method = "pairwise") %>%
  gather_emmeans_draws()

# Calculate Bayesian p-values for each contrast
p_values <- emm_draws %>%
  group_by(contrast) %>%
  summarize(
    p_value = min(mean(.value > 0), mean(.value < 0)) * 2
  )

print(p_values)

print(levels(df_survived$SymbiontTreatment))
print(levels(df_survived$Family))
print(levels(df_survived$Treatment))

```
Plot of mean size at T22

```{r}
# Replace NA values with zeros in the Area..mm.2. column
df_clean$Area..mm.2.[is.na(df_clean$Area..mm.2.)] <- 0

# Group by UniqueID and calculate initial and final cell densities
df_clean <- df_clean %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%  # Ensure the dataframe is arranged by Timepoint
  mutate(
    Sizeinitial = first(Area..mm.2.),  # First recorded value of size for each UniqueID
    Sizefinal = last(Area..mm.2.)      # Last recorded value of size for each UniqueID
  ) %>%
  ungroup()

# Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  Cross_2 = unique(df_clean$Cross_2),
  SymbiontTreatment = unique(df_clean$SymbiontTreatment),
  stringsAsFactors = FALSE
)

final_timepoint_df_full <- all_combos %>%
  left_join(final_timepoint_df, by = c("Treatment", "Cross_2", "SymbiontTreatment")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_area), 0, mean_area),
    se_area = ifelse(is.na(se_area), 0, se_area),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e") # Modify colors as needed

# Plot the mean area with error bars and custom colors
area_plot <- ggplot(final_timepoint_df, aes(x = Treatment, y = mean_area)) +
  geom_point(aes(fill = Cross_2, shape = SymbiontTreatment), 
             color = "black", size = 4, stroke = 1.5) +  # black border around points
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area, 
                    color = Cross_2), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 24)) +  # use shapes that support fill (adjust as needed)
  labs(x = "Temperature Treatment", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )



# Display the plot
print(area_plot)

# Create inset for the above plot
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df_inset <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_df_inset <- final_timepoint_df_inset %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_area_plot <- ggplot(final_timepoint_df_inset, aes(x = Treatment, y = mean_area)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_area_plot)

# Create inset for the above plot seperated by Treatment and Symbiont treatment
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df_inset2 <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_df_inset2 <- final_timepoint_df_inset2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_area_plot2 <- ggplot(final_timepoint_df_inset2, aes(x = Treatment, y = mean_area, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_area_plot2)

# Combine the two plots side by side
combined_plot_mean_area <- mean_area_plot + mean_area_plot2 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_mean_area)

# Save the combined plot as a PNG file
ggsave("combined_plot_mean_area_inset.png", plot = combined_plot_mean_area, width = 6, height = 3, dpi = 300)

```

Plot of percent change in size

```{r}

# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_perc_change = mean(PercChangeSize, na.rm = TRUE),
            se_perc_change = sd(PercChangeSize, na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  Cross_2 = unique(totaldf_long$Cross_2),
  SymbiontTreatment = unique(totaldf_long$SymbiontTreatment),
  stringsAsFactors = FALSE
)

perc_change_summary <- all_combos %>%
  left_join(perc_change_summary, by = c("Treatment", "Cross_2", "SymbiontTreatment")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_area = ifelse(is.na(se_perc_change), 0, se_perc_change),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot the percent change in area with error bars and custom colors
perc_change_plot <- ggplot(perc_change_summary, aes(x = Treatment, y = mean_perc_change, 
                                                    fill = Cross_2, shape = SymbiontTreatment)) +
  geom_point(size = 4, color = "black", stroke = 1.5) +  # Point border is black
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change,
                    color = Cross_2),  # Match error bars to fill color
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +   # Fill = group color
  scale_color_manual(values = custom_colors) +  # Color = same as fill (for error bars)
  scale_shape_manual(values = c(21, 24)) +      # Shapes that allow fill and border
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the plot
print(perc_change_plot)

# Create inset just for treatment
# Group by Treatment and calculate mean and standard error for percent change
perc_change_summary2 <- df_clean %>%
  group_by(Treatment) %>%
  summarise(mean_perc_change = mean(PercChangeArea, na.rm = TRUE),
            se_perc_change = sd(PercChangeArea, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary2 <- perc_change_summary2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot2 <- ggplot(perc_change_summary2, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot2)

# Create inset for treatment and symbiont treatment
# Group by Treatment and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary3 <- df_clean %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_perc_change = mean(PercChangeArea, na.rm = TRUE),
            se_perc_change = sd(PercChangeArea, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary3 <- perc_change_summary3 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot3 <- ggplot(perc_change_summary3, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot3)

# Combine the two plots side by side
combined_plot_perc_area <- perc_change_plot2 + perc_change_plot3 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_perc_area)

# Save the combined plot as a PNG file
ggsave("combined_plot_perc_area_inset.png", plot = combined_plot_perc_area, width = 6, height = 3, dpi = 300)
```
Combine area and perc change area plots
```{r}
# Install patchwork if you haven't already
install.packages("patchwork")

# Load patchwork
library(patchwork)

# Combine the two plots side by side
combined_plot <- area_plot + perc_change_plot + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot)

# Save the combined plot as a PNG file
ggsave("combined_plot.png", plot = combined_plot, width = 12, height = 6, dpi = 300)

```

Percent change in size for survivors

```{r}
# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment, ReefMom) %>%
  summarise(mean_perc_change = mean(PercChangeSize, na.rm = TRUE),
            se_perc_change = sd(PercChangeSize, na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31"),
  Cross_2 = unique(totaldf_long$Cross_2),
  SymbiontTreatment = unique(totaldf_long$SymbiontTreatment),
  ReefMom = unique (totaldf_long$ReefMom),
  stringsAsFactors = FALSE
)

perc_change_summary <- all_combos %>%
  left_join(perc_change_summary, by = c("Treatment", "Cross_2", "SymbiontTreatment", "ReefMom")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_area = ifelse(is.na(se_perc_change), 0, se_perc_change),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot percent change in area with colors assigned to Cross_2 and separate panels for Family
survivors_perc_change <- ggplot(perc_change_summary, aes(x = Treatment, y = mean_perc_change, 
                                                        fill = Cross_2, shape = SymbiontTreatment)) +
  geom_line(aes(group = interaction(Cross_2, SymbiontTreatment), color = Cross_2), size = 0.7) +  # connecting lines
  geom_point(size = 4, color = "black", stroke = 1.5) +  # points with black border
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change,
                    color = Cross_2), width = 0.2) +  # error bars matching fill color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +  # fill for points
  scale_color_manual(values = custom_colors) + # color for error bars and lines
  scale_shape_manual(values = c(21, 24)) + # shapes that support fill + border
  facet_wrap(~ ReefMom, nrow = 7) +
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area (Survived to Timepoint 22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.ticks = element_line(color = "black")
  )


print(survivors_perc_change)

# Save the plot to a file
ggsave("percent_change_area_plot.png", 
       plot = survivors_perc_change,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```

Combine the 3 plots for size into one figure

```{r}
# Combine the three plots into one figure
combined_plot2 <- area_plot +  theme(legend.position = "none") +
  perc_change_plot +  theme(legend.position = "none") +
  survivors_perc_change +  theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_size.png", 
       plot = combined_plot2,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  

```

Plot of mean FV/FM at T22
(first measurements taken at T4)

```{r}

# Filter the dataframe to get data for the final timepoint (22)
final_timepoint_fvfm_df <- totaldf_long %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_fvfm_df <- final_timepoint_fvfm_df %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(final_timepoint_fvfm_df$SymbiontTreatment),
  Cross_2 = unique(final_timepoint_fvfm_df$Cross_2)
)

# Join with existing data
final_timepoint_fvfm_df <- all_combos %>%
  left_join(final_timepoint_fvfm_df, by = c("Treatment", "SymbiontTreatment", "Cross_2")) %>%
  mutate(
    Timepoint = 22,
    mean_fvfm = ifelse(is.na(mean_fvfm), 0, mean_fvfm),
    se_fvfm = ifelse(is.na(se_fvfm), 0, se_fvfm)
  )

# Define a custom color palette
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e") # Modify colors as needed

# Plot the mean area with error bars and custom colors
fvfm_plot <- ggplot(final_timepoint_fvfm_df, aes(x = Treatment, y = mean_fvfm, 
                                                 fill = Cross_2, shape = SymbiontTreatment)) +
  # Error bars match fill color
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm,
                    color = Cross_2), 
                width = 0.2) +
  
  # Reference line
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Points with fill and black border
  geom_point(size = 4, stroke = 1.2, color = "black") +

  # Manual color settings
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  # Labels and theme
  labs(x = "Temperature Treatment", 
       y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

fvfm_plot

# Create inset for the above plot
# Step 1: Filter the dataframe to get data for the final timepoint (22)

# Reorder the Treatment factor in the desired order
totaldf_long <- totaldf_long %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

final_timepoint_fvfm_df_inset <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Step 2: Create the plot
mean_fvfm_plot <- ggplot(final_timepoint_fvfm_df_inset, aes(x = Treatment, y = mean_fvfm)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_fvfm_plot)

# Create inset for the above plot seperated by Treatment and Symbiont treatment
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_fvfm_df_inset2 <- totaldf_long %>%
  filter(Treatment != "35.5") %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
totaldf_long <- totaldf_long %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_fvfm_plot2 <- ggplot(final_timepoint_fvfm_df_inset2, aes(x = Treatment, y = mean_fvfm, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_fvfm_plot2)

# Combine the two plots side by side
combined_plot_mean_fvfm <- mean_fvfm_plot + mean_fvfm_plot2 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_mean_fvfm)

# Save the combined plot as a PNG file
ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_mean_fvfm_inset.png", plot = combined_plot_mean_fvfm, width = 6, height = 3, dpi = 300)

```


Plot of percent change in FvFm

```{r}

# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_fvfm_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(PercChange, na.rm = TRUE),
    se_perc_change = sd(PercChange, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder the Treatment factor in the desired order
perc_change_fvfm_summary <- perc_change_fvfm_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(perc_change_fvfm_summary$SymbiontTreatment),
  Cross_2 = unique(perc_change_fvfm_summary$Cross_2)
)

# Join with existing data
perc_change_fvfm_summary <- all_combos %>%
  left_join(perc_change_fvfm_summary, by = c("Treatment", "SymbiontTreatment", "Cross_2")) %>%
  mutate(
    Timepoint = 22,
    mean_pct = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_perc_change = ifelse(is.na(se_perc_change), 0, se_perc_change)
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot the percent change in area with error bars and custom colors
perc_change_fvfm_plot <- ggplot(perc_change_fvfm_summary, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross_2,
  shape = SymbiontTreatment
)) +
  # Error bars colored by Cross_2 (same as fill)
  geom_errorbar(
    aes(
      ymin = mean_perc_change - se_perc_change,
      ymax = mean_perc_change + se_perc_change,
      color = Cross_2
    ),
    width = 0.2
  ) +
  # Points with colored fill and black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +   # fill for points
  scale_color_manual(values = custom_colors) +  # color for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # circle and triangle
  labs(
    x = "Temperature (Treatment)",
    y = "% Change in Fv/Fm (± s.e.)",
    title = "% Change in Larval Fv/Fm from Timepoint 4 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the plot
print(perc_change_fvfm_plot)

# Create inset just for treatment
# Group by Treatment and calculate mean and standard error for percent change
perc_change_summary2 <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment) %>%
  summarise(mean_perc_change = mean(PercChange, na.rm = TRUE),
            se_perc_change = sd(PercChange, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary2 <- perc_change_summary2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot2 <- ggplot(perc_change_summary2, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "% Change in Fv/Fm (± s.e.)",
       title = "% Change in Larval Fv/Fm from Timepoint 4 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot2)

# Create inset for treatment and symbiont treatment
# Group by Treatment and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary3 <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_perc_change = mean(PercChange, na.rm = TRUE),
            se_perc_change = sd(PercChange, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary3 <- perc_change_summary3 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot3 <- ggplot(perc_change_summary3, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "% Change in Fv/Fm (± s.e.)",
       title = "% Change in Larval Fv/Fm from Timepoint 4 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot3)

library(patchwork)

# Combine the two plots side by side
combined_plot_perc_fvfm <- perc_change_plot2 + perc_change_plot3 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_perc_fvfm)

# Save the combined plot as a PNG file
ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_perc_fvfm_inset.png", plot = combined_plot_perc_fvfm, width = 6, height = 3, dpi = 300)
```

Percent change in FVFM for survivors

```{r}
# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_fvfm_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_perc_change = mean(PercChange, na.rm = TRUE),
    se_perc_change = sd(PercChange, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder the Treatment factor in the desired order
perc_change_fvfm_summary <- perc_change_fvfm_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31"),
  SymbiontTreatment = unique(perc_change_fvfm_summary$SymbiontTreatment),
  Cross_2 = unique(perc_change_fvfm_summary$Cross_2),
  ReefMom = unique(perc_change_fvfm_summary$ReefMom)
)

# Join with existing data
perc_change_fvfm_summary <- all_combos %>%
  left_join(perc_change_fvfm_summary, by = c("Treatment", "SymbiontTreatment", "Cross_2", "ReefMom")) %>%
  mutate(
    Timepoint = 22,
    mean_pct = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_perc_change = ifelse(is.na(se_perc_change), 0, se_perc_change)
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot percent change in area with colors assigned to Cross_2 and separate panels for Family
survivors_perc_change <- ggplot(perc_change_fvfm_summary, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross_2,
  shape = SymbiontTreatment,
  group = interaction(Cross_2, SymbiontTreatment)
)) +
  # Colored lines connecting points
  geom_line(aes(color = Cross_2), linewidth = 0.8) +

  # Error bars colored by fill
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross_2
  ), width = 0.2) +

  # Points with black border and colored fill
  geom_point(size = 4, stroke = 1.2, color = "black") +

  # Reference line at 0
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual color and shape control
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  # Labels and faceting
  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in Fv/Fm (± s.e.)",
    title = "% Change in Larval Fv/Fm (Survived to Timepoint 22)"
  ) +
  facet_wrap(~ ReefMom, nrow = 7) +

  # Theme styling
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.ticks = element_line(color = "black")
  )


print(survivors_perc_change)

# Save the plot to a file
ggsave("survivors_perc_change_plot.png", 
       plot = survivors_perc_change,  
       width = 10,          
       height = 7,          
       dpi = 300)           

```

Combine the 3 plots for size into one figure

```{r}
# Combine the three plots into one figure
combined_plot3 <- fvfm_plot + theme(legend.position = "none") + 
  perc_change_fvfm_plot + theme(legend.position = "none") +
  survivors_perc_change + theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot3)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_fvfm.png", 
       plot = combined_plot3,  
       width = 10,          
       height = 7,          
       dpi = 300)           

```
Percentage of Larvae with Cells: line graphs
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)  # for plot_layout()

# Replace NA values with zeros in PercentageWithCells column
summary_df2_survived$PercentageWithCells[is.na(summary_df2_survived$PercentageWithCells)] <- 0

summary_df2_survived <- summary_df2_survived %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

summary_df2_survived %>%
  group_by(Timepoint, SymbiontTreatment, Treatment) %>%
  summarise(n = sum(!is.na(PercentageWithCells))) %>%
  print(n = Inf)

str(summary_df2_survived$PercentageWithCells)

# Filter the dataframe to get data for the final timepoint (22)
summary_stats_day22 <- summary_df2_survived %>%
  filter(Timepoint == 22) %>%
  group_by(Timepoint, SymbiontTreatment, Treatment, Cross) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    n = sum(!is.na(PercentageWithCells)),
    sd_pct = ifelse(n > 1, sd(PercentageWithCells, na.rm = TRUE), NA_real_),
    se = ifelse(n > 1, sd_pct / sqrt(n), NA_real_),
    ci_lower = ifelse(n > 1, mean_pct - qt(0.975, df = n - 1) * se, NA_real_),
    ci_upper = ifelse(n > 1, mean_pct + qt(0.975, df = n - 1) * se, NA_real_)
  ) %>%
  ungroup()

# Set factor levels BEFORE plotting, to retain all x-axis categories
summary_stats_day22 <- summary_stats_day22 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Make a full combination of all groups you'd expect at Timepoint 22
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(summary_stats_day22$SymbiontTreatment),
  Cross = unique(summary_stats_day22$Cross)
)

# Merge with your summary data
summary_stats_day22 <- all_combos %>%
  left_join(summary_stats_day22, by = c("Treatment", "SymbiontTreatment", "Cross")) %>%
  mutate(
    Timepoint = 22,
    mean_pct = ifelse(is.na(mean_pct), 0, mean_pct),
    se = ifelse(is.na(se), 0, se),
    TREATMENT = factor(Treatment, levels = c("Ambient", "31", "35.5"))
  )

summary_stats_day22$SymbiontTreatment <- factor(
  summary_stats_day22$SymbiontTreatment,
  levels = c("C", "D")  # or whatever levels you actually have
)

# Reorder the Treatment factor in the desired order
#final_timepoint_df <- final_timepoint_df %>%
#  mutate(TREATMENT = factor(TREATMENT, levels = c("Ambient", "31", "35.5")))

# Define a custom color palette
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e") # Modify as needed

# Plot mean PercentageWithCells with error bars and custom colors
pct_plot <- ggplot(summary_stats_day22, aes(
  x = Treatment,
  y = mean_pct,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Error bars take the fill color
  geom_errorbar(
    aes(ymin = mean_pct - se, ymax = mean_pct + se, color = Cross),
    width = 0.2
  ) +

  # Points with black outlines and colored fill
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  labs(
    x = "Temperature Treatment",
    y = "Mean % With Cells (± s.e.)",
    title = "Mean Percentage With Cells at Final Timepoint (22)"
  ) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

print(pct_plot)

# Create inset plot by Treatment only
final_timepoint_df_inset <- summary_df2_survived %>%
  filter(TIMEPOINT == 22) %>%
  group_by(TREATMENT) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se_pct = sd(PercentageWithCells, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2", "T3")))

mean_pct_plot <- ggplot(final_timepoint_df_inset, aes(x = TREATMENT, y = mean_pct)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_pct - se_pct, ymax = mean_pct + se_pct), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean % With Cells (± s.e.)",
       title = "Mean Percentage With Cells at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

print(mean_pct_plot)

# Create inset plot separated by Treatment and SymbiontTreatment
final_timepoint_df_inset2 <- summary_df3_survived %>%
  filter(DayNumber == 22) %>%
  group_by(TREATMENT, SymbiontTreatment) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se_pct = sd(PercentageWithCells, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("Ambient", "31", "35.5")))

mean_pct_plot2 <- ggplot(final_timepoint_df_inset2, aes(x = TREATMENT, y = mean_pct, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_pct - se_pct, ymax = mean_pct + se_pct), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean % With Cells (± s.e.)",
       title = "Mean Percentage With Cells at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

print(mean_pct_plot2)

# Combine the two inset plots side by side
library(patchwork)

combined_pct_plot <- mean_pct_plot + mean_pct_plot2 + plot_layout(ncol = 2)
print(combined_pct_plot)

# Save combined plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_mean_percentage_with_cells_inset.png", plot = combined_pct_plot, width = 6, height = 3, dpi = 300)

```
PercentageWithCells from Day 1 to Day 22
```{r}
summary_df2_survived <- summary_df2_survived %>%
  group_by(SymbiontTreatment, Treatment, Cross) %>%
  mutate(PercentageWithCells_adj = PercentageWithCells + 0.01)

# Extract PercentageWithCells at Day 1
cells_day1 <- summary_df2_survived %>%
  filter(Timepoint == 1) %>%
  dplyr::select(Treatment, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay1 = PercentageWithCells_adj)

# Extract PercentageWithCells at Day 22
cells_day22 <- summary_df2_survived %>%
  filter(Timepoint == 22) %>%
  dplyr::select(Treatment, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay22 = PercentageWithCells_adj)

# Join Day 1 and Day 22 data
cells_change_df <- left_join(cells_day1, cells_day22,
                             by = c("Treatment", "ReefMom", "SymbiontTreatment", "Cross"))

# Calculate change
cells_change_df <- cells_change_df <- cells_change_df %>%
  mutate(AcquisitionChangeCells = (CellsDay22) - (CellsDay1))


# Summarize percent change by Treatment, Cross, SymbiontTreatment
perc_change_summary <- cells_change_df %>%
  group_by(Treatment, Cross, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder treatment levels
perc_change_summary <- perc_change_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot
log_change_plot2 <- ggplot(perc_change_summary, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,  # use fill instead of color
  shape = SymbiontTreatment
)) +
  # Colored error bars based on Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross  # error bar matches fill
  ), width = 0.2) +

  # Points: colored fill, black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black outline
  ) +

  # Add reference line
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual color scales
  scale_fill_manual(values = custom_colors) +   # for fill in points
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c(21, 24)) +      # use filled shapes

  # Labels & styling
  labs(
    x = "Temperature (Treatment)",
    y = "Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Show plot
print(log_change_plot2)

# Summarize log change by TREATMENT only
perc_change_inset1 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot_inset1 <- ggplot(perc_change_inset1, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change), width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Change in % With Cells (± s.e.)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

perc_change_inset2 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot_inset2 <- ggplot(perc_change_inset2, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change), width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Log Change in % With Cells (± s.e.)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )


library(patchwork)

# Combine the insets
combined_perc_change_insets <- perc_change_plot_inset1 + perc_change_plot_inset2 + plot_layout(ncol = 2)

# Print
print(combined_perc_change_insets)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_perc_change_insets_pct.png", plot = combined_perc_change_insets,
       width = 6, height = 3, dpi = 300)

```

```{r}
summary_df2_survived <- summary_df2_survived %>%
  group_by(SymbiontTreatment, TREATMENT, Cross, ReefMom) %>%
  mutate(PercentageWithCells_adj = PercentageWithCells + 0.01)

# Extract PercentageWithCells at Day 1
cells_day1 <- summary_df2_survived %>%
  filter(TIMEPOINT == 1) %>%
  dplyr::select(TREATMENT, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay1 = PercentageWithCells_adj)

# Extract PercentageWithCells at Day 22
cells_day22 <- summary_df2_survived %>%
  filter(TIMEPOINT == 22) %>%
  dplyr::select(TREATMENT, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay22 = PercentageWithCells_adj)

# Join Day 1 and Day 22 data
cells_change_df <- left_join(cells_day1, cells_day22,
                             by = c("TREATMENT", "ReefMom", "SymbiontTreatment", "Cross"))

# Calculate log change
cells_change_df <- cells_change_df <- cells_change_df %>%
  mutate(PercChangeCells_Acq = (CellsDay22) - (CellsDay1))

perc_change_summary2 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT, Cross, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells_Acq, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells_Acq, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder treatment levels
perc_change_summary2 <- perc_change_summary2 %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot3 <- ggplot(perc_change_summary2, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Error bars colored by Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross
  ), width = 0.2) +

  # Points with black border and colored fill
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black outline
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual scales for fill and shape
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 22)) +

  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +

  facet_wrap(~ ReefMom, nrow = 7) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the faceted plot
print(perc_change_plot3)

perc_change_plot3 <- ggplot(perc_change_summary2, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Lines connecting points of same Cross and SymbiontTreatment
  geom_line(aes(
    group = interaction(Cross, SymbiontTreatment),
    color = Cross
  ), linewidth = 0.8) +

  # Error bars colored by Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross
  ), width = 0.2) +

  # Points with colored fill and black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Scales and labels
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 24)) +

  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +

  facet_wrap(~ ReefMom, nrow = 7) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

```
Combine all of the plots
```{r}
# Combine the three plots into one figure
combined_plot_pct <- 
  pct_plot + 
    theme(legend.position = "none") +
  log_change_plot2 + 
    theme(legend.position = "none") +
  perc_change_plot3 + 
    theme(legend.position = "none") +
  plot_layout(ncol = 3)


# Display the combined plot
print(combined_plot_pct)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_pct_updated.png", 
       plot = combined_plot_pct,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```
Line graphs of Cell Density
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

# Replace NA values with zeros in Cell_Density
df_subset$Cell_Density[is.na(df_subset$Cell_Density)] <- 0

# Define crosses (adjust as needed)
df_subset <- df_subset %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

# Set factor levels BEFORE plotting, to retain all x-axis categories
df_subset <- df_subset %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Filter for Day 22 and summarize
summary_stats_day22_cd <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Timepoint, SymbiontTreatment, Treatment, Cross) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    n = sum(!is.na(Cell_Density)),
    sd_cd = ifelse(n > 1, sd(Cell_Density, na.rm = TRUE), NA_real_),
    se = ifelse(n > 1, sd_cd / sqrt(n), NA_real_),
    ci_lower = ifelse(n > 1, mean_cd - qt(0.975, df = n - 1) * se, NA_real_),
    ci_upper = ifelse(n > 1, mean_cd + qt(0.975, df = n - 1) * se, NA_real_)
  ) %>%
  ungroup()

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(summary_stats_day22_cd$SymbiontTreatment),
  Cross = unique(summary_stats_day22_cd$Cross)
)

# Join with existing data
summary_stats_day22_cd <- all_combos %>%
  left_join(summary_stats_day22_cd, by = c("Treatment", "SymbiontTreatment", "Cross")) %>%
  mutate(
    Timepoint = 22,
    mean_cd = ifelse(is.na(mean_cd), 0, mean_cd),
    se = ifelse(is.na(se), 0, se)
  )

# Define custom colors
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")

# Plot main Cell Density plot
cd_plot <- ggplot(summary_stats_day22_cd, aes(
  x = Treatment,
  y = mean_cd,
  fill = Cross,                    # fill color by Cross
  shape = SymbiontTreatment        # shape by symbiont
)) +
  geom_errorbar(
    aes(ymin = mean_cd - se, ymax = mean_cd + se, color = Cross), 
    width = 0.2
  ) +
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"                # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +
  labs(
    x = "Temperature Treatment",
    y = "Mean Cell Density (± s.e.)",
    title = "Mean Cell Density at Final Timepoint (22)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


print(cd_plot)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/cell_density_mean_plot.png", plot = cd_plot,
       width = 6, height = 3, dpi = 300)

#Mean cell density by Treatment
final_timepoint_df_inset_cd <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    se_cd = sd(Cell_Density, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

mean_cd_plot <- ggplot(final_timepoint_df_inset_cd, aes(x = Treatment, y = mean_cd)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_cd - se_cd, ymax = mean_cd + se_cd), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean Cell Density (± s.e.)",
       title = "Mean Cell Density at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )
print(mean_cd_plot)

#Inset by Treatment x SymbiontTreatment
final_timepoint_df_inset_cd2 <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    se_cd = sd(Cell_Density, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

mean_cd_plot2 <- ggplot(final_timepoint_df_inset_cd2, aes(x = Treatment, y = mean_cd, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_cd - se_cd, ymax = mean_cd + se_cd), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean Cell Density (± s.e.)",
       title = "Mean Cell Density at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

combined_cd_plot <- mean_cd_plot + mean_cd_plot2 + plot_layout(ncol = 2)
print(combined_cd_plot)

# Save combined inset plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_cell_density_inset.png", plot = combined_cd_plot,
       width = 6, height = 3, dpi = 300)

```
Percent change difference between T0 and T22
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

# Make sure Cross is added and standardized at the beginning
class(df_subset$Cross)
df_subset$Cross <- factor(df_subset$Cross, levels = c("CC", "WW"))
levels(df_subset$Cross)

# Add a small constant to avoid log(0)
df_subset <- df_subset %>%
  group_by(SymbiontTreatment, Treatment, Cross) %>%
  mutate(Cell_Density_adj = Cell_Density + epsilon)

cells_day1 <- df_subset %>%
  filter(Timepoint == 0) %>%
  group_by(Treatment, ReefMom, SymbiontTreatment, Cross) %>%
  summarise(CellsDay1 = mean(Cell_Density_adj, na.rm = TRUE), .groups = "drop")

cells_day22 <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, ReefMom, SymbiontTreatment, Cross) %>%
  summarise(CellsDay22 = mean(Cell_Density_adj, na.rm = TRUE), .groups = "drop")


# Calculate percent change per group
cells_change_df <- left_join(cells_day1, cells_day22,
                             by = c("Treatment", "ReefMom", "SymbiontTreatment", "Cross"))

cells_change_df <- cells_change_df %>%
  mutate(PercChangeCells = 100 * (CellsDay22 - CellsDay1) / CellsDay1)

# Define custom colors
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")

# Summarize percent change by Treatment, Cross, SymbiontTreatment
perc_change_summary <- cells_change_df %>%
  group_by(Treatment, Cross, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )


# Main plot
perc_change_plot_cells <- ggplot(perc_change_summary, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  geom_errorbar(
    aes(ymin = mean_perc_change - se_perc_change,
        ymax = mean_perc_change + se_perc_change,
        color = Cross),
    width = 0.2
  ) +
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # shape for symbionts
  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in Cell Density (± s.e.)",
    title = "Percent Change in Cell Density from Timepoint 1 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


print(perc_change_plot_cells)

#Log change by Treatment only
inset1_df <- cells_change_df %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

inset1_plot <- ggplot(inset1_df, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, color = "black", fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  labs(title = "Mean Log Change by Treatment", y = "Log Change (± s.e.)", x = NULL) +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.title.y = element_text(size = 10),
    plot.title = element_text(size = 10, hjust = 0.5),
    axis.title.x = element_blank()
  )


# Inset 2: Mean log change by Treatment and SymbiontTreatment (point + error bars)
inset2_df <- cells_change_df %>%
  filter(Treatment != "35.5") %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

inset2_plot <- ggplot(inset2_df, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  labs(x = NULL, y = "Log Change (± s.e.)", title = "Log Change by Treatment × Symbiont") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    plot.title = element_text(size = 10, hjust = 0.5),
    axis.title.x = element_blank()
  )


combined_cd_plot2 <- inset1_plot + inset2_plot + plot_layout(ncol = 2)
print(combined_cd_plot2)

# Save combined inset plot
ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_cell_density_percchange_inset.png", plot = combined_cd_plot2,
       width = 6, height = 3, dpi = 300)


```



```{r}
# Summarize perc change including ReefMom
perc_change_summary_by_reef <- cells_change_df %>%
  filter(Treatment != "35.5") %>%
  group_by(Treatment, Cross, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot faceted by ReefMom
perc_change_plot_faceted <- ggplot(perc_change_summary_by_reef, 
                                   aes(x = Treatment, y = mean_perc_change,
                                       fill = Cross, shape = SymbiontTreatment)) +
  # Connect points with same color as fill
  geom_line(aes(group = interaction(Cross, SymbiontTreatment), color = Cross), 
            size = 0.8) +
  
  # Error bars with Cross color
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change,
                    color = Cross), 
                width = 0.2) +
  
  # Points with black border and colored fill
  geom_point(size = 4, stroke = 1.2, color = "black") +
  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # triangle and circle

  labs(x = "Temperature (Treatment)", 
       y = "Percent Change in Cell Density (± s.e.)",
       title = "Percent Change in Cell Density from Timepoint 1 to 22") +
  
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  ) +
  facet_wrap(~ ReefMom, nrow = 7)

print(perc_change_plot_faceted)


```

Combine all of the plots
```{r}
# Combine the three plots into one figure
combined_plot_cd <- cd_plot + 
    theme(legend.position = "none") +
  perc_change_plot_cells + 
    theme(legend.position = "none") + perc_change_plot_faceted + 
    theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot_cd)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_cd.png", 
       plot = combined_plot_cd,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```

##Percentage of Larvae that Acquired Cells with Source Reef
```{r}
#Percentage with Cells ############################################

# Ensure factors are ordered
library(dplyr)

ipam <- ipam %>%
  mutate(
    TEMP = case_when(
      near(TEMP, 27.5) ~ "Ambient",
      near(TEMP, 31) ~ "31",
      near(TEMP, 35.5) ~ "35.5",
      TRUE ~ as.character(TEMP)
    ),
    Reef = recode(Reef, "Bruboodjoo" = "CC", "Tantabiddi" = "WW"),
    SymbiontTreatment = factor(zoox, levels = c("C", "D")),
    Treatment = factor(TEMP, levels = c("Ambient", "31", "35.5")),
    Cross = factor(Reef, levels = c("CC", "WW"))
  )

#df_subset$logChangeCells <- log(df_subset$PercChangeCells + 1)

#check how many observations per group
table(ipam$SymbiontTreatment, ipam$Cross, ipam$Treatment)

#include replicates
ipam <- ipam %>%
  rename(Timepoint = TIMEPOINT)

ipam <- ipam %>%
  mutate(Timepoint = as.character(Timepoint)) %>%
  left_join(
    df_with_extremes %>%
      mutate(Timepoint = as.character(Timepoint)) %>%
      dplyr::select(UniqueID, Timepoint, Replicate) %>%
      distinct(),
    by = c("UniqueID", "Timepoint")
  )

summary(ipam[, c("PercChangeCells", "SymbiontTreatment", "Cross", "Treatment")])

#set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)

#model
model_perc <- MCMCglmm(
  PercChangeCells ~ SymbiontTreatment * Cross * Treatment,
  random = ~ Replicate,
  data = ipam,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_perc)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_perc$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

newdat_perc <- expand.grid(
  SymbiontTreatment = levels(ipam$SymbiontTreatment),
  Cross = levels(ipam$Cross),
  Treatment = levels(ipam$Treatment)  
)

newdat_perc$SymbiontTreatment <- factor(newdat_perc$SymbiontTreatment, levels = levels(ipam$SymbiontTreatment))
newdat_perc$Cross <- factor(newdat_perc$Cross, levels = levels(ipam$Cross))
newdat_perc$Treatment <- factor(newdat_perc$Treatment, levels = levels(ipam$Treatment))

lapply(newdat_perc[, c("SymbiontTreatment", "Cross", "Treatment")], function(x) length(unique(x)))


X_full_subset <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat_perc)
X_subset <- X_full_subset[, colnames(model_perc$Sol), drop = FALSE]

pred_matrix_subset <- X_subset %*% t(model_perc$Sol)
newdat_perc$pred_mean <- rowMeans(pred_matrix_subset)
newdat_perc$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat_perc$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat_perc$significant <- !(newdat_perc$lower < 0 & newdat_perc$upper > 0)
newdat_perc$label_combined <- paste0(round(newdat_perc$pred_mean, 2),
                                       ifelse(newdat_perc$significant, "*", ""))
# Calculate pMCMC values: two-tailed test for each posterior distribution
newdat_perc$pMCMC <- apply(pred_matrix_subset, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

#Global mean
# Vector of posterior means across all groups for each MCMC iteration
global_mean_post_subset <- colMeans(pred_matrix_subset)
# Difference: each group's posterior - global mean at each MCMC iteration
diff_matrix_global_subset <- sweep(pred_matrix_subset, 2, global_mean_post_subset, FUN = "-")
# pMCMC: two-tailed probability that the difference ≠ 0
pMCMC_vals <- apply(diff_matrix_global_subset, 1, function(x) {
  mean(x < 0) * 2 * (mean(x < 0) < 0.5) + mean(x > 0) * 2 * (mean(x > 0) < 0.5)
})
diff_summary_global_subset <- as.data.frame(t(apply(diff_matrix_global_subset, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
})))

colnames(diff_summary_global_subset) <- c("mean_global", "lower_global", "upper_global")

diff_summary_global_subset$pMCMC <- pMCMC_vals
diff_summary_global_subset$signif_label_global <- case_when(
  pMCMC_vals < 0.005 ~ "**",
  pMCMC_vals < 0.05  ~ "*",
  TRUE               ~ ""
)

diff_summary_global_subset$label_combined_global <- paste0(
  round(diff_summary_global_subset$mean_global, 2),
  diff_summary_global_subset$signif_label_global
)

diff_summary_global_subset <- as.data.frame(diff_summary_global_subset)
diff_summary_global_subset$significant_vs_global <- with(diff_summary_global_subset, lower_global > 0 | upper_global < 0)

newdat_perc <- cbind(newdat_perc, diff_summary_global_subset)

ggplot(newdat_perc, aes(x = Treatment, y = Cross, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted cell change %") +
  theme_minimal() +
  labs(title = "Predicted Change in Cell Density (No 35.5)",
       x = "Treatment", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = ipam,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_perc_Treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = ipam, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_perc_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = ipam, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_perc_family <- MCMCglmm(PercChangeCells ~ Cross, 
                       random = ~ Replicate , 
                       data = ipam, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, ipam, full_formula)
r2_Treatment <- calc_marginal_R2(mod_perc_Treatment, ipam, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_perc_symbiont, ipam, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_perc_family, ipam, PercChangeCells ~ Cross)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_Treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}


library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, ipam, full_formula)
r2_Treatment <- calc_marginal_conditional_R2(mod_perc_Treatment, ipam, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_perc_symbiont, ipam, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_perc_family, ipam, PercChangeCells ~ Cross)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_Treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_Treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")

# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_Treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_Treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_Treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_Treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_Treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_Treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)
```

##ONLY SURVIVORS: Percentage of Larvae that Acquired Cells with Source Cross
```{r}
#Percentage with Cells ############################################

# Step 1: Get UniqueIDs present at Timepoint 22
ids_at_22 <- ipam %>%
  filter(Timepoint == 22) %>%
  pull(UniqueID) %>%
  unique()

# Step 2: Subset ipam to include only those UniqueIDs
ipam_subset <- ipam %>%
  filter(UniqueID %in% ids_at_22)

# Ensure factors are ordered
ipam_subset$Treatment <- factor(ipam_subset$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
ipam_subset$Cross <- factor(ipam_subset$Cross, 
                                     levels = c("CC", "WW"))
ipam_subset$SymbiontTreatment <- factor(ipam_subset$SymbiontTreatment, 
                                     levels = c("C", "D"))

#Remove 35.5 because larvae didn't survive
ipam_subset <- ipam_subset %>% 
  filter(Treatment != "35.5") %>%
  droplevels()

#check how many observations per group
table(ipam_subset$SymbiontTreatment, ipam_subset$Cross, ipam_subset$Treatment)

#set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)

#model
model_perc <- MCMCglmm(
  PercChangeCells ~ SymbiontTreatment * Cross * Treatment,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_perc)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_perc$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

newdat_perc2 <- expand.grid(
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment),
  Cross = levels(ipam_subset$Cross),
  Treatment = levels(ipam_subset$Treatment)  
)

newdat_perc2$SymbiontTreatment <- factor(newdat_perc2$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))
newdat_perc2$Cross <- factor(newdat_perc2$Cross, levels = levels(ipam_subset$Cross))
newdat_perc2$Treatment <- factor(newdat_perc2$Treatment, levels = levels(ipam_subset$Treatment))

lapply(newdat_perc2[, c("SymbiontTreatment", "Cross", "Treatment")], function(x) length(unique(x)))


X_full_subset <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat_perc2)
X_subset <- X_full_subset[, colnames(model_perc$Sol), drop = FALSE]

pred_matrix_subset <- X_subset %*% t(model_perc$Sol)
newdat_perc2$pred_mean <- rowMeans(pred_matrix_subset)
newdat_perc2$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat_perc2$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat_perc2$significant <- !(newdat_perc2$lower < 0 & newdat_perc2$upper > 0)
newdat_perc2$label_combined <- paste0(round(newdat_perc2$pred_mean, 2),
                                       ifelse(newdat_perc2$significant, "*", ""))

ggplot(newdat_perc2, aes(x = Treatment, y = Cross, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted cell change %") +
  theme_minimal() +
  labs(title = "Predicted Change in Cell Density (No 35.5)",
       x = "Treatment", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_perc_Treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = ipam_subset, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_perc_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = ipam_subset, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_perc_family <- MCMCglmm(PercChangeCells ~ Cross, 
                       random = ~ Replicate , 
                       data = ipam_subset, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, ipam_subset, full_formula)
r2_Treatment <- calc_marginal_R2(mod_perc_Treatment, ipam_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_perc_symbiont, ipam_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_perc_family, ipam_subset, PercChangeCells ~ Cross)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_Treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}


library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, ipam_subset, full_formula)
r2_Treatment <- calc_marginal_conditional_R2(mod_perc_Treatment, ipam_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_perc_symbiont, ipam_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_perc_family, ipam_subset, PercChangeCells ~ Cross)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_Treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_Treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")

# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_Treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_Treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_Treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_Treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_Treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_Treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

##########
# Pairwise comparisons for survivors (Percent Change)
##########

# Create new data frame of combinations
newdat <- expand.grid(
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment),
  Cross = levels(ipam_subset$Cross),
  Treatment = levels(ipam_subset$Treatment)
)

# Ensure same factor levels as in model
newdat$SymbiontTreatment <- factor(newdat$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))
newdat$Cross <- factor(newdat$Cross, levels = levels(ipam_subset$Cross))
newdat$Treatment <- factor(newdat$Treatment, levels = levels(ipam_subset$Treatment))

# For clarity in output
newdat$group <- with(newdat, paste(SymbiontTreatment, Cross, Treatment, sep = "_"))

# Design matrix must match the fixed effects structure in the full model
X <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat)

# Match columns exactly
X <- X[, colnames(model_perc$Sol), drop = FALSE]

# Get posterior predictions
pred_matrix <- X %*% t(model_perc$Sol)

# All pairwise group combinations
group_combos <- combn(1:nrow(newdat), 2, simplify = FALSE)

# Compute posterior difference, 95% CI, and pMCMC
pairwise_results <- lapply(group_combos, function(idx) {
  i <- idx[1]
  j <- idx[2]
  diff <- pred_matrix[i, ] - pred_matrix[j, ]
  ci <- quantile(diff, probs = c(0.025, 0.975))
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  
  data.frame(
    group1 = newdat$group[i],
    group2 = newdat$group[j],
    mean_diff = mean(diff),
    lower = ci[1],
    upper = ci[2],
    pMCMC = pMCMC,
    significant = ci[1] > 0 | ci[2] < 0
  )
})

pairwise_df <- do.call(rbind, pairwise_results)

ggplot(pairwise_df, aes(group1, group2, fill = mean_diff)) +
  geom_tile() +
  geom_text(aes(label = ifelse(significant, "*", "")), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Pairwise Differences in log(Cell Density Change)",
       x = "Group 1", y = "Group 2")

# Add back-transformed columns and format them nicely
pairwise_summary <- pairwise_df %>%
  mutate(
    mean_diff_bt = exp(mean_diff) - 1,
    lower_bt = exp(lower) - 1,
    upper_bt = exp(upper) - 1,
    mean_diff_bt_fmt = formatC(mean_diff_bt, format = "e", digits = 2),
    lower_bt_fmt = formatC(lower_bt, format = "e", digits = 2),
    upper_bt_fmt = formatC(upper_bt, format = "e", digits = 2),
    significant_label = ifelse(significant, "*", "")
  ) %>%
  select(
    group1, group2,
    mean_diff, lower, upper,
    mean_diff_bt_fmt, lower_bt_fmt, upper_bt_fmt,
    pMCMC, significant_label
  ) %>%
  rename(
    `Group 1` = group1,
    `Group 2` = group2,
    `Mean Diff (log)` = mean_diff,
    `Lower 95% CI (log)` = lower,
    `Upper 95% CI (log)` = upper,
    `Mean Diff (back-transformed)` = mean_diff_bt_fmt,
    `Lower 95% CI (back-transformed)` = lower_bt_fmt,
    `Upper 95% CI (back-transformed)` = upper_bt_fmt,
    `pMCMC` = pMCMC,
    `Significant` = significant_label
  )

write.csv(pairwise_summary, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/pairwise_summary_table_perc_with_cells.csv", row.names = FALSE)

###############################################################
# Now with just Treatment and Cross

# Fit the model
model_tc <- MCMCglmm(
  PercChangeCells ~ Treatment * Cross,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# New data grid for predictions
newdat_tc <- expand.grid(
  Treatment = levels(ipam_subset$Treatment),
  Cross = levels(ipam_subset$Cross)
)

newdat_tc$Treatment <- factor(newdat_tc$Treatment, levels = levels(ipam_subset$Treatment))
newdat_tc$Cross <- factor(newdat_tc$Cross, levels = levels(ipam_subset$Cross))

# Model matrix for fixed effects (match model columns)
X_tc <- model.matrix(~ Treatment * Cross, data = newdat_tc)

# Subset posterior samples for fixed effects
common_cols <- intersect(colnames(model_tc$Sol), colnames(X_tc))
X_tc_aligned <- X_tc[, common_cols, drop = FALSE]
Sol_tc <- model_tc$Sol[, common_cols, drop = FALSE]

# Calculate predicted values per MCMC iteration
pred_mat_tc <- X_tc_aligned %*% t(Sol_tc)  # rows = groups, cols = MCMC samples

# Calculate pairwise differences for all combinations
pairwise_diff_tc <- combn(nrow(newdat_tc), 2, function(i) {
  diff_samples <- pred_mat_tc[i[1], ] - pred_mat_tc[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_tc$Treatment[i[1]]), as.character(newdat_tc$Cross[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_tc$Treatment[i[2]]), as.character(newdat_tc$Cross[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

# Add significance flag
pairwise_diff_tc <- pairwise_diff_tc %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_tc)

###############################################################
# Now with just Treatment and SymbiontTreatment
model_ts <- MCMCglmm(
  PercChangeCells ~ Treatment * SymbiontTreatment,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

newdat_ts <- expand.grid(
  Treatment = levels(ipam_subset$Treatment),
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(ipam_subset$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
common_cols <- intersect(colnames(model_ts$Sol), colnames(X_ts))
X_ts_aligned <- X_ts[, common_cols, drop = FALSE]
Sol_ts <- model_ts$Sol[, common_cols, drop = FALSE]

pred_mat_ts <- X_ts_aligned %*% t(Sol_ts) 

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()


pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)


```
