---
title: "Ningaloo Larval Infection Experiment 2024 - PhD Chapter 4"
output: html_notebook
date: 07-22-2025
author: Sydney Bell
---

#Load packages and data
```{r}
library('ggplot2'); packageVersion('ggplot2') #version 3.5.0
library(dplyr)
library(tidyr)
#install.packages("MCMCglmm")
library(MCMCglmm)
#install.packages("lsmeans")
library(lsmeans)
#install.packages("sjPlot")
library(sjPlot)
library(stats)
library(nlme)
library(glmmTMB)
library(DHARMa)
library(coda)
library(parallel)
library(emmeans)
#install.packages("tidybayes")
library(tidybayes)

setwd("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment")

metadata = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE)
str(metadata)

# Remove rows with missing treatment
metadata <- metadata %>% filter(!is.na(Treatment))

# Convert Timepoint columns to numeric
df <- metadata %>%
  mutate(across(starts_with("Timepoint"), as.numeric))

# Rename FvFm column (column 35)
colnames(df)[35] <- "FvFm"

# Remove blank rows based on key columns
df <- df %>%
  filter(!(is.na(tube.ID) & is.na(Timepoint) & is.na(Temp)))

# Set categorical variable levels
df <- df %>%
  mutate(
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")),
    Family = na_if(Family, ""),
    SymbiontTreatment = na_if(SymbiontTreatment, "")
  ) %>%
  mutate(across(c(Family, SymbiontTreatment), factor)) %>%
  droplevels()

# Temp coding based on Treatment
df <- df %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ as.character(Temp)
  ))

# Create UniqueID
df <- df %>%
  mutate(UniqueID = paste0(Temp, "V", tube.ID))

# Calculate Initial/Final and Percent Change Metrics
epsilon <- 1e-8 # Small number to avoid division by zero

# FvFm
# Calculate FvFminitial and FvFmfinal without dropping rows with NA
df <- df %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    FvFminitial = first(na.omit(FvFm)),  # First non-NA FvFm
    FvFmfinal = last(na.omit(FvFm))      # Last non-NA FvFm
  ) %>%
  ungroup()

# Calculate percent change, skipping division by zero
epsilon <- 1e-4 # Small number to avoid division by zero
df <- df %>%
  mutate(
    FvFminitial_eps = ifelse(FvFminitial == 0 | is.na(FvFminitial), epsilon, FvFminitial),
    PercChange = ((FvFmfinal - FvFminitial_eps) / FvFminitial_eps) * 100
  )

#raw change Fv/Fm
df <- df %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    FvFminitial = first(na.omit(FvFm)),
    FvFmfinal = last(na.omit(FvFm)),
    RawChangeFvFm = FvFmfinal - FvFminitial
  ) %>%
  ungroup()

# Size (Area)
df <- df %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    Sizeinitial = first(na.omit(Area..mm.2.)),
    Sizefinal = last(na.omit(Area..mm.2.)),
    PercChangeSize = ((Sizefinal - Sizeinitial) / (Sizeinitial + epsilon)) * 100
  ) %>%
  ungroup()

#0 = alive
df_with_extremes <- df %>%
  # Recode Percent_Survival_atend == 0 as Dead
  mutate(`Alive..Dead..Sampled` = ifelse(Percent_Survival_atend == 0, "Dead", `Alive..Dead..Sampled`)) %>%
  # Create Status column: 0 = Alive, 1 = Dead
  mutate(Status = ifelse(`Alive..Dead..Sampled` == "Alive", 0, 1))

#Long-format Cell Density (From No.Cells1–3)
# Convert and reshape
totaldf_long <- df_with_extremes %>%
  mutate(across(starts_with("No.Cells"), as.numeric)) %>%
  pivot_longer(cols = starts_with("No.Cells"),
               names_to = "Cell_Measurement",
               values_to = "Cell_Density") %>%
  filter(!is.na(Cell_Density))

# Clean up factors and drop missing key values
totaldf_long <- totaldf_long %>%
  mutate(across(c(SymbiontTreatment, Family, Treatment, Timepoint), factor)) %>%
  filter(!is.na(SymbiontTreatment), !is.na(Family),
         !is.na(Treatment), !is.na(Timepoint))

# Add Cross column based on ReefMom
totaldf_long <- totaldf_long %>%
  mutate(Cross_2 = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

#Survival Calculation
df_Surv <- totaldf_long %>%
  mutate(
    Percent_Survival_atend = Percent_Survival_atend / 100,
    Dead_Larvae = No.LarvaeInExpected - No.LarvaeInObserved
  ) %>%
  filter(!is.na(No.LarvaeInObserved), !is.na(Dead_Larvae), Dead_Larvae >= 0)

df_Surv <- df_Surv %>%
  mutate(across(c(SymbiontTreatment, Family, Treatment, Timepoint, Replicate), factor))

# Ensure both columns are integers
df_Surv <- df_Surv %>%
  filter(!is.na(No.LarvaeInObserved) & !is.na(Dead_Larvae))  # Remove rows with NA values
# Remove rows where Dead_Larvae is negative
df_Surv <- df_Surv %>%
  filter(Dead_Larvae >= 0)

df_Surv <- df_Surv %>%
  mutate(
    Percent_Survival = (No.LarvaeInObserved / No.LarvaeInStart) * 100
  ) %>%
  filter(!is.na(Percent_Survival))

#Survival summary
df_surv_summary <- df_Surv %>%
  filter(Timepoint == 22) %>%   # keep only timepoint 22
  group_by(Treatment) %>%  
  summarise(
    Mean_Survival = mean(Percent_Survival, na.rm = TRUE),
    SD_Survival   = sd(Percent_Survival, na.rm = TRUE),
    N             = n(),
    SE_Survival   = SD_Survival / sqrt(N)
  )

# Temp coding based on Treatment
df_Surv <- df_Surv %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ as.character(Temp)
  ))

library(dplyr)

#Calculate percent survival and summarize per treatment × timepoint
#table of replicates
table_s1_tubes <- df_with_extremes %>%
  filter(!is.na(No.LarvaeInObserved)) %>%
  group_by(Timepoint, Treatment, SymbiontTreatment, Cross_2) %>%
  summarise(
    Replicates_Started  = n(),                     # total tubes
    Replicates_Survived = sum(No.LarvaeInObserved > 0), # tubes with ≥1 larvae alive
    Percent_Tube_Survival = (Replicates_Survived / Replicates_Started) * 100,
    Mean_Larval_Survival  = mean(No.LarvaeInObserved / No.LarvaeInStart * 100), # avg % larvae per tube
    .groups = "drop"
  ) %>%
  arrange(Timepoint, Treatment, SymbiontTreatment, Cross_2)

table_s1_tubes <- df_with_extremes %>%
  filter(!is.na(No.LarvaeInObserved)) %>%
  group_by(Timepoint, Treatment, SymbiontTreatment, Cross_2) %>%
  summarise(
    Replicates_Started      = n(),                              # total tubes
    Replicates_Survived     = sum(No.LarvaeInObserved > 0),     # tubes with ≥1 larva alive
    Percent_Tube_Survival   = (Replicates_Survived / Replicates_Started) * 100,
    Mean_Larval_Survival    = mean(No.LarvaeInObserved / No.LarvaeInStart * 100), # avg % larvae per tube
    Total_Larvae_Started    = sum(No.LarvaeInStart),           # sum of all larvae at start
    Total_Larvae_Survived   = sum(No.LarvaeInObserved),        # sum of larvae alive
    .groups = "drop"
  ) %>%
  arrange(Timepoint, Treatment, SymbiontTreatment, Cross_2)

table_s1_tubes


#write to CSV
write.csv(table_s1_tubes, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/Table_S1_Larval_Survival_Tubes.csv", row.names = FALSE)

# Cell Density
totaldf_long <- totaldf_long %>%
  filter(!is.na(Cell_Density)) %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%
  mutate(
    Cellinitial = first(Cell_Density),
    Cellfinal = last(Cell_Density),
    PercChangeCells = ((Cellfinal - Cellinitial) / (Cellinitial + epsilon)) * 100
  ) %>%
  ungroup()

#####################################
#load in cells for exploratory box plots
cells = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/celldensity.csv", header = TRUE)
str(cells)

# Calculate total number of cells per TubeID and Date.Start
total_cells <- cells %>%
  filter(!is.na(Cells.End.Average)) %>%  # Exclude rows with NA in Cells.End.Average
  group_by(TubeID) %>%
  summarise(Cells_End_Average = sum(Cells.End.Average))  # Calculate sum of Cells.End.Average for each TubeID

# Extract tank information from TubeID
cells <- cells %>%
  mutate(tank = ifelse(substr(TubeID, 1, 2) == "T1", "Ambient", "31C"))

# Calculate total number of cells per TubeID, tank, and CellType
total_cells <- cells %>%
  filter(!is.na(Cells.End.Average)) %>%  
  group_by(tank, TubeID, CellType) %>%
  summarise(Cells_End_Average = sum(Cells.End.Average))  

# Make Treatment a factor
cells$Treatment <- factor(cells$Treatment, levels = c("Ambient", "31", "35.5"))
treatment_colors <- c("Ambient" = "green", "31" = "orange", "35.5" = "red")

# Reshape the data so that all 3 cell counts are combined
cells_long <- cells %>%
  pivot_longer(cols = starts_with("No.Cells"), 
               names_to = "Measurement", 
               values_to = "CellDensity",
               values_drop_na = TRUE)
```

#Exploratory Survival plots
```{r}
#Family
# Plot using ggplot2 with a smooth curve, facet by Treatment, and custom layout

df_Surv$Timepoint_num <- as.numeric(as.character(df_Surv$Timepoint))


ggplot(df_Surv, aes(x = Timepoint_num, y = Percent_Survival,
                    color = as.factor(Family))) +
  geom_point() +
  geom_line() +
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +
  labs(x = "Timepoint (days)", y = "Percent Survival (%)", color = "Family") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.placement = "outside",
    strip.background = element_blank()
  )

surv_summary <- df_Surv %>%
  group_by(Family, Treatment, Timepoint_num) %>%
  summarise(
    mean_survival = mean(Percent_Survival, na.rm = TRUE),
    se_survival = sd(Percent_Survival, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

ggplot(surv_summary, aes(x = Timepoint_num, y = mean_survival, color = Family, group = Family)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = mean_survival - se_survival, ymax = mean_survival + se_survival), width = 0.5) +
  facet_wrap(~Treatment, nrow = 1) +
  labs(x = "Timepoint (days)", y = "Mean Percent Survival (%)") +
  theme_minimal() +
  theme(legend.position = "bottom")

surv_summary_22 <- df_Surv %>%
  filter(Timepoint == "22") %>%
  group_by(Treatment) %>%
  summarise(
    mean_survival = mean(Percent_Survival, na.rm = TRUE),
    se_survival = sd(Percent_Survival, na.rm = TRUE) / sqrt(n())
  )

surv_summary_22

#plotGen
plotGen <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(SymbiontTreatment))) +
  geom_smooth(method = "loess", se = FALSE) +  # Use loess method for smoothing
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +  # Facet by Treatment with one row
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
plotGen

#ReefMom

plot_raw <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(Culture))) +
  geom_point() +
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
print(plot_raw)


plotCul <- ggplot(df, aes(x = Timepoint, y = survival_percentage, color = as.factor(Culture))) +
  geom_smooth(method = "loess", se = FALSE) +  # Use loess method for smoothing
  facet_wrap(~Treatment, nrow = 1, scales = "free_x") +  # Facet by Treatment with one row
  labs(x = "Timepoint", y = "Survival %", color = "Tube ID") +
  theme_minimal() +
  theme(
    legend.position = "bottom",  # Move legend to the bottom
    strip.placement = "outside",  # Place facet labels outside the plot area
    strip.background = element_blank()  # Remove background of facet labels
  )
plotCul


```
## Cell Density: Exploratory Bar Graph
```{r}

# Create a bar graph
ggplot(total_cells, aes(x = TubeID, y = Cells_End_Average)) +
  geom_bar(stat = "identity") +
  labs(x = "Tube ID", y = "Total Number of Cells") +
  theme_minimal()

# Create a bar graph with color by CellType
ggplot(total_cells, aes(x = TubeID, y = Cells_End_Average, fill = CellType)) +
  geom_bar(stat = "identity") +
  labs(x = "Tube ID", y = "Total Number of Cells") +
  theme_minimal()

avg_cells <- cells_long %>%
  group_by(Treatment) %>%
  summarise(mean_density = mean(CellDensity, na.rm = TRUE),
            sd_density = sd(CellDensity, na.rm = TRUE),
            n = n(),
            se_density = sd_density / sqrt(n))
```
## Cell Density: Exploratory Line Graph
```{r}

# Create a new data frame with start and end points for each TubeID
combined_data <- data.frame(
  Date = c(cells$T.Start, cells$T.End),
  Cells = c(cells$Cells.Start, cells$Cells.End.Average),
  TubeID = rep(cells$TubeID, 2),
  Type = rep(c("Start", "End"), each = nrow(cells))
)

# Plot the line graph
cellden = ggplot(combined_data, aes(x = Date, y = Cells, group = TubeID, color = Type)) +
  geom_line() +
  geom_point() +
  geom_text(data = subset(combined_data, Type == "End"), 
            aes(label = TubeID), vjust = -0.5, hjust = 1.5) +
  labs(x = "Date", y = "Cell Density", color = "Type") +
  theme_minimal()

cellden
#ggsave("celldensity.jpg", plot = cellden)
```
## Cell Density: Boxplot by Cross
```{r}
# Create the box plot
celldenboxplot = ggplot(cells_long, aes(x = Cross, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  labs(title = "Box Plot of Cell Density by Cross and Treatment",
       x = "Cross",
       y = "Cell Density") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = treatment_colors)

celldenboxplot

#ggsave("celldensityboxplot.jpg", plot = boxplot, width = 25, height = 15)
```
## Cell Density: Boxplot by Reef, Cell Type, and Treatment
```{r}
# Create the boxplot
celldenboxplot <- ggplot(cells_long, aes(x = Reef, y = CellDensity, fill = CellType)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +  # separate boxes for each CellType
  facet_wrap(~ Treatment) +
  labs(title = "Cell Density by Reef, Cell Type, and Treatment",
       x = "Reef",
       y = "Cell Density") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.background = element_blank(),
    strip.text = element_text(face = "bold")
  )

celldenboxplot

# Load necessary library
library(stats)

# Perform Kruskal-Wallis test
cells_long$Group <- paste(cells_long$Treatment,
                          cells_long$CellType,
                          sep = ".")


kruskal.test(CellDensity ~ Group, data = cells_long)

#Kruskal-Wallis rank sum test
#data:  CellDensity by Treatment
#Kruskal-Wallis chi-squared = 99.817, df = 5, p-value < 2.2e-16

#Based on this result, you can conclude that there is a statistically significant difference in cell density among the different treatment, cell type, and Reef combinantions (Ambient, 31, and 35.5).

# Example of pairwise Wilcoxon rank-sum test (pairwise comparisons)
pairwise.wilcox.test(cells_long$CellDensity, cells_long$Group, p.adjust.method = "BH")

ggplot(cells_long, aes(x = Group, y = CellDensity)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```
## Cell Density: Kruskal-Wallis test with Treatment
```{r}
# provided a very small p-value (< 2.2e-16), indicating strong evidence against the null hypothesis of normality
shapiro.test(cells_long$CellDensity)
#data is nonparametric

# Load necessary library
library(stats)

# Perform Kruskal-Wallis test
kw_result <- kruskal.test(CellDensity ~ Treatment, data = cells_long)

# Check test result
print(kw_result)

#Kruskal-Wallis rank sum test
#data:  CellDensity by Treatment
#Kruskal-Wallis chi-squared = 90.004, df = 2, p-value < 2.2e-16

#Based on this result, you can conclude that there is a statistically significant difference in cell density among the different treatments (Ambient, 31, and 35.5).

# Example of pairwise Wilcoxon rank-sum test (pairwise comparisons)
pairwise.wilcox.test(cells_long$CellDensity, cells_long$Treatment, p.adjust.method = "bonferroni")

#Ambient vs. 31: The p-value is approximately 1, indicating no significant difference in cell density between Ambient and 31 treatments.
#Ambient vs. 35.5: The adjusted p-value is < 2e-16, indicating a highly significant difference in cell density between Ambient and 35.5 treatments.
#31 vs. 35.5: The adjusted p-value is also < 2e-16, indicating a highly significant difference in cell density between 31 and 35.5 treatments.

```
## Cell Density: Two-Way Repeated Measures ANOVA
2 predictors: Treatment and CellType
```{r}
# 1. Check assumptions 
########### TREATMENT #############
# Convert Treatment to a factor
cells_long$Treatment <- factor(cells_long$Treatment)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$Treatment)

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, Treatment=='Ambient')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='31')$CellDensity)
shapiro.test(subset(cells_long, Treatment=='35.5')$CellDensity)
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############
# Convert CellType to a factor
cells_long$CellType <- factor(cells_long$CellType)
str(cells_long)

boxplot(cells_long$CellDensity ~ cells_long$CellType)

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(subset(cells_long, CellType=='C')$CellDensity)
shapiro.test(subset(cells_long, CellType=='D')$CellDensity)
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(cells_long$CellDensity ~ cells_long$CellType)
# Bartlett's K-squared = 24.126, df = 1, p-value = 9.024e-07
# NOT HOMOGENOUS

# 2. Assumptions are not met: Try scale transformations

########### TREATMENT #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$Treatment) # square root transformed because we have counts

#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, Treatment=='Ambient')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='31')$CellDensity))
shapiro.test(sqrt(subset(cells_long, Treatment=='35.5')$CellDensity))
# …. (do a test for each level of the categorical variable)
# NOT NORMAL p<0.005

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$Treatment)
#Bartlett's K-squared = Inf, df = 2, p-value < 2.2e-16
# NOT HOMOGENOUS

########## CELLTYPE #############

boxplot(sqrt(cells_long$CellDensity) ~ cells_long$CellType) # square root transformed because we have counts

sample_sizes <- table(cells_long$CellType)
#Shapiro-Wilk test (H0: data is normal):
shapiro.test(sqrt(subset(cells_long, CellType=='C')$CellDensity))
shapiro.test(sqrt(subset(cells_long, CellType=='D')$CellDensity))
# …. (do a test for each level of the categorical variable)

# Bartlett’s test (H0: variances are homogenous):
bartlett.test(sqrt(cells_long$CellDensity) ~ cells_long$CellType)
# Bartlett's K-squared = 4.5066, df = 1, p-value = 0.03377
# HOMOGENOUS

# 3. Do non-parametric test by rank-transforming the data

library(nlme)
rDV<-rank(cells_long$CellDensity)

lme.rank<-lme(fixed = rDV ~ Treatment * CellType, random=~1|Cross, data = cells_long)
celldenanova <- anova (lme.rank)
#                       numDF       denDF      F-value       p-value
# (Intercept)             1         358        518.9960     <0.0001
# Treatment               2         358         64.6619     <0.0001
# CellType                1         358         1.8426      0.1755
# Treatment:CellType      2         358         5.1615      0.0062

plot(CellDensity ~ Treatment*CellType, data = cells_long)

# Treatment: F(2, 358) = 64.6619, p = <0.0001
# CellType: NOT sig
# Interaction: F(2, 358) = 5.1615, p = 0.0062

```
##Cell density box plot
Analyze significant interaction Treatment*CellType
```{r}
interaction.plot(cells_long$CellType, cells_long$Treatment, cells_long$CellDensity, 
                 xlab="CellType", ylab="CellDensity", trace.label="Treatment")

# Example using pairwise comparisons
pairwise.t.test(cells_long$CellDensity, interaction(cells_long$Treatment, cells_long$CellType), p.adjust.method = "bonferroni")
#	Pairwise comparisons using t tests with pooled SD 

#data:  cells_long$CellDensity and interaction(cells_long$Treatment, cells_long$CellType) 

#          Ambient.C 31.C    35.5.C  Ambient.D 31.D   
#31.C      0.05188   -       -       -         -      
#35.5.C    0.00012   1.00000 -       -         -      
#Ambient.D 0.01986   1.00000 1.00000 -         -      
#31.D      1.00000   1.00000 0.03891 1.00000   -      
#35.5.D    0.00012   1.00000 1.00000 1.00000   0.03891

#P value adjustment method: bonferroni 
#install.packages("emmeans")
library(emmeans)
# Fit the linear mixed-effects model
lme.rank <- lme(fixed = rDV ~ Treatment * CellType, random = ~1|Cross, data = cells_long)

# Obtain the estimated marginal means
emm <- emmeans(lme.rank, ~ Treatment * CellType)

# Perform Tukey's post hoc test
tukey_result <- pairs(emm, adjust = "tukey")

# Print the results
print(tukey_result)
tukey_df <- as.data.frame(tukey_result)
print(tukey_df)
write.csv(tukey_df, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/tukey_posthoc_results.csv", row.names = FALSE)

# Create boxplot with facets by CellType and colors by Treatment
cells_long$Treatment <- factor(cells_long$Treatment, levels = c("Ambient", "31", "35.5"))


ggplot(cells_long, aes(x = Treatment, y = CellDensity, fill = Treatment)) +
  geom_boxplot() +
  facet_grid(. ~ CellType) +
  labs(title = "Boxplot of Cell Density by Treatment and Cell Type",
       x = "Treatment",
       y = "Cell Density",
       fill = "Treatment") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = c("Ambient" = "green","31" = "orange", "35.5" = "red"))

```
##Cell Density Boxplot for Publication
```{r}
library(ggplot2)
library(ggpubr)  # for stat_compare_means
library(dplyr)

# 1. Recode Treatment factor levels with degree symbols
cells_long$Treatment <- factor(cells_long$Treatment,
    levels = c("Ambient", "31", "35.5"),
    labels = c("27.5°C", "31°C", "35.5°C"))

# 2. Recode CellType
cells_long$CellType <- recode(cells_long$CellType,
    "C" = "C",
    "D" = "D"
)

# Recreate Group safely
cells_long$Group <- paste0(cells_long$Treatment, "_", cells_long$CellType)
cells_long$Group <- factor(cells_long$Group)

# Check that it worked:
table(cells_long$Group)

# 3. Define comparisons for p-values
my_comparisons <- list(
  c("27.5°C_C", "27.5°C_D"),
  c("31°C_C", "31°C_D"),
  c("35.5°C_C", "35.5°C_D"),    # compare symbionts at 35.5°C
  c("27.5°C_C", "31°C_C"),
  c("31°C_C", "35.5°C_C"),      # compare temperatures for Cladocopium
  c("27.5°C_D", "31°C_D"),
  c("31°C_D", "35.5°C_D"),      # compare temperatures for Durusdinium
  c("27.5°C_C", "35.5°C_C"),
  c("27.5°C_D", "35.5°C_D")
  )

# Calculate p-values
pvals_df <- lapply(my_comparisons, function(pair) {
  group1_vals <- filter(cells_long, Group == pair[1])$CellDensity
  group2_vals <- filter(cells_long, Group == pair[2])$CellDensity
  
  p_val <- tryCatch(
    wilcox.test(group1_vals, group2_vals)$p.value,
    error = function(e) NA_real_
  )
  
  data.frame(
    group1 = pair[1],
    group2 = pair[2],
    p_value = p_val,
    comparison = paste(pair, collapse = " vs "),
    stringsAsFactors = FALSE
  )
}) %>% bind_rows()

# Format p-values nicely
pvals_df <- pvals_df %>%
  mutate(p_label = ifelse(is.na(p_value), "NA",
                          ifelse(p_value < 0.001, "p < 0.001", paste0("p = ", signif(p_value, 3)))))
pvals_df

# Create a data frame of positions for each comparison
# You need to find the numeric x-axis positions of groups in your plot (1 to 6 for 6 groups)

group_levels <- levels(cells_long$Group)

# Increase the horizontal line height a bit above the vertical lines
pvals_df <- pvals_df %>%
  mutate(
    y_hline = y + 0.00 * max(cells_long$CellDensity),  # horizontal line a bit above y
    y_label = y_hline + 0.025 * max(cells_long$CellDensity)  # label above horizontal line
  )

x_labels <- c(
  expression("27.5°C " * italic("Cladocopium")),
  expression("27.5°C " * italic("Durusdinium")),
  expression("31°C " * italic("Cladocopium")),
  expression("31°C " * italic("Durusdinium")),
  expression("35.5°C " * italic("Cladocopium")),
  expression("35.5°C " * italic("Durusdinium"))
)

legend_labels <- c(
  "27.5°C_C" = expression("27.5°C " * italic("Cladocopium")),
  "27.5°C_D" = expression("27.5°C " * italic("Durusdinium")),
  "31°C_C"   = expression("31°C " * italic("Cladocopium")),
  "31°C_D"   = expression("31°C " * italic("Durusdinium")),
  "35.5°C_C" = expression("35.5°C " * italic("Cladocopium")),
  "35.5°C_D" = expression("35.5°C " * italic("Durusdinium"))
)

celldensity_boxplot <- ggplot(cells_long, aes(x = Group, y = CellDensity, fill = Group)) +
  geom_boxplot() +
  scale_x_discrete(labels = x_labels) +
  scale_fill_manual(
    values = c(
      "27.5°C_C" = "#abd9e9",
      "31°C_C"   = "#fee08b",
      "35.5°C_C" = "#d53e4f",
      "27.5°C_D" = "#3288bd",
      "31°C_D"   = "gold",
      "35.5°C_D" = "#a50026"
    ),
    labels = unname(as.list(legend_labels))
  ) +
  # Your segments & text here, e.g.:
  geom_segment(data = pvals_df,
               aes(x = x1, xend = x1, y = y, yend = y_line),
               inherit.aes = FALSE) +
  geom_segment(data = pvals_df,
               aes(x = x2, xend = x2, y = y, yend = y_line),
               inherit.aes = FALSE) +
  geom_segment(data = pvals_df,
               aes(x = x1, xend = x2, y = y_hline, yend = y_hline),
               inherit.aes = FALSE) +
  geom_text(data = pvals_df,
            aes(x = x, y = y_label, label = p_label),
            inherit.aes = FALSE, size = 4) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  theme(legend.text = element_text(size = 12))


ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/celldensity_boxplot.png", 
       plot = celldensity_boxplot,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```


##Survival Analysis
Cox model: with Treatment and ReefMom
```{r}
#Install package survival
library(survival)

str(metadata)

# Determine the class of the Factors (not the covariates):
class(metadata$Treatment)
class(metadata$SymbiontTreatment)
class(metadata$ReefMom)
#If any of the factors is not a “factor”, redefine it as a factor:
metadata$Treatment <- factor(metadata$Treatment)
metadata$SymbiontTreatment <- factor(metadata$SymbiontTreatment)
metadata$ReefMom <- factor(metadata$ReefMom)
attach (metadata)

# Create the Status column
# Zero = Alive
metadata$Status <- ifelse(metadata$`Alive..Dead..Sampled` == "Alive", 0, 1)
# Check for missing values in the columns used in the model
sum(is.na(metadata$Timepoint))
sum(is.na(metadata$Status))
sum(is.na(metadata$Treatment))
sum(is.na(metadata$SymbiontTreatment))
sum(is.na(metadata$ReefMom))

# Keep the entire metadata dataset, but filter out rows with NA in specific columns
metadata_clean <- metadata %>%
  filter(!is.na(Timepoint) & !is.na(Status) & !is.na(Treatment) & !is.na(SymbiontTreatment) & !is.na(ReefMom))

# Check the dimensions to ensure you retain all necessary columns
dim(metadata_clean)  # Check number of rows and columns

# Verify the changes
head(metadata_clean)

metadata_clean$Timepoint <- as.numeric(as.character(metadata_clean$Timepoint))

X<-cbind(metadata_clean$Treatment, metadata_clean$SymbiontTreatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox <- coxph(
  Surv(Timepoint, Status) ~ Treatment + SymbiontTreatment + Cross_2,
  data = metadata_clean,
  method = "breslow"
)
cox<- coxph (Surv(Timepoint, Status)~ X, method='breslow', data = metadata_clean)
summary(cox)

cox_td <- coxph(
  Surv(Timepoint, Status) ~ SymbiontTreatment + Cross_2 + 
    tt(Treat31) + tt(Treat35.5),
  data = transform(metadata_clean,
                   Treat31 = as.numeric(Treatment == "31"),
                   Treat35.5 = as.numeric(Treatment == "35.5")),
  method = "breslow",
  tt = function(x, t, ...) x * log(t)
)
summary(cox_td)
# Create time grid
time_grid <- seq(1, 22, length.out = 100)

b <- coef(cox_td)

# Compute HR for each treatment
df <- data.frame(
  Time = rep(time_grid, 2),
  HR = c(exp(b["tt(Treat31)"] * log(time_grid + 1)),
         exp(b["tt(Treat35.5)"] * log(time_grid + 1))),
  Treatment = rep(c("31 °C", "35.5 °C"), each = length(time_grid)))

ggplot(df, aes(x = Time, y = HR, color = Treatment)) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "red"))

library(ggplot2)
library(dplyr)
library(tidyr)

# Time grid (experiment ran 22 days)
time_grid <- seq(1, 22, length.out = 100)

# Coefficients and covariance matrix
b <- coef(cox_td)
V <- vcov(cox_td)  # covariance matrix

# Function to compute HR(t) and CI
compute_hr_ci <- function(coef_name, time_grid, b, V) {
  logt <- log(time_grid + 1)          # log(time+1) for tt() term
  hr <- exp(b[coef_name] * logt)      # HR(t)
  
  # Standard error for log(HR(t)) = log(HR) * sqrt(var)
  se_log_hr <- sqrt(logt^2 * V[coef_name, coef_name])
  
  # 95% CI
  hr_lower <- exp(log(hr) - 1.96 * se_log_hr)
  hr_upper <- exp(log(hr) + 1.96 * se_log_hr)
  
  data.frame(
    Time = time_grid,
    HR = hr,
    HR_lower = hr_lower,
    HR_upper = hr_upper,
    Treatment = coef_name
  )
}

# Compute for both treatments
df_31  <- compute_hr_ci("tt(Treat31)", time_grid, b, V)
df_355 <- compute_hr_ci("tt(Treat35.5)", time_grid, b, V)

# Combine into one data frame
df_plot <- bind_rows(df_31, df_355)
df_plot$Treatment <- recode(df_plot$Treatment, 
                            "tt(Treat31)" = "31 °C",
                            "tt(Treat35.5)" = "35.5 °C")

ggplot(df_plot, aes(x = Time, y = HR, color = Treatment, fill = Treatment)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = HR_lower, ymax = HR_upper), alpha = 0.2, color = NA) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_manual(values = c("blue", "red")) +
  scale_fill_manual(values = c("blue", "red"))

cox_3way <- coxph(
  Surv(Timepoint, Status) ~ SymbiontTreatment * Treatment * Cross_2,
  data = metadata_clean,
  method = "breslow"
)
summary(cox_3way)

metadata_clean2 <- transform(metadata_clean,
                            Treat31 = as.numeric(Treatment == "31"),
                            Treat35.5 = as.numeric(Treatment == "35.5"))
library(survival)

# Time-dependent function: linear in log(time)
tt_fun <- function(x, t, ...) x * log(t)

cox_td_3way <- coxph(
  Surv(Timepoint, Status) ~ SymbiontTreatment * Cross_2 +
    tt(Treat31) + tt(Treat35.5) +
    SymbiontTreatment:tt(Treat31) + SymbiontTreatment:tt(Treat35.5) +
    Cross_2:tt(Treat31) + Cross_2:tt(Treat35.5) +
    SymbiontTreatment:Cross_2:tt(Treat31) + SymbiontTreatment:Cross_2:tt(Treat35.5),
  data = metadata_clean2,
  tt = tt_fun,
  method = "breslow"
)
summary(cox_td_3way)

time_grid <- 1:22  # experiment duration

# Extract coefficients
coefs <- coef(cox_td_3way)

# Example: HR for 31°C, Symbiont C, Cross reference (baseline)
hr_31_C_ref <- exp(coefs["tt(Treat31)"] * log(time_grid))
# HR for 35.5°C, Symbiont C, Cross reference (baseline)
hr_355_C_ref <- exp(coefs["tt(Treat35.5)"] * log(time_grid))

# HR for 31°C, Symbiont D, Cross TxT
hr_31_D_TxT <- exp(
  coefs["tt(Treat31)"] * log(time_grid) +
  coefs["SymbiontTreatmentD:tt(Treat31)"] * log(time_grid) +
  coefs["Cross_2TxT:tt(Treat31)"] * log(time_grid) +
  coefs["SymbiontTreatmentD:Cross_2:tt(Treat31)"] * log(time_grid)
)

# HR for 35.5°C, Symbiont D, Cross TxT
hr_355_D_TxT <- exp(
  coefs["tt(Treat35.5)"] * log(time_grid) +
  coefs["SymbiontTreatmentD:tt(Treat35.5)"] * log(time_grid) +
  coefs["Cross_2TxT:tt(Treat35.5)"] * log(time_grid) +
  coefs["SymbiontTreatmentD:Cross_2:tt(Treat35.5)"] * log(time_grid)
)
library(ggplot2)
df_hr <- data.frame(
  Day = rep(time_grid, 4),
  HR = c(hr_31_C_ref, hr_31_D_TxT, hr_355_C_ref, hr_355_D_TxT),
  Group = rep(c("31°C C BxB", "31°C D TxT", "35.5°C C BxB", "35.5°C D TxT"), each = length(time_grid))
)

ggplot(df_hr, aes(x = Day, y = HR, color = Group)) +
  geom_line(size = 1.2) +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")


# Test proportional hazards assumption
ph_test <- cox.zph(cox_3way)
print(ph_test)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                       coef exp(coef) se(coef)      z Pr(>|z|)    
#XTreatment         -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#XSymbiontTreatment  0.04804   1.04921  0.06201  0.775  0.43848    
#XReefMom           -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#                   exp(coef) exp(-coef) lower .95 upper .95
#XTreatment            0.7831     1.2770    0.7262    0.8445
#XSymbiontTreatment    1.0492     0.9531    0.9291    1.1848
#XReefMom              0.9588     1.0430    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.83  on 3 df,   p=1e-10
#Wald test            = 48.21  on 3 df,   p=2e-10
#Score (logrank) test = 48.62  on 3 df,   p=2e-10

# Not all predictors are significant so use backward stepwise model selection to remove the most insignificant factor (symbiont treatment)

X2<-cbind(metadata_clean$Treatment, metadata_clean$ReefMom)# if you don’t have covariates, do not include them
# if observations are right censored:
cox2<- coxph (Surv(Timepoint, Status)~ X2, method='breslow', data = metadata_clean)
summary(cox2)

#Call:
#coxph(formula = Surv(Timepoint, Status) ~ X2, data = metadata, 
#    method = "breslow")

#  n= 2772, number of events= 1041 
#   (345 observations deleted due to missingness)

#                coef exp(coef) se(coef)      z Pr(>|z|)    
#X2Treatment -0.24448   0.78311  0.03853 -6.346 2.22e-10 ***
#X2ReefMom   -0.04209   0.95878  0.01553 -2.710  0.00673 ** 
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

#            exp(coef) exp(-coef) lower .95 upper .95
#X2Treatment    0.7831      1.277    0.7262    0.8445
#X2ReefMom      0.9588      1.043    0.9300    0.9884

#Concordance= 0.546  (se = 0.01 )
#Likelihood ratio test= 48.23  on 2 df,   p=3e-11
#Wald test            = 47.61  on 2 df,   p=5e-11
#Score (logrank) test = 48.02  on 2 df,   p=4e-11

# Compare models
AIC(cox, cox2) #cox2 has the lowest AIC so we keep it

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km <-survfit(Surv(Timepoint,Status)~ Treatment + ReefMom, data = metadata_clean) # do not include interactions
km
summary(km)

# Plot the survival curves
km$strata

# Plot the Kaplan-Meier curve
plot(km, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
#install.packages("survminer")
library(survminer)
require("survival")
ggsurvplot(km)
# Create a combined label for legend
metadata_clean$combined_label <- with(metadata_clean, paste(Treatment, ReefMom, sep = "."))

# Now refit the survival object
km <- survfit(Surv(Timepoint, Status) ~ combined_label, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.ReefMom",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET
# Fit the Kaplan-Meier survival curve
km2 <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom, data = metadata_clean)

ggsurv <- ggsurvplot(km2, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names <- c("coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue","coral2", "orange", "darkkhaki", "aquamarine3", "darkred", "darkorchid", "blue"
)

levels(km2$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km2, conf.int = TRUE, 
                     palette = custom_curve_names,  # Custom color palette
                     legend.title = "ReefMom",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
survival_curves_facet_ReefMom <- ggsurv$plot + 
    theme_bw() + 
    facet_wrap(~ Treatment)  # Faceting by Treatment

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_ReefMom.png", plot = survival_curves_facet_ReefMom, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pairs <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + ReefMom, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pairs

# Symbolic number coding
symnum(pairs$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")

# Extract survival probabilities at a specific time, e.g., time = 22
# You can do this using the 'summary()' function with the 'time' argument
surv_summary <- summary(km2, times = 22)

# Print the survival probability at time 22
print(surv_summary$surv)  # This gives the survival probabilities


#########
# Try interactions just to confirm SymbiontTreatment isn't significant
########

# Fit Cox proportional hazards model with interactions
cox.int <- coxph(Surv(Timepoint, Status) ~ Treatment * SymbiontTreatment * ReefMom, 
             method = 'breslow', data = metadata_clean)

# Display the summary of the model
summary(cox.int)

#SymbiontTreatment is not significant

#########
# Plot original model with SymbiontTreatment for visual
# Final Plot
########
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))
metadata_clean$ReefMom <- factor(metadata_clean$ReefMom,
                                levels = c("BT2", "BT4", "BT8", "Bulk", "TT12", "TT2", "TT6"),  # your original levels
                                labels = c("CC1", "CC2", "CC3", "WW1", "WW2", "WW3", "WW4"))  # new display names

metadata_clean$SymbiontTreatment <- factor(metadata_clean$SymbiontTreatment,
                                          levels = c("C", "D"),  # original levels
                                          labels = c("Cladocopium", "Durusdinium"))  # new display names


# Fit survival by Treatment + ReefMom + SymbiontTreatment
km.symb <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom + SymbiontTreatment, data = metadata_clean)

# Extract Treatment from strata names
strata_names <- names(km.symb$strata)

# Extract Treatment from each strata string
library(stringr)
treatment_in_strata <- str_extract(strata_names, "(?<=Treatment=)[^,]+")

# Create a vector mapping each strata to one of your 3 colors
my_colors_42 <- ifelse(treatment_in_strata == "Ambient", "#3288bd",
                 ifelse(treatment_in_strata == "31", "#fee08b",
                        ifelse(treatment_in_strata == "35.5", "#d53e4f", "black")))

names(my_colors_42) <- strata_names

# Now pass this as palette to ggsurvplot
ggsurv <- ggsurvplot(km.symb,
                     conf.int = TRUE,
                     palette = my_colors_42,
                     legend.title = "Treatment",
                     conf.int.alpha = 0.2)

# Add facets
survival_curves_facet_Symb <- ggsurv$plot +
    theme_bw() +
    facet_grid(ReefMom ~ SymbiontTreatment) + theme(
    strip.background = element_blank(),  # removes the grey background box
    strip.text = element_text(color = "black", face = "bold", size = 12),
    legend.position = "none" # text styling
  )

print(survival_curves_facet_Symb)

time_grid <- 1:22  # experiment duration in days
coefs <- coef(cox_td_3way)
library(dplyr)

combinations <- expand.grid(
  SymbiontTreatment = c("C", "D"),
  Temperature = c("31", "35.5"),
  Cross_2 = c("BxB", "TxT")
)
compute_hr <- function(symbiont, temp, cross, coefs, time_grid) {
  
  # Identify the relevant tt term
  tt_term <- if(temp == "31") "tt(Treat31)" else "tt(Treat35.5)"
  
  # Start with main time-dependent effect
  hr_log <- coefs[tt_term] * log(time_grid)
  
  # Symbiont × tt
  sym_tt <- paste0("SymbiontTreatmentD:", tt_term)
  if(symbiont == "D" & sym_tt %in% names(coefs)) hr_log <- hr_log + coefs[sym_tt] * log(time_grid)
  
  # Cross × tt
  cross_tt <- paste0("Cross_2TxT:", tt_term)
  if(cross == "TxT" & cross_tt %in% names(coefs)) hr_log <- hr_log + coefs[cross_tt] * log(time_grid)
  
  # Three-way interaction
  threeway <- paste0("SymbiontTreatmentD:", "Cross_2TxT:", tt_term)
  if(symbiont == "D" & cross == "TxT" & threeway %in% names(coefs)) hr_log <- hr_log + coefs[threeway] * log(time_grid)
  
  exp(hr_log)
}
hr_list <- mapply(
  FUN = compute_hr,
  symbiont = combinations$SymbiontTreatment,
  temp = combinations$Temperature,
  cross = combinations$Cross_2,
  MoreArgs = list(coefs = coefs, time_grid = time_grid),
  SIMPLIFY = FALSE
)
df_hr <- do.call(rbind, lapply(1:nrow(combinations), function(i) {
  data.frame(
    Day = time_grid,
    HR = hr_list[[i]],
    Group = paste(combinations$Temperature[i], combinations$SymbiontTreatment[i], combinations$Cross_2[i], sep = "°C ")
  )
}))
ggplot(df_hr, aes(x = Day, y = HR, color = Group)) +
  geom_line(size = 1.2) +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")

# 1️⃣ Compute HR for baseline group: Ambient BxB + C
baseline_hr <- compute_hr(symbiont = "C", temp = "31", cross = "BxB", coefs = coefs, time_grid = time_grid)
# If you want Ambient group to include both temps as reference, repeat accordingly

# 2️⃣ Adjust all HRs relative to baseline
df_hr <- do.call(rbind, lapply(1:nrow(combinations), function(i) {
  hr_adj <- hr_list[[i]] / baseline_hr  # divide by baseline to get relative HR
  data.frame(
    Day = time_grid,
    HR = hr_adj,
    Group = paste(combinations$Temperature[i], combinations$SymbiontTreatment[i], combinations$Cross_2[i], sep = "°C ")
  )
}))

# 3️⃣ Plot
ggplot(df_hr, aes(x = Day, y = HR, color = Group)) +
  geom_line(size = 1.2) +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient BxB C") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")







# --- 1️⃣ Define time grid ---
time_grid <- 1:22  # experiment duration in days

# --- 2️⃣ Extract coefficients and variance-covariance matrix ---
coefs <- coef(cox_td_3way)
vcov_mat <- vcov(cox_td_3way)

# --- 3️⃣ Define all combinations ---
combinations <- expand.grid(
  SymbiontTreatment = c("C", "D"),
  Temperature = c("31", "35.5"),
  Cross_2 = c("BxB", "TxT")
)

# --- 4️⃣ Function to compute HR(t) and 95% CI ---
compute_hr_ci <- function(symbiont, temp, cross, coefs, vcov_mat, time_grid) {
  
  tt_term <- if(temp == "31") "tt(Treat31)" else "tt(Treat35.5)"
  
  # Build coefficient vector for this combination
  coef_vec <- rep(0, length(coefs))
  names(coef_vec) <- names(coefs)
  
  # Main time-dependent effect
  coef_vec[tt_term] <- 1
  
  # Symbiont × tt
  sym_tt <- paste0("SymbiontTreatmentD:", tt_term)
  if(symbiont == "D" & sym_tt %in% names(coefs)) coef_vec[sym_tt] <- 1
  
  # Cross × tt
  cross_tt <- paste0("Cross_2TxT:", tt_term)
  if(cross == "TxT" & cross_tt %in% names(coefs)) coef_vec[cross_tt] <- 1
  
  # Three-way interaction
  threeway <- paste0("SymbiontTreatmentD:Cross_2TxT:", tt_term)
  if(symbiont == "D" & cross == "TxT" & threeway %in% names(coefs)) coef_vec[threeway] <- 1
  
  # Indices of used coefficients
  idx <- which(coef_vec != 0)
  
  # Compute log(HR) for each time
  log_hr <- sapply(time_grid, function(t) sum(coef_vec[idx] * log(t)))
  
  # Compute SE for each time point (delta method)
  se_log_hr <- sapply(time_grid, function(t) sqrt(sum((log(t)^2) * diag(vcov_mat[idx, idx]))))
  
  # HR and 95% CI
  data.frame(Day = time_grid,
             HR = exp(log_hr),
             Lower = exp(log_hr - 1.96 * se_log_hr),
             Upper = exp(log_hr + 1.96 * se_log_hr))
}


# --- 5️⃣ Compute HR(t) + CIs for all combinations ---
hr_ci_list <- lapply(1:nrow(combinations), function(i) {
  df <- compute_hr_ci(
    symbiont = combinations$SymbiontTreatment[i],
    temp = combinations$Temperature[i],
    cross = combinations$Cross_2[i],
    coefs = coefs,
    vcov_mat = vcov_mat,
    time_grid = time_grid
  )
  df$Group <- paste(combinations$Temperature[i], combinations$SymbiontTreatment[i], combinations$Cross_2[i], sep = "°C ")
  df
})

df_hr_ci <- do.call(rbind, hr_ci_list)

# --- 6️⃣ Plot with ggplot2 ---
library(ggplot2)

ggplot(df_hr_ci, aes(x = Day, y = HR, color = Group, fill = Group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.2, color = NA) +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1")


# Create a dataframe of p-values to include on the plots
facet_pvals <- metadata_clean %>%
  group_by(ReefMom, SymbiontTreatment) %>%
  summarise(
    p = tryCatch({
      survdiff(Surv(Timepoint, Status) ~ Treatment, data = pick(everything()))$chisq %>%
        {1 - pchisq(., df = n_distinct(Treatment) - 1)}
    }, error = function(e) NA),
    .groups = "drop"
  ) %>%
  mutate(
    label = paste0("p = ", signif(p, 3)),
    x = 0,         # adjust as needed for your plot's x-axis scale
    y = 0.05       # adjust as needed for your plot's y-axis scale
  )

#add p-values to the plot by facet
survival_curves_facet_Symb <- ggsurv$plot +
  facet_grid(ReefMom ~ SymbiontTreatment) +
  theme_bw() +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(color = "black", face = "italic", size = 12),
    legend.position = "none"
  ) +
  geom_text(data = facet_pvals, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, vjust = 0, size = 4)

#save
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_Symb.png", plot = survival_curves_facet_Symb, width = 10, height = 20, dpi = 300)

# Extract survival probabilities at a specific time, e.g., time = 22
# You can do this using the 'summary()' function with the 'time' argument
surv_summary <- summary(km.symb, times = 22)

# Print the survival probability at time 22
print(surv_summary$surv)  # This gives the survival probabilities

# Fit survival by Treatment + ReefMom + SymbiontTreatment
km.symb2 <- survfit(Surv(Timepoint, Status) ~ Treatment + ReefMom, data = metadata_clean)
surv_summary <- summary(km.symb2, times = 15)

# Subset for 27.5°C
data_27 <- metadata_clean %>% filter(Treatment == "Ambient")

# Subset for 31°C
data_31 <- metadata_clean %>% filter(Treatment == "31")

# KM log-rank test at 27.5°C
survdiff(Surv(Timepoint, Status) ~ ReefMom, data = data_27)

# KM log-rank test at 31°C
survdiff(Surv(Timepoint, Status) ~ ReefMom, data = data_31)

survdiff(Surv(Timepoint, Status) ~ Treatment * ReefMom, data = metadata_clean)

###
#Simplify figure to just Treatment
###

# Ensure Treatment is a factor with correct order
metadata_clean$Treatment <- factor(metadata_clean$Treatment,
                                   levels = c("Ambient", "31", "35.5"),
                                   labels = c("27.5°C", "31°C", "35.5°C"))

# Fit KM model by Treatment only
km_fit <- survfit(Surv(Timepoint, Status) ~ Treatment, data = metadata_clean)

# Define treatment colors
treatment_colors <- c(
  "Treatment=27.5°C" = "#3288bd",
  "Treatment=31°C"   = "#fee08b",
  "Treatment=35.5°C" = "#d53e4f"
)

# Plot
km_plot <- ggsurvplot(
  km_fit,
  data = metadata_clean,
  conf.int = TRUE,
  pval = TRUE,
  palette = treatment_colors,
  legend.title = "Temperature",
  xlab = "Time (days)",
  ylab = "Survival probability",
  risk.table = FALSE
)

# Display plot
print(km_plot)

# Save if needed
ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/KM_survival_by_Treatment.png", plot = km_plot$plot, width = 8, height = 6, dpi = 300)

# Pairwise comparisons with log-rank test
pairwise_res <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment,
                                  data = metadata_clean,
                                  p.adjust.method = "BH")  # Benjamini-Hochberg correction for multiple testing

print(pairwise_res$p.value)

```
##Survival Analysis
Cox model: with Treatment and Cross_2
```{r}
# Determine the class of the Factors (not the covariates):
class(metadata_clean$Cross_2)
#If any of the factors is not a “factor”, redefine it as a factor:
metadata_clean$Cross_2 <- factor(metadata_clean$Cross_2)
# Check for missing values in the columns used in the model
sum(is.na(metadata_clean$Cross_2))

X3<-cbind(metadata_clean$Treatment, metadata_clean$Cross_2)# if you don’t have covariates, do not include them
# if observations are right censored:
cox3 <- coxph (Surv(Timepoint, Status)~ X3, method='breslow', data = metadata_clean)
summary(cox3)

# Plot
# To plot the predicted probability of an event not occurring over time (for significant factors only) and use the model to make predictions

km3 <-survfit(Surv(Timepoint,Status)~ Treatment + Cross_2, data = metadata_clean) # do not include interactions
km3
summary(km3)

# Plot the survival curves
km3$strata

plot(km3, 
     lwd = 2, 
     xlab = 'Time', 
     ylab = 'Probability of the Event not to occur', 
     lty = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),
     col = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),  # Dynamically adjust colors
     conf.int = FALSE)

#Use ggplot
ggsurvplot(km3)
# Create a combined label for legend
metadata_clean$combined_label2 <- with(metadata_clean, paste(Treatment, Cross_2, sep = "."))

# Now refit the survival object
km4 <- survfit(Surv(Timepoint, Status) ~ combined_label2, data = metadata_clean)

# Generate unique labels for the legend based on combined_label
unique_combined_labels <- levels(as.factor(metadata_clean$combined_label2))

# Plot the survival curves
ggsurv_all <- ggsurvplot(km4, 
           data = metadata_clean, 
           conf.int = TRUE, 
           pval = TRUE, 
           risk.table = FALSE, 
           legend.title = "Treatment.Cross_2",
           legend.labs = unique_combined_labels,  # Now use combined labels
           title = "Kaplan-Meier Curve for Genet Survival", 
           risk.table.height = 2)

#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves.png", plot = ggsurv_all$plot, width = 10, height = 8, dpi = 300)

ggsurv_all$plot +theme_bw()

### FACET

# Fit the Kaplan-Meier survival curve
km5 <- survfit(Surv(Timepoint, Status) ~ Treatment + Cross_2, data = metadata_clean)

summary(km5)

ggsurv <- ggsurvplot(km5, conf.int = TRUE)

ggsurv$plot +theme_bw() + facet_wrap(~ Treatment)

# Ensure Treatment is a factor with specified levels
metadata_clean$Treatment <- factor(metadata_clean$Treatment, levels = c("Ambient", "31", "35.5"))

# Create custom color names for each curve
custom_curve_names2 <- c("aquamarine3", "orange", "aquamarine3", "orange", "aquamarine3", "orange")

levels(km5$strata)

# Create the survival plot with custom colors
ggsurv <- ggsurvplot(km5, conf.int = TRUE, 
                     palette = custom_curve_names2,  # Custom color palette
                     legend.title = "Source Reef",
                     conf.int.alpha = 0.2)  # Set legend title

# Customize the plot
final_plot <- ggsurv$plot + 
              theme_bw() + 
              facet_wrap(~ Treatment)  # Faceting by Treatment

# Save the plot using ggsave
#ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/survival_curves_facet_SourceReef.png", plot = final_plot, width = 10, height = 5, dpi = 300)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment + Cross_2, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair

# Symbolic number coding
symnum(pair$p.value, cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 0.1, 1),
   symbols = c("****", "***", "**", "*", "+", " "),
   abbr.colnames = FALSE, na = "")

# Extract survival probabilities at a specific time, e.g., time = 22
# You can do this using the 'summary()' function with the 'time' argument
surv_summary <- summary(km5, times = 22)

# Print the survival probability at time 22
print(surv_summary$surv)  # This gives the survival probabilities

#at day 22:
# ambient BxB = 0.4891414 +- 0.0836
# ambient TxT = 0.8182818 +- 0.0693
# 31 BxB = 0.1330052 +- 0.0438
# 31 TxT = 0.1398107 +- 0.0406
# 35.5 = 0.0000000 and 0.0000000


```

Survival Analysis
Just Treatment as a variable

```{r}
# Fit the Kaplan-Meier survival curve
km6 <- survfit(Surv(Timepoint, Status) ~ Treatment, data = metadata_clean)

summary(km6)

#Bonferroni post-hoc test
# Perform pairwise comparisons of survival curves
pair2 <- pairwise_survdiff(Surv(Timepoint, Status) ~ Treatment, 
                  data = metadata_clean,
                  p.adjust.method = "bonferroni")

pair2
```
#HEATMAP WITH SOURCE REEF (CC and WW instead of individial families)

##Fv/Fm with Source Reef
```{r}
#Fv/Fm #################################################### 
library(MCMCglmm)
# Set factor levels
df_with_extremes <- df_with_extremes %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
df_with_extremes$Treatment <- factor(df_with_extremes$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
df_with_extremes$Cross_2 <- factor(df_with_extremes$Cross_2, 
                                     levels = c("BxB", "TxT"))
df_with_extremes$SymbiontTreatment <- factor(df_with_extremes$SymbiontTreatment, 
                                     levels = c("C", "D"))

#df_with_extremes <- df_with_extremes %>%
 # mutate(logPercChange = log1p(PercChange))  # log1p handles 0 and negative % changes better


hist(df$PercChange, breaks = 50)
summary(df$PercChange)

#Set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)


# Fit the model
model3.reef <- MCMCglmm(RawChangeFvFm ~ SymbiontTreatment * Cross_2 * Treatment, 
                        random = ~ Replicate, 
                        data = df_with_extremes, 
                        family = "gaussian",  
                        prior = prior,
                        nitt = 50000, burnin = 10000, thin = 20)

solution_summary <- summary(model3.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model3.reef$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# 1. Create prediction grid
newdat.reef <- expand.grid(
  SymbiontTreatment = levels(df_with_extremes$SymbiontTreatment),
  Cross_2 = levels(df_with_extremes$Cross_2),
  Treatment = levels(df_with_extremes$Treatment)
)

#match levels exactly to model
newdat.reef$Treatment <- factor(newdat.reef$Treatment,
                                levels = levels(df_with_extremes$Treatment))  # same as model
newdat.reef$Cross_2 <- factor(newdat.reef$Cross_2,
                              levels = levels(df_with_extremes$Cross_2))
newdat.reef$SymbiontTreatment <- factor(newdat.reef$SymbiontTreatment,
                                        levels = levels(df_with_extremes$SymbiontTreatment))

# Ensure factor levels match original data
newdat.reef <- newdat.reef %>%
  mutate(across(everything(), ~ factor(.x, levels = levels(df_with_extremes[[cur_column()]]))))

#double check factors
newdat.reef[1, ]  # Should show Ambient, BxB, C

# 2. Generate design matrix
# Model matrix for prediction rows
X_full <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat.reef)
X <- X_full[, colnames(model3.reef$Sol), drop = FALSE]

# 3. Posterior predictions
# For each prediction, calculate a "pMCMC-equivalent" value
# This is done by testing whether the *linear combination of coefficients* differs from 0
# using the posterior distribution (model3.reef$Sol)

posterior_preds <- X %*% t(model3.reef$Sol)

newdat.reef$pred_mean <- rowMeans(posterior_preds)
newdat.reef$lower <- apply(posterior_preds, 1, quantile, probs = 0.025)
newdat.reef$upper <- apply(posterior_preds, 1, quantile, probs = 0.975)

# 4. Calculate pMCMC: proportion of posterior samples less than 0 or greater than 0 (optional)
newdat.reef$pMCMC <- apply(posterior_preds, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance at alpha = 0.05
newdat.reef$significant <- newdat.reef$pMCMC < 0.05


# Create label
newdat.reef$label_combined <- paste0(
  round(as.numeric(as.character(newdat.reef$pred_mean)), 1),
  ifelse(newdat.reef$significant, "*", "")
)

# Make sure pred_mean is numeric for fill
newdat.reef$pred_mean <- as.numeric(as.character(newdat.reef$pred_mean))

# 5. Compare to control (Ambient X BxB X C)
control_row <- which(
  newdat.reef$Treatment == "Ambient" &
  newdat.reef$Cross_2 == "BxB" &
  newdat.reef$SymbiontTreatment == "C"
)

control_post <- posterior_preds[control_row, ]

diff_matrix_control <- sweep(posterior_preds, 2, control_post, FUN = "-")

pMCMC_control <- apply(diff_matrix_control, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

diff_summary_control <- t(apply(diff_matrix_control, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
}))

diff_summary_control <- as.data.frame(diff_summary_control)
colnames(diff_summary_control) <- c("mean_control", "lower_control", "upper_control")
diff_summary_control$pMCMC_control <- pMCMC_control

diff_summary_control$signif_label_control <- case_when(
  pMCMC_control < 0.005 ~ "**",
  pMCMC_control < 0.05  ~ "*",
  TRUE                  ~ ""
)

diff_summary_control$label_combined_control <- paste0(
  round(diff_summary_control$mean_control, 2),
  diff_summary_control$signif_label_control
)

diff_summary_control$significant_vs_control <- with(
  diff_summary_control,
  lower_control > 0 | upper_control < 0
)

# 6. Combine with newdat.reef
newdat.reef <- cbind(newdat.reef, diff_summary_control)

# Plot predicted means
ggplot(newdat.reef, aes(x = Treatment, y = Cross_2, fill = mean_control)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined_control), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Difference from Control") +
  theme_minimal() +
  labs(title = "Predicted Fv/Fm Change Relative to Control (Ambient × CC × C)",
       x = "Temperature", y = "Host Genotype")

# 7. # Posterior predictions for each Treatment
posterior_preds <- X %*% t(model3.reef$Sol)
rownames(posterior_preds) <- newdat.reef$Treatment

# All pairwise comparisons
treatments <- levels(df_with_extremes$Treatment)
pairwise_comparisons <- t(combn(treatments, 2))  # all unique pairs

pairwise_results <- apply(pairwise_comparisons, 1, function(pair) {
  t1 <- pair[1]
  t2 <- pair[2]
  diff <- posterior_preds[t2, ] - posterior_preds[t1, ]
  
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  q <- quantile(diff, probs = c(0.025, 0.975))
  
  data.frame(
    contrast = paste(t2, "–", t1),
    mean_diff = mean(diff),
    lower = q[1],
    upper = q[2],
    pMCMC = pMCMC,
    signif = case_when(
      pMCMC < 0.005 ~ "**",
      pMCMC < 0.05  ~ "*",
      TRUE          ~ ""
    )
  )
})

pairwise_results <- do.call(rbind, pairwise_results)

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
model_treatment <- MCMCglmm(
  fixed = PercChange ~ Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_symbiont <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_cross2 <- MCMCglmm(
  fixed = PercChange ~ Cross_2,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_R2(model_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_R2(model_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(model_cross2, df_with_extremes, PercChange ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChange ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_with_extremes, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_conditional_R2(model_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(model_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(model_cross2, df_with_extremes, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),
  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  )
)

print(results_df)

print(results_df)

print(r2_interaction)
str(r2_interaction)

results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

```

##Larval Size with Source Reef
```{r}

#Larval Size #####################################

# Ensure factors are ordered
df_with_extremes$Treatment <- factor(df_with_extremes$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
df_with_extremes$Cross_2 <- factor(df_with_extremes$Cross_2, 
                                     levels = c("BxB", "TxT"))
df_with_extremes$SymbiontTreatment <- factor(df_with_extremes$SymbiontTreatment, 
                                     levels = c("C", "D"))

mod.s.reef <- MCMCglmm(PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment, 
                  random = ~ Replicate, 
                  data = df_with_extremes, 
                  family = "gaussian",  # Use gaussian for continuous proportions
                  prior = prior,
                  nitt = 50000,    # Number of MCMC iterations
                  burnin = 10000,  # Burn-in period
                  thin = 20)       # Thinning interval

summary(mod.s.reef)
#DIC: -2345.138 
solution_summary <- summary(mod.s.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(mod.s.reef$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# 1. Create prediction grid
newdat_size_reef <- expand.grid(
  SymbiontTreatment = levels(df_with_extremes$SymbiontTreatment),
  Cross_2 = levels(df_with_extremes$Cross_2),
  Treatment = levels(df_with_extremes$Treatment)
)

# Match factor levels explicitly (good practice)
newdat_size_reef$SymbiontTreatment <- factor(newdat_size_reef$SymbiontTreatment, levels = levels(df_with_extremes$SymbiontTreatment))
newdat_size_reef$Cross_2 <- factor(newdat_size_reef$Cross_2, levels = levels(df_with_extremes$Cross_2))
newdat_size_reef$Treatment <- factor(newdat_size_reef$Treatment, levels = levels(df_with_extremes$Treatment))

# Ensure factor levels match original data
newdat_size_reef <- newdat_size_reef %>%
  mutate(across(everything(), ~ factor(.x, levels = levels(df_with_extremes[[cur_column()]]))))

#double check factors
newdat_size_reef[1, ]  # Should show Ambient, BxB, C

# 2. Construct model matrix
X_full_s <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat_size_reef)

# Align columns with posterior samples matrix
X_s <- X_full_s[, colnames(mod.s.reef$Sol), drop = FALSE]

# 3. Generate posterior predictions matrix
pred_matrix_s <- X_s %*% t(mod.s.reef$Sol)  # rows = newdat rows, cols = MCMC samples

# Calculate posterior mean predictions
newdat_size_reef$pred_mean <- rowMeans(pred_matrix_s)

# Calculate 95% credible intervals
newdat_size_reef$lower <- apply(pred_matrix_s, 1, quantile, probs = 0.025)
newdat_size_reef$upper <- apply(pred_matrix_s, 1, quantile, probs = 0.975)

# 4. Calculate pMCMC values: two-tailed test for each posterior distribution
newdat_size_reef$pMCMC <- apply(pred_matrix_s, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance: TRUE if 95% CI excludes zero
newdat_size_reef$significant <- !(newdat_size_reef$lower < 0 & newdat_size_reef$upper > 0)

# Create label with stars for significance
newdat_size_reef$label_combined <- paste0(
  round(newdat_size_reef$pred_mean, 1),
  ifelse(newdat_size_reef$significant, "*", "")
)

# 5. Compare to control (Ambient × CC × C)
control_post <- pred_matrix_s[1, ]  # 1st row = control

diff_matrix_control <- sweep(pred_matrix_s, 2, control_post, FUN = "-")

pMCMC_control <- apply(diff_matrix_control, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

diff_summary_control <- t(apply(diff_matrix_control, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
}))

diff_summary_control <- as.data.frame(diff_summary_control)
colnames(diff_summary_control) <- c("mean_control", "lower_control", "upper_control")
diff_summary_control$pMCMC_control <- pMCMC_control

diff_summary_control$signif_label_control <- case_when(
  pMCMC_control < 0.005 ~ "**",
  pMCMC_control < 0.05  ~ "*",
  TRUE                  ~ ""
)

diff_summary_control$label_combined_control <- paste0(
  round(diff_summary_control$mean_control, 2),
  diff_summary_control$signif_label_control
)

diff_summary_control$significant_vs_control <- with(
  diff_summary_control,
  lower_control > 0 | upper_control < 0
)

# 6. Combine with newdat.reef
newdat_size_reef <- cbind(newdat_size_reef, diff_summary_control)

# Plot predicted larval size changes with significance
ggplot(newdat_size_reef, aes(x = Treatment, y = Cross_2, fill = mean_control)) +
  geom_tile(color = "white") +
  geom_text(aes(label = signif_label_control), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Difference from Control") +
  theme_minimal() +
  labs(title = "Predicted Change in Size (%) Relative to Control (Ambient × CC × C)",
       x = "Treatment", y = "Host Genotype")

# 7. # Posterior predictions for each Treatment
pred_matrix_s <- X_s %*% t(mod.s.reef$Sol)
rownames(pred_matrix_s) <- newdat_size_reef$Treatment

# All pairwise comparisons
treatments <- levels(df_with_extremes$Treatment)
pairwise_comparisons <- t(combn(treatments, 2))  # all unique pairs

pairwise_results <- apply(pairwise_comparisons, 1, function(pair) {
  t1 <- pair[1]
  t2 <- pair[2]
  diff <- pred_matrix_s[t2, ] - pred_matrix_s[t1, ]
  
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  q <- quantile(diff, probs = c(0.025, 0.975))
  
  data.frame(
    contrast = paste(t2, "–", t1),
    mean_diff = mean(diff),
    lower = q[1],
    upper = q[2],
    pMCMC = pMCMC,
    signif = case_when(
      pMCMC < 0.005 ~ "**",
      pMCMC < 0.05  ~ "*",
      TRUE          ~ ""
    )
  )
})

pairwise_results <- do.call(rbind, pairwise_results)

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_size_treatment <- MCMCglmm(PercChangeSize ~ Treatment, 
                          random = ~ Replicate , 
                          data = df_with_extremes, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont <- MCMCglmm(PercChangeSize ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = df_with_extremes, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family <- MCMCglmm(PercChangeSize ~ Cross_2, 
                       random = ~ Replicate , 
                       data = df_with_extremes, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_R2(mod_size_treatment, df_with_extremes, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_size_symbiont, df_with_extremes, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_size_family, df_with_extremes, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeSize ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_with_extremes,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_with_extremes, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_with_extremes, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_size_treatment, df_with_extremes, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_size_symbiont, df_with_extremes, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_size_family, df_with_extremes, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)


```

##Cell Density with Source Reef
```{r}
#Cell Density ############################################

# Model and plot excluding 35.5 treatment level

# Ensure factors are ordered
totaldf_long$Treatment <- factor(totaldf_long$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
totaldf_long$Cross_2 <- factor(totaldf_long$Cross_2, 
                                     levels = c("CC", "WW"))
totaldf_long$SymbiontTreatment <- factor(totaldf_long$SymbiontTreatment, 
                                     levels = c("C", "D"))
totaldf_long <- totaldf_long %>%
  mutate(Timepoint = as.numeric(Timepoint)) %>%
  arrange(UniqueID, Timepoint)

df_subset <- totaldf_long %>% filter(Treatment != "35.5")
df_subset$Treatment <- droplevels(df_subset$Treatment)

df_subset$logChangeCells <- log(df_subset$PercChangeCells + 1)

#check how many observations per group
table(df_subset$SymbiontTreatment, df_subset$Cross_2, df_subset$Treatment)

model_subset <- MCMCglmm(
  logChangeCells ~ SymbiontTreatment * Cross_2 * Treatment,
  random = ~ Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_subset)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_subset$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size
heidel.diag(mcmc_obj)  # Heidelberger-Welch convergence diagnostic

# 1. Create prediction grid
newdat2_subset <- expand.grid(
  SymbiontTreatment = levels(df_subset$SymbiontTreatment),
  Cross_2 = levels(df_subset$Cross_2),
  Treatment = levels(df_subset$Treatment)  # Only Ambient and 31 here
)

newdat2_subset$SymbiontTreatment <- factor(newdat2_subset$SymbiontTreatment, levels = levels(df_subset$SymbiontTreatment))
newdat2_subset$Cross_2 <- factor(newdat2_subset$Cross_2, levels = levels(df_subset$Cross_2))
newdat2_subset$Treatment <- factor(newdat2_subset$Treatment, levels = levels(df_subset$Treatment))

#check factors
lapply(newdat2_subset[, c("SymbiontTreatment", "Cross_2", "Treatment")], function(x) length(unique(x)))
newdat2_subset[1, ]  # Should show Ambient, BxB, C

# 2. Generate model matrix
X_full_subset <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat2_subset)
X_subset <- X_full_subset[, colnames(model_subset$Sol), drop = FALSE]

# 3. Posterior predictions
pred_matrix_subset <- X_subset %*% t(model_subset$Sol)
newdat2_subset$pred_mean <- rowMeans(pred_matrix_subset)
newdat2_subset$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat2_subset$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat2_subset$significant <- !(newdat2_subset$lower < 0 & newdat2_subset$upper > 0)
newdat2_subset$label_combined <- paste0(round(newdat2_subset$pred_mean, 2),
                                       ifelse(newdat2_subset$significant, "*", ""))
# 4. Calculate pMCMC values: two-tailed test for each posterior distribution
newdat2_subset$pMCMC <- apply(pred_matrix_subset, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# 5. Compare to control (Ambient × CC × C)
# Make sure you use the first row of the posterior predictions for this subset
control_post <- pred_matrix_subset[1, ]  # first row = Ambient × CC × C

# Subtract control from all rows
diff_matrix_control <- sweep(pred_matrix_subset, 2, control_post, FUN = "-")

# Compute pMCMC for difference-from-control
pMCMC_control <- apply(diff_matrix_control, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Summarize difference-from-control
diff_summary_control <- t(apply(diff_matrix_control, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
}))

diff_summary_control <- as.data.frame(diff_summary_control)
colnames(diff_summary_control) <- c("mean_control", "lower_control", "upper_control")
diff_summary_control$pMCMC_control <- pMCMC_control

diff_summary_control$signif_label_control <- case_when(
  pMCMC_control < 0.005 ~ "**",
  pMCMC_control < 0.05  ~ "*",
  TRUE                  ~ ""
)

diff_summary_control$label_combined_control <- paste0(
  round(diff_summary_control$mean_control, 2),
  diff_summary_control$signif_label_control
)

diff_summary_control$significant_vs_control <- with(
  diff_summary_control,
  lower_control > 0 | upper_control < 0
)

# Combine difference-from-control with your prediction grid
newdat2_subset <- cbind(newdat2_subset, diff_summary_control)

# Plot differences relative to control
ggplot(newdat2_subset, aes(x = Treatment, y = Cross_2, fill = mean_control)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined_control), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_gradient2(
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0,
    name = "Difference from Control (%)"
  ) +
  theme_minimal() +
  labs(
    title = "Predicted Change in Cell Density Relative to Control (No 35.5)",
    x = "Treatment", y = "Host Genotype"
  )

# 7. # Posterior predictions for each Treatment
pred_matrix_subset <- X_subset %*% t(model_subset$Sol)
rownames(pred_matrix_subset) <- newdat2_subset$Treatment

# All pairwise comparisons
treatments <- levels(df_subset$Treatment)
pairwise_comparisons <- t(combn(treatments, 2))  # all unique pairs

pairwise_results <- apply(pairwise_comparisons, 1, function(pair) {
  t1 <- pair[1]
  t2 <- pair[2]
  diff <- pred_matrix_subset[t2, ] - pred_matrix_subset[t1, ]
  
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  q <- quantile(diff, probs = c(0.025, 0.975))
  
  data.frame(
    contrast = paste(t2, "–", t1),
    mean_diff = mean(diff),
    lower = q[1],
    upper = q[2],
    pMCMC = pMCMC,
    signif = case_when(
      pMCMC < 0.005 ~ "**",
      pMCMC < 0.05  ~ "*",
      TRUE          ~ ""
    )
  )
})

pairwise_results <- do.call(rbind, pairwise_results)

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_cells_treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = df_subset, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cells_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = df_subset, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cells_family <- MCMCglmm(PercChangeCells ~ Cross_2, 
                       random = ~ Replicate , 
                       data = df_subset, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, df_subset, full_formula)
r2_treatment <- calc_marginal_R2(mod_cells_treatment, df_subset, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_cells_symbiont, df_subset, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_cells_family, df_subset, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeCells ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = df_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, df_subset, PercChangeCells ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, df_subset, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_cells_treatment, df_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_cells_symbiont, df_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_cells_family, df_subset, PercChangeCells ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

# Pairwise comparisons
# Extract posterior draws
post <- model_subset$Sol

# Cladocopium at 31°C (Cross_CC is baseline)
clad_31 <- post[, "(Intercept)"] + post[, "Treatment31"]

# Durusdinium at 31°C (Cross_CC is baseline)
dur_31 <- post[, "(Intercept)"] +
          post[, "SymbiontTreatmentD"] +
          post[, "Treatment31"] +
          post[, "SymbiontTreatmentD:Treatment31"]

# Contrast
contrast <- dur_31 - clad_31

# Summary stats
mean_diff <- mean(contrast)
CI <- quantile(contrast, probs = c(0.025, 0.975))
pMCMC <- 2 * min(mean(contrast > 0), mean(contrast < 0))

# Output
cat("Durusdinium vs Cladocopium at 31°C (Cross_CC)\n")
cat("Mean difference:", round(mean_diff, 3), "\n")
cat("95% CI:", round(CI[1], 3), "to", round(CI[2], 3), "\n")
cat("pMCMC:", round(pMCMC, 4), "\n")

###############################################################
# Pairwise differences with just Treatment and SymbiontTreatment
mod_ts <- MCMCglmm(logChangeCells ~ Treatment * SymbiontTreatment, 
                          random = ~ Replicate , 
                          data = df_subset, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

newdat_ts <- expand.grid(
  Treatment = levels(df_subset$Treatment),
  SymbiontTreatment = levels(df_subset$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(df_subset$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(df_subset$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
Sol_ts <- mod_ts$Sol[, colnames(X_ts), drop = FALSE]
pred_mat_ts <- X_ts %*% t(Sol_ts)

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()


pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)
```
##Survival GLMM with glmmTMB package and Source Reef
```{r}
# Load libraries
library(dplyr)
library(tidyr)
library(MASS)
library(nlme)
library(emmeans)
library(ggplot2)
library(stringr)

# Step 1: Prepare long-format dataset
df_long <- df_Surv %>%
  rowwise() %>%
  mutate(
    Survived = list(c(rep(1, No.LarvaeInObserved), rep(0, Dead_Larvae))),
    LarvaID = list(seq_len(No.LarvaeInObserved + Dead_Larvae))
  ) %>%
  unnest(cols = c(Survived, LarvaID)) %>%
  ungroup() %>%
  mutate(
    symbiont = factor(SymbiontTreatment, levels = c("C", "D")),
    host = factor(Cross_2, levels = c("BxB", "TxT")),
    temperature = factor(Treatment, levels = c("Ambient", "31", "35.5")),
    timepoint = as.factor(Timepoint),
    rep = as.factor(Replicate)
  )

df_trimmed <- df_long %>%
  filter(!(temperature == "35.5" & as.numeric(as.character(timepoint)) > 6))
df_trimmed <- readRDS("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/df_trimmed.rds")

# Step 2: Fit binomial GLMM
model <- glmmPQL(
  fixed = Survived ~ symbiont * host * temperature,
  random = ~1 | timepoint,
  family = binomial,
  data = df_trimmed
)

summary(model)

#Check model fit
# Residual plot
plot(model)
# Residual deviance / degrees of freedom
deviance <- sum(residuals(model, type = "pearson")^2)
df <- df.residual(model)
dispersion <- deviance / df
dispersion  # Should be close to 1 but is 0

#Tried other models
#1
glm_quasi <- glm(cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature * Timepoint, 
                 data = df_long, 
                 family = quasibinomial())
summary(glm_quasi)

deviance(glm_quasi) / df.residual(glm_quasi)

#2
glm_quasi2 <- glm(cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature, 
                 data = df_trimmed, 
                 family = quasibinomial())
summary(glm_quasi)

#4
mod_survival <- glmmTMB(
  cbind(Survived, Dead_Larvae) ~ symbiont * host * temperature + (1 | Timepoint) +
  (1 | Replicate),
  family = binomial,
  control = glmmTMBControl(optCtrl = list(iter.max = 1000, eval.max = 1000)),
  data = df_trimmed
)
library(DHARMa)
sim_res <- simulateResiduals(mod_survival)
plot(sim_res)
testDispersion(sim_res)
testOutliers(sim_res, type = "bootstrap")

#5
mod_betabin <- glmmTMB( Survived ~ symbiont * host * temperature + 
    (1 | Timepoint / Replicate),
  family = binomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin)
plot(sim_res_beta)
testDispersion(sim_res_beta)

#6
mod_betabin <- glmmTMB( Survived ~ symbiont * host * temperature + 
    (1 | Timepoint / Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin)
plot(sim_res_beta)
testDispersion(sim_res_beta)

#7
#This is the best --> final model
library(splines)
library(glmmTMB)
library(DHARMa)

mod_betabin2 <- glmmTMB(Survived ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
sim_res_beta <- simulateResiduals(mod_betabin2)
plot(sim_res_beta)
testDispersion(sim_res_beta)
summary(mod_betabin2)

# Add residuals back to your dataset
df_trimmed$DHARMa_resid <- residuals(sim_res_beta)

# You can also extract standardized residuals explicitly if needed
df_trimmed$DHARMa_resid_std <- residuals(sim_res_beta, type = "scaled")

# Load ggplot2
library(ggplot2)

# Plot residuals by temperature
ggplot(df_trimmed, aes(x = predict(mod_betabin2, type = "response"),
                       y = DHARMa_resid_std)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  facet_wrap(~ temperature) +
  theme_minimal() +
  ylab("Standardized Residuals") +
  xlab("Fitted Values") +
  ggtitle("Residuals vs. Fitted Values by Temperature")

plotResiduals(sim_res_beta, form = df_trimmed$temperature)
plotResiduals(sim_res_beta, form = predict(mod_betabin2, type = "response"))

outliers <- which(sim_res_beta$outliers == TRUE)
df_trimmed[outliers, ]

res_df <- data.frame(
  residuals = sim_res_beta$scaledResiduals,
  fitted = sim_res_beta$fittedPredictedResponse,
  row = 1:nrow(df_trimmed)
)

# Join residuals with original data
res_df_full <- cbind(df_trimmed, res_df)

# View the most extreme residuals (positive or negative)
res_df_full %>%
  dplyr::arrange(desc(abs(residuals))) %>%
  dplyr::select(row, residuals, fitted, temperature, symbiont, host, timepoint, everything()) %>%
  head(10)

library(ggplot2)

ggplot(res_df_full, aes(x = temperature, y = residuals, color = temperature)) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(title = "DHARMa Residuals by Temperature Treatment")


#8
#nope, convergence warning
mod_groupdisp <- glmmTMB(Survived ~ symbiont * host * temperature + 
                           ns(as.numeric(timepoint), df = 4) + 
                           (1 | Replicate),
                         dispformula = ~ temperature,  # group-wise dispersion
                         family = betabinomial(link = "logit"),
                         data = df_trimmed)
anova(mod_betabin2, mod_groupdisp)

# Step 3: Estimated marginal means (EMMs)
emm <- emmeans(mod_betabin2, specs = ~ ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4))
emm_df <- as.data.frame(test(emm, null = 0))

# Add significance stars and clean labels
emm_df <- emm_df %>%
  mutate(
    signif_label = case_when(
      p.value < 0.005 ~ "**",
      p.value < 0.05  ~ "*",
      TRUE            ~ ""
    ),
    label_combined = paste0(round(emmean, 2), signif_label),
    temperature = factor(temperature, levels = c("Ambient", "31", "35.5")),
    host = factor(host, levels = c("BxB", "TxT")),
    symbiont = factor(symbiont, levels = c("C", "D"))
  )

emm_simple <- emmeans(mod_betabin2, specs = ~ symbiont * host * temperature, 
                      model = "response")  # if you want on response scale

contrasts_vs_control <- contrast(
  emm_simple,
  method = "trt.vs.ctrl",
  ref = which(with(as.data.frame(emm_simple),
                   symbiont == "C" & host == "BxB" & temperature == "Ambient"))
)

summary_contrasts <- summary(contrasts_vs_control, infer = TRUE)

summary_contrasts_df <- as.data.frame(summary_contrasts) %>%
  mutate(
    signif_label = case_when(
      p.value < 0.005 ~ "**",
      p.value < 0.05  ~ "*",
      TRUE            ~ ""
    ),
    label_combined = paste0(round(estimate, 2), signif_label)
  ) %>%
  rename(
    mean_control = estimate,
    lower_control = asymp.LCL,
    upper_control = asymp.UCL
  )

print(summary_contrasts_df)

# Extract LHS (the treatment being compared to control)
summary_contrasts_df <- summary_contrasts_df %>%
  mutate(lhs = str_remove(contrast, " - C BxB Ambient$")) %>%
  separate(lhs, into = c("symbiont", "host", "temperature"), sep = " ")

# Now you have symbiont, host, temperature columns
print(summary_contrasts_df %>% dplyr::select(contrast, symbiont, host, temperature, mean_control))

# Combine with EMMs for plotting
emm_df <- as.data.frame(emm_simple) %>%
  dplyr::left_join(summary_contrasts_df %>% 
              dplyr::select(symbiont, host, temperature, mean_control, lower_control, 
                     upper_control, signif_label, label_combined),
            by = c("symbiont", "host", "temperature"))

#set the order of temps for plotting
emm_df <- emm_df %>%
  mutate(
    temperature = factor(temperature, levels = c("Ambient", "31", "35.5"))
  )


# Step 4: Plot heatmap
ggplot(emm_df, aes(x = temperature, y = host, fill = emmean)) +
  geom_tile(color = "black") +
  geom_text(aes(label = label_combined), size = 4, color = "white") +
  facet_wrap(~ symbiont) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    name = "Predicted Survival"
  ) +
  labs(x = "Temperature Treatment", y = "Host Genotype",
       title = "Predicted Survival vs Control (Ambient × BxB × C)") +
  theme_minimal()

# 5. Get estimated marginal means for each Treatment
# Average across symbiont and host to get treatment-level means
emm_treatment <- emmeans(mod_betabin2, ~ temperature, 
                         weights = "proportional",   # marginalize over symbiont and host
                         type = "response")          # back-transform to probability scale

# Pairwise contrasts among temperatures
pairwise_treatment <- pairs(emm_treatment, adjust = "tukey")  # 31 vs Ambient, 35.5 vs Ambient, 35.5 vs 31

# Convert to dataframe for plotting or table
pairwise_treatment_df <- as.data.frame(pairwise_treatment) %>%
  mutate(
    signif_label = case_when(
      p.value < 0.005 ~ "**",
      p.value < 0.05  ~ "*",
      TRUE            ~ ""
    ),
    label_combined = paste0(round(odds.ratio, 2), signif_label)
  )

# Estimated marginal means for each treatment
emm_treatment_df <- as.data.frame(emm_treatment) %>%
  mutate(
    temperature = factor(temperature, levels = c("Ambient", "31", "35.5"))
  )

# View results
emm_treatment_df        # mean survival ± SE or CI for each temperature
pairwise_treatment_df   # all pairwise contrasts and significance


# Option 1: Using sjstats
install.packages("sjstats")
install.packages("performance")
library(sjstats)
library(performance)
library(glmmTMB)
library(splines)
library(tibble)


mod_betabin2 <- glmmTMB(Survived ~ symbiont * host * temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
  family = betabinomial(link = "logit"),
  data = df_trimmed
)
# Get marginal R² from full model
r2_full <- r2(mod_betabin2)$R2_marginal

# Fit reduced models — one fixed effect at a time (including ns(timepoint) and random intercept)
mod_symbiont <- glmmTMB(Survived ~ symbiont + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                    family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_symbiont)

mod_host <- glmmTMB(Survived ~ host + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_host)

mod_temp <- glmmTMB(Survived ~ temperature + ns(as.numeric(timepoint), df = 4) + (1 | Replicate),
                family = betabinomial(link = "logit"), data = df_trimmed)
r2(mod_temp)

# Extract marginal and conditional R2
r2_full <- r2(mod_betabin2)
r2_symbiont <- r2(mod_symbiont)
r2_host     <- r2(mod_host)
r2_temp     <- r2(mod_temp)

# Calculate ΔR² for each effect
delta_symbiont <- r2_full$R2_marginal - r2_symbiont$R2_marginal
delta_host     <- r2_full$R2_marginal - r2_host$R2_marginal
delta_temp     <- r2_full$R2_marginal - r2_temp$R2_marginal

# Total ΔR² across all reduced models
total_delta <- delta_symbiont + delta_host + delta_temp

# Relative % contribution of each fixed effect
rel_contrib_symbiont <- 100 * delta_symbiont / total_delta
rel_contrib_host     <- 100 * delta_host     / total_delta
rel_contrib_temp     <- 100 * delta_temp     / total_delta


# Create summary table
summary_df <- tibble(
  Model = c("Full", "Symbiont-only", "Host-only", "Temperature-only"),
  R2_marginal = c(r2_full$R2_marginal, r2_symbiont$R2_marginal, r2_host$R2_marginal, r2_temp$R2_marginal),
  R2_conditional = c(r2_full$R2_conditional, r2_symbiont$R2_conditional, r2_host$R2_conditional, r2_temp$R2_conditional),
  Relative_Contribution = c(NA, rel_contrib_symbiont, rel_contrib_host, rel_contrib_temp)
)

print(summary_df)

# Save results
write.csv(summary_df, "glmmTMB_relative_r2.csv", row.names = FALSE)
saveRDS(summary_df, "glmmTMB_relative_r2.rds")
```
Make a "mega heatmap" with all 5 traits using CROSS_2
```{r}
newdat_size_reef$Trait <- "Larval Size"
newdat.reef$Trait <- "Fv/Fm"
newdat2_subset$Trait <- "Cell Density"
emm_df$Trait <- "Survival"
newdat_perc$Trait <- "Acquisition"

colnames(emm_df)[1:3] <- c("SymbiontTreatment", "Cross_2", "Treatment")
emm_df <- emm_df %>%
  rename(label_combined_control = label_combined)
newdat_perc <- newdat_perc %>%
  rename(Cross_2 = Cross)

# Recode all Cross_2 consistently
recode_cross <- function(df) {
  df %>% 
    mutate(Cross_2 = recode_factor(Cross_2,
                                   "WW" = "WW",
                                   "TxT" = "WW",
                                   "CC" = "CC",
                                   "BxB" = "CC"))
}

newdat_size_reef <- recode_cross(newdat_size_reef)
newdat.reef      <- recode_cross(newdat.reef)
newdat2_subset   <- recode_cross(newdat2_subset)
emm_df           <- recode_cross(emm_df)
newdat_perc      <- recode_cross(newdat_perc)

# Combine all traits
big_heatmap_df <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

# Make sure the factor levels are consistent and ordered
big_heatmap_df$Cross_2 <- factor(big_heatmap_df$Cross_2, levels = c("CC", "WW"))

# Then plot
ggplot(big_heatmap_df, aes(x = Treatment, y = Cross_2, fill = mean_control)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined_control), color = "black", size = 3) +
  facet_grid(Trait ~ SymbiontTreatment) +
  scale_fill_gradient2(
    name = "Predicted Value",
    low = "blue",
    mid = "white",
    high = "red",
    midpoint = 0
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Predicted Trait Responses by Treatment and Symbiont",
    x = "Treatment", y = "Cross"
  )

```

Log transformed big heatmap
```{r}
signed_log <- function(x) {
  sign(x) * log1p(abs(x))
}

newdat.reef$mean_control_sign <- signed_log(newdat.reef$mean_control)
newdat_size_reef$mean_control_sign <- signed_log(newdat_size_reef$mean_control)
newdat2_subset$mean_control_sign <- signed_log(newdat2_subset$mean_control)  # Cell density, all positive 
newdat_perc$mean_control_sign <- signed_log(newdat_perc$mean_control) 
emm_df$mean_control_sign <- (emm_df$mean_control) #left as is (survival log-odds)

big_heatmap_df_log <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

# Combine Treatment and SymbiontTreatment into one factor for the x-axis ordering
big_heatmap_df_log <- big_heatmap_df_log %>%
  mutate(
    Treatment_Symbiont = factor(paste(Treatment, SymbiontTreatment, sep = "_"),
                                levels = c(
                                  "Ambient_C", "Ambient_D",
                                  "31_C", "31_D",
                                  "35.5_C", "35.5_D"
                                ))
  )

# Round to 2 decimals and combine with significance
#big_heatmap_df_log <- big_heatmap_df_log %>%
#  mutate(
#label_combined_global2 = ifelse(
#      is.na(mean_global),
#      "",  # leave blank for missing cells
#      paste0(round(mean_global, 0), "\n", signif_label_global)
#    )
#  )

# Compute 5th and 95th percentile of mean_control across the whole dataset
lims <- quantile(big_heatmap_df_log$mean_control, probs = c(0.05, 0.95), na.rm = TRUE)

mega_heatmap <- ggplot(big_heatmap_df_log, aes(x = Treatment_Symbiont, y = Cross_2, fill = mean_control_sign)) +
  geom_tile(color = "black") +
  geom_text(aes(label = label_combined_control), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0 ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Predicted Trait Responses by Treatment and Symbiont",
    x = "Treatment and Symbiont",
    y = "Family"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

mega_heatmap

#ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap.png", plot = mega_heatmap, width = 7, height = 5, dpi = 300)

library(dplyr)

# Normalize within each Trait
# Define the controls
big_heatmap_df_log_scaled <- big_heatmap_df_log %>%
  mutate(scaled_mean = scale(mean_control_sign)) %>%
  mutate(significant = str_detect(label_combined_control, "\\*+")) %>%
  mutate(scaled_mean_sig = ifelse(significant, mean_control_sign, NA)) %>%
  mutate(label_sig = ifelse(significant, label_combined_control, NA)) %>%
  # Force control cells to always be 0 with no stars
  mutate(
    label_combined_control = ifelse(
      Treatment == "Ambient" & Cross_2 == "CC" & SymbiontTreatment == "C",
      "0",
      label_combined_control
    ),
    scaled_mean = ifelse(
      Treatment == "Ambient" & Cross_2 == "CC" & SymbiontTreatment == "C",
      0,
      scaled_mean
    ),
    scaled_mean_sig = ifelse(
      Treatment == "Ambient" & Cross_2 == "CC" & SymbiontTreatment == "C",
      0,
      scaled_mean_sig
    )
  )


mega_heatmap_sig <- ggplot(big_heatmap_df_log_scaled, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = scaled_mean_sig), color = "black") +
  geom_text(aes(label = label_combined_control), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd", mid = "white", high = "red", midpoint = 0,
    na.value = "white"
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses by Treatment and Symbiont",
    x = "Temperature",
    y = "Population of Origin"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

mega_heatmap_sig

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap_control_contrast.png", plot = mega_heatmap_sig, width = 7, height = 5, dpi = 300)

write.csv(
  big_heatmap_df_log,
  "C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/big_heatmap_df_log.csv",
  row.names = FALSE
)

big_heatmap_df_log_scaled2 <- big_heatmap_df_log %>%
  # Identify significance
  mutate(
    sig_stars = ifelse(Trait == "Survival", signif_label, signif_label_control),
    significant = str_detect(sig_stars, "\\*")  # TRUE if * or **
  ) %>%
  # Only significant cells get colored using the original fold-change
  mutate(fold_change_color = ifelse(significant, mean_control_sign, NA)) %>%
  # Round fold change and append significance stars for all cells
  mutate(
    rounded_value = round(mean_control_sign, 2),
    label_fc = paste0(rounded_value, sig_stars)
  ) %>%
  # Force control cells to 0 with no stars
  mutate(
    label_fc = ifelse(
      Treatment == "Ambient" & Cross_2 == "CC" & SymbiontTreatment == "C",
      "0",
      label_fc
    ),
    fold_change_color = ifelse(
      Treatment == "Ambient" & Cross_2 == "CC" & SymbiontTreatment == "C",
      0,
      fold_change_color
    )
  )



mega_heatmap_sig_values <- ggplot(big_heatmap_df_log_scaled2, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = fold_change_color), color = "black") +
  geom_text(aes(label = label_fc), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0,
    na.value = "white"
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses by Treatment and Symbiont",
    x = "Temperature",
    y = "Population of Origin"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

mega_heatmap_sig_values

ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/heatmap.png", plot = mega_heatmap_sig_values, width = 6, height = 8, dpi = 300)


big_heatmap_sig_only <- big_heatmap_df_log_scaled2 %>%
  # Create a label that only shows * or ** for significant cells
  mutate(
    label_stars_only = ifelse(significant, sig_stars, "")
  )

# Set Trait as a factor with desired order
big_heatmap_sig_only <- big_heatmap_sig_only %>%
  mutate(Trait = factor(Trait, levels = c(
    "Survival",
    "Cell Density",
    "Acquisition",
    "Fv/Fm",
    "Larval Size"
  )))


heatmap_stars<- ggplot(big_heatmap_sig_only, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = fold_change_color), color = "black") +  # keep coloring for significant cells
  geom_text(aes(label = label_stars_only), color = "black", size = 4) +  # only stars inside cells
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0,
    na.value = "white"  # non-significant cells stay white
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses (Stars Only)",
    x = "Temperature",
    y = "Population of Origin"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/heatmap_stars.png", plot = heatmap_stars, width = 5, height = 5, dpi = 300)
```
### FINAL HEAT MAP
```{r}
# Store original (untransformed) means before transformation
newdat.reef$raw_mean <- newdat.reef$mean_global
newdat_size_reef$raw_mean <- newdat_size_reef$mean_global
newdat2_subset$raw_mean <- newdat2_subset$mean_global
newdat_perc$raw_mean <- newdat_perc$mean_global

# Now apply signed log to mean_global for coloring
newdat.reef$mean_global <- signed_log(newdat.reef$mean_global)
newdat_size_reef$mean_global <- signed_log(newdat_size_reef$mean_global)
newdat2_subset$mean_global <- signed_log(newdat2_subset$mean_global)
newdat_perc$mean_global <- signed_log(newdat_perc$mean_global)

big_heatmap_df_log2 <- bind_rows(newdat_size_reef, newdat.reef, newdat2_subset, emm_df, newdat_perc)

# Create a new column where only significant cells retain their mean value
big_heatmap_df_log2 <- big_heatmap_df_log2 %>%
  mutate(
    significant = str_detect(label_combined_global, "\\*+"),
    scaled_mean_sig = ifelse(significant, mean_global, NA),
    # Show label in ALL cells regardless of significance
    label_sig = label_combined_global  # <- Don't NA-out nonsignificant cells
  )


# Combine Treatment and SymbiontTreatment into one factor for the x-axis ordering
big_heatmap_df_sigonly <- big_heatmap_df_log2 %>%
  mutate(
    Treatment_Symbiont = factor(paste(Treatment, SymbiontTreatment, sep = "_"),
                                levels = c(
                                  "Ambient_C", "Ambient_D",
                                  "31_C", "31_D",
                                  "35.5_C", "35.5_D"
                                ))
  )


# Plot: only significant cells are colored, others are white
mega_heatmap_sigonly <- ggplot(big_heatmap_df_sigonly, aes(x = Treatment_Symbiont, y = Cross_2)) +
  geom_tile(aes(fill = scaled_mean_sig), color = "black") +
  geom_text(aes(label = label_sig), color = "black", size = 3) +
  facet_grid(Trait ~ .) +
  scale_fill_gradient2(
    name = "Fold Change",
    low = "#3288bd",
    mid = "white",
    high = "red",
    midpoint = 0,
    na.value = "white"  # non-significant cells will be white
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Significant Trait Responses by Treatment and Symbiont",
    x = "Treatment and Symbiont",
    y = "Family"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

mega_heatmap_sigonly

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/mega_heatmap_global_mean_FINAL.png", plot = mega_heatmap_sigonly, width = 7, height = 5, dpi = 300)
```
## Fv/Fm: Exploratory Box Plot
```{r}
library(ggplot2)

ggplot(df_with_extremes, aes(x = interaction(Treatment, Cross_2, SymbiontTreatment), 
                             y = FvFmfinal, 
                             fill = SymbiontTreatment)) +
  geom_boxplot() +
  labs(x = "Treatment x Cross x Symbiont", y = "Final Fv/Fm", 
       title = "Final Fv/Fm by Treatment, Cross, and Symbiont") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


ggplot(df_with_extremes, aes(x = interaction(Treatment, Cross_2, SymbiontTreatment), 
                             y = FvFminitial, 
                             fill = SymbiontTreatment)) +
  geom_boxplot() +
  labs(x = "Treatment x Cross x Symbiont", y = "Final Fv/Fm", 
       title = "Initial Fv/Fm by Treatment, Cross, and Symbiont") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

Survivors Only: Fv/Fm
```{r}
#Fv/Fm #################################################### 
library(MCMCglmm)
library(dplyr)

#subset to survivors
subset_df <- df_with_extremes %>%
  filter(Timepoint == 22, Percent_Survival_atend > 0)

# Set factor levels
subset_df <- subset_df %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
subset_df$Treatment <- factor(subset_df$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df$Cross_2 <- factor(subset_df$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df$SymbiontTreatment <- factor(subset_df$SymbiontTreatment, 
                                     levels = c("C", "D"))

subset_df <- subset_df %>% filter(Treatment != "35.5")
subset_df$Treatment <- droplevels(subset_df$Treatment)

subset_df$logPercChange <- log(subset_df$PercChange + 101)  # shift so all values are > 0

#Set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)


# Fit the model
model3.reef <- MCMCglmm(RawChangeFvFm ~ SymbiontTreatment * Cross_2 * Treatment, 
                        random = ~ Replicate, 
                        data = subset_df, 
                        family = "gaussian",  
                        prior = prior,
                        nitt = 50000, burnin = 10000, thin = 20)

solution_summary <- summary(model3.reef)$solutions
pmcmc_values <- solution_summary[, "pMCMC"]

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model3.reef$Sol)
plot(mcmc_obj)  # Trace and density plots
plot(model3.reef$VCV)
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# Create prediction grid
newdat.reef <- expand.grid(
  SymbiontTreatment = levels(subset_df$SymbiontTreatment),
  Cross_2 = levels(subset_df$Cross_2),
  Treatment = levels(subset_df$Treatment)
)

# Ensure factor levels match
newdat.reef <- newdat.reef %>%
  mutate(across(everything(), ~ factor(.x, levels = levels(subset_df[[cur_column()]]))))

# Generate design matrix
# Model matrix for prediction rows
X_full <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat.reef)
X <- X_full[, names(pmcmc_values), drop = FALSE]  # Make sure columns match

# For each prediction, calculate a "pMCMC-equivalent" value
# This is done by testing whether the *linear combination of coefficients* differs from 0
# using the posterior distribution (model3.reef$Sol)

posterior_preds <- X %*% t(model3.reef$Sol)

newdat.reef$pred_mean <- rowMeans(posterior_preds)
newdat.reef$lower <- apply(posterior_preds, 1, quantile, probs = 0.025)
newdat.reef$upper <- apply(posterior_preds, 1, quantile, probs = 0.975)

# Calculate pMCMC: proportion of posterior samples less than 0 or greater than 0
newdat.reef$pMCMC <- apply(posterior_preds, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# Determine significance at alpha = 0.05
newdat.reef$significant <- newdat.reef$pMCMC < 0.05


# Create label
newdat.reef$label_combined <- paste0(
  round(as.numeric(as.character(newdat.reef$pred_mean)), 1),
  ifelse(newdat.reef$significant, "*", "")
)

# Make sure pred_mean is numeric for fill
newdat.reef$pred_mean <- as.numeric(as.character(newdat.reef$pred_mean))

# Plot predicted means
ggplot(newdat.reef, aes(x = Treatment, y = Cross_2, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted Change") +
  theme_minimal() +
  labs(title = "Predicted Percent Change in Fv/Fm with pMCMC Significance",
       x = "Temperature", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChange ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- RawChangeFvFm ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
model_treatment <- MCMCglmm(
  fixed = RawChangeFvFm ~ Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_symbiont <- MCMCglmm(
  fixed = RawChangeFvFm ~ SymbiontTreatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

model_cross2 <- MCMCglmm(
  fixed = RawChangeFvFm ~ Cross_2,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_R2(model_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_R2(model_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(model_cross2, subset_df, PercChange ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = RawChangeFvFm ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_conditional_R2(model_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(model_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(model_cross2, subset_df, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),
  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  )
)

print(results_df)

results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

##########
# Pairwise comparisons
##########
# Create new data frame of combinations
newdat <- expand.grid(
  SymbiontTreatment = levels(subset_df$SymbiontTreatment),
  Cross_2 = levels(subset_df$Cross_2),
  Treatment = levels(subset_df$Treatment)
)

# Ensure same factor levels as in model
newdat$SymbiontTreatment <- factor(newdat$SymbiontTreatment, levels = levels(subset_df$SymbiontTreatment))
newdat$Cross_2 <- factor(newdat$Cross_2, levels = levels(subset_df$Cross_2))
newdat$Treatment <- factor(newdat$Treatment, levels = levels(subset_df$Treatment))

# For clarity in output
newdat$group <- with(newdat, paste(SymbiontTreatment, Cross_2, Treatment, sep = "_"))

# Design matrix must match the fixed effects structure in the full model
X <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat)

# Match columns exactly
X <- X[, colnames(model3.reef$Sol), drop = FALSE]

# Get posterior predictions
pred_matrix <- X %*% t(model3.reef$Sol)

# All pairwise group combinations
group_combos <- combn(1:nrow(newdat), 2, simplify = FALSE)

# Compute posterior difference, 95% CI, and pMCMC
pairwise_results <- lapply(group_combos, function(idx) {
  i <- idx[1]
  j <- idx[2]
  diff <- pred_matrix[i, ] - pred_matrix[j, ]
  ci <- quantile(diff, probs = c(0.025, 0.975))
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  
  data.frame(
    group1 = newdat$group[i],
    group2 = newdat$group[j],
    mean_diff = mean(diff),
    lower = ci[1],
    upper = ci[2],
    pMCMC = pMCMC,
    significant = ci[1] > 0 | ci[2] < 0
  )
})

pairwise_df <- do.call(rbind, pairwise_results)

ggplot(pairwise_df, aes(group1, group2, fill = mean_diff)) +
  geom_tile() +
  geom_text(aes(label = ifelse(significant, "*", "")), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Pairwise Differences in log(Cell Density Change)",
       x = "Group 1", y = "Group 2")

# Add back-transformed columns and format them nicely
pairwise_summary <- pairwise_df %>%
  mutate(
    mean_diff_bt = exp(mean_diff) - 1,
    lower_bt = exp(lower) - 1,
    upper_bt = exp(upper) - 1,
    mean_diff_bt_fmt = formatC(mean_diff_bt, format = "e", digits = 2),
    lower_bt_fmt = formatC(lower_bt, format = "e", digits = 2),
    upper_bt_fmt = formatC(upper_bt, format = "e", digits = 2),
    significant_label = ifelse(significant, "*", "")
  ) %>%
  select(
    group1, group2,
    mean_diff, lower, upper,
    mean_diff_bt_fmt, lower_bt_fmt, upper_bt_fmt,
    pMCMC, significant_label
  ) %>%
  rename(
    `Group 1` = group1,
    `Group 2` = group2,
    `Mean Diff (log)` = mean_diff,
    `Lower 95% CI (log)` = lower,
    `Upper 95% CI (log)` = upper,
    `Mean Diff (back-transformed)` = mean_diff_bt_fmt,
    `Lower 95% CI (back-transformed)` = lower_bt_fmt,
    `Upper 95% CI (back-transformed)` = upper_bt_fmt,
    `pMCMC` = pMCMC,
    `Significant` = significant_label
  )

write.csv(pairwise_summary, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/pairwise_summary_table_fvfm_raw.csv", row.names = FALSE)

###############################################################
# Now with just Treatment and Cross
# Fit the model
model_tc <- MCMCglmm(
  RawChangeFvFm ~ Treatment * Cross_2,
  random = ~ Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# New data grid for predictions
newdat_tc <- expand.grid(
  Treatment = levels(subset_df$Treatment),
  Cross_2 = levels(subset_df$Cross_2)
)

newdat_tc$Treatment <- factor(newdat_tc$Treatment, levels = levels(subset_df$Treatment))
newdat_tc$Cross_2 <- factor(newdat_tc$Cross_2, levels = levels(subset_df$Cross_2))

# Model matrix for fixed effects (match model columns)
X_tc <- model.matrix(~ Treatment * Cross_2, data = newdat_tc)

# Subset posterior samples for fixed effects
Sol_tc <- model_tc$Sol[, colnames(X_tc), drop = FALSE]

# Calculate predicted values per MCMC iteration
pred_mat_tc <- X_tc %*% t(Sol_tc)  # rows = groups, cols = MCMC samples

# Calculate pairwise differences for all combinations
pairwise_diff_tc <- combn(nrow(newdat_tc), 2, function(i) {
  diff_samples <- pred_mat_tc[i[1], ] - pred_mat_tc[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_tc$Treatment[i[1]]), as.character(newdat_tc$Cross_2[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_tc$Treatment[i[2]]), as.character(newdat_tc$Cross_2[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

# Add significance flag
pairwise_diff_tc <- pairwise_diff_tc %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_tc)

###############################################################
# Now with just Treatment and SymbiontTreatment
model_ts <- MCMCglmm(
  RawChangeFvFm ~ Treatment * SymbiontTreatment,
  random = ~ Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

newdat_ts <- expand.grid(
  Treatment = levels(subset_df$Treatment),
  SymbiontTreatment = levels(subset_df$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(subset_df$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(subset_df$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
Sol_ts <- model_ts$Sol[, colnames(X_ts), drop = FALSE]
pred_mat_ts <- X_ts %*% t(Sol_ts)

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)

# ---- Variance Partitioning between SymbiontTreatment, Cross_2, and Treatment ----

# Load packages
library(vegan)
library(dplyr)
library(ggplot2)

# ---- Step 1: Define predictors and response ----
Y <- subset_df$RawChangeFvFm
# SymbiontTreatment, Cross_2, Treatment are factors in your df

# ---- Step 2: Variance partitioning ----
varpart_result <- varpart(Y, ~SymbiontTreatment, ~Cross_2, ~Treatment, data = subset_df)

# Get adjusted R² fractions
fractions <- varpart_result$part$indfract$Adj.R.square
fractions[fractions < 0] <- 0  # truncate negatives

# ---- Step 3: RDA + permutation tests for unique fractions ----
# Unique Symbiont
rda_X1 <- rda(subset_df$RawChangeFvFm ~ SymbiontTreatment + Condition(Cross_2 + Treatment), 
              data = subset_df)
anova_X1 <- anova(rda_X1, permutations = 999)

# Unique Cross
rda_X2 <- rda(subset_df$RawChangeFvFm ~ Cross_2 + Condition(SymbiontTreatment + Treatment), data = subset_df)
anova_X2 <- anova(rda_X2, permutations = 999)

# Unique Treatment
rda_X3 <- rda(subset_df$RawChangeFvFm ~ Treatment + Condition(SymbiontTreatment + Cross_2), data = subset_df)
anova_X3 <- anova(rda_X3, permutations = 999)

# ---- Step 4: Compile table for manuscript ----
varpart_table <- data.frame(
  Component = c("Unique Symbiont", "Unique Cross", "Unique Treatment", 
                "Shared Symbiont/Cross", "Shared Symbiont/Treatment", 
                "Shared Cross/Treatment", "Shared All", "Residual"),
  Adj_R2 = c(fractions[1], fractions[2], fractions[3], 
             fractions[4], fractions[5], fractions[6], fractions[7], fractions[8]),
  F_stat = c(anova_X1$F[1], anova_X2$F[1], anova_X3$F[1], NA, NA, NA, NA, NA),
  df_num = c(anova_X1$Df[1], anova_X2$Df[1], anova_X3$Df[1], NA, NA, NA, NA, NA),
  df_den = c(anova_X1$Df[2], anova_X2$Df[2], anova_X3$Df[2], NA, NA, NA, NA, NA),
  p_value = c(anova_X1$`Pr(>F)`[1], anova_X2$`Pr(>F)`[1], anova_X3$`Pr(>F)`[1], NA, NA, NA, NA, NA),
  n = nrow(subset_df)
)

# View the table
varpart_table

# ---- Step 5: Optional Venn diagram ----
plot(varpart_result, bg = c("red", "blue", "green"), 
     Xnames = c("Symbiont", "Cross", "Treatment"))

# ---- Step 6: Optional ggplot barplot ----
varpart_df <- varpart_table %>%
  select(Component, Adj_R2)

ggplot(varpart_df, aes(x = Component, y = Adj_R2, fill = Component)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = sprintf("%.3f", Adj_R2)), vjust = -0.5, size = 3) +
  theme_minimal(base_size = 14) +
  ylab("Proportion of variance explained (adjusted R²)") +
  xlab("") +
  ggtitle("Variance Partitioning: Symbiont vs Cross vs Treatment") +
  theme(legend.position = "none")

# Save Venn diagram as PNG
   # Just hover over the plot and right click to save image

ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/FvFm_SURVIVORS_VariancePartition_Barplot.png", plot = p, width = 10, height = 6, dpi = 300)

write.csv(varpart_table, 
          file = "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/FvFm_SURVIVORS_varpart_table.csv",
          row.names = FALSE)

```
Cell Density and Survival
```{r}
#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

#subset to survivors
subset_df_cells <- df_subset %>%
  filter(Timepoint == 22, Percent_Survival_atend > 0)

# Set factor levels
subset_df_cells <- subset_df_cells %>%
  mutate(across(c(Cross_2, Treatment, SymbiontTreatment, Timepoint, Replicate), factor))

# Ensure factors are ordered
subset_df_cells$Treatment <- factor(subset_df_cells$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df_cells$Cross_2 <- factor(subset_df_cells$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df_cells$SymbiontTreatment <- factor(subset_df_cells$SymbiontTreatment, 
                                     levels = c("C", "D"))

subset_df_cells <- subset_df_cells %>% 
  filter(Treatment != "35.5") %>%
  droplevels()


# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
prior <- list(
  R = list(V = 1, nu = 1),
  G = list(G1 = list(V = 1, nu = 1))
)

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_full)

# Fit single fixed effect models
mod_cells_treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = subset_df_cells, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_cells_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = subset_df_cells, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_cells_family <- MCMCglmm(PercChangeCells ~ Cross_2, 
                       random = ~ Replicate , 
                       data = subset_df_cells, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df_cells, full_formula)
r2_treatment <- calc_marginal_R2(mod_cells_treatment, subset_df_cells, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_cells_symbiont, subset_df_cells, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_cells_family, subset_df_cells, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeCells ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df_cells, PercChangeCells ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df_cells, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_cells_treatment, subset_df_cells, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_cells_symbiont, subset_df_cells, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_cells_family, subset_df_cells, PercChangeCells ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

##########
# Pairwise comparisons
##########
subset_df_cells$sign_log_PercChangeCells <- sign(subset_df_cells$PercChangeCells) * 
                                            log1p(abs(subset_df_cells$PercChangeCells))

model_full <- MCMCglmm(
  sign_log_PercChangeCells ~ SymbiontTreatment * Cross_2 * Treatment,
  random = ~ Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Create new data frame of combinations
newdat <- expand.grid(
  SymbiontTreatment = levels(subset_df_cells$SymbiontTreatment),
  Cross_2 = levels(subset_df_cells$Cross_2),
  Treatment = levels(subset_df_cells$Treatment)
)

# Ensure same factor levels as in model
newdat$SymbiontTreatment <- factor(newdat$SymbiontTreatment, levels = levels(subset_df_cells$SymbiontTreatment))
newdat$Cross_2 <- factor(newdat$Cross_2, levels = levels(subset_df_cells$Cross_2))
newdat$Treatment <- factor(newdat$Treatment, levels = levels(subset_df_cells$Treatment))

# For clarity in output
newdat$group <- with(newdat, paste(SymbiontTreatment, Cross_2, Treatment, sep = "_"))

# Design matrix must match the fixed effects structure in the full model
X <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat)

# Match columns exactly
X <- X[, colnames(model_full$Sol), drop = FALSE]

# Get posterior predictions
pred_matrix <- X %*% t(model_full$Sol)

# All pairwise group combinations
group_combos <- combn(1:nrow(newdat), 2, simplify = FALSE)

# Compute posterior difference, 95% CI, and pMCMC
pairwise_results <- lapply(group_combos, function(idx) {
  i <- idx[1]
  j <- idx[2]
  diff <- pred_matrix[i, ] - pred_matrix[j, ]
  ci <- quantile(diff, probs = c(0.025, 0.975))
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  
  data.frame(
    group1 = newdat$group[i],
    group2 = newdat$group[j],
    mean_diff = mean(diff),
    lower = ci[1],
    upper = ci[2],
    pMCMC = pMCMC,
    significant = ci[1] > 0 | ci[2] < 0
  )
})

pairwise_df <- do.call(rbind, pairwise_results)

ggplot(pairwise_df, aes(group1, group2, fill = mean_diff)) +
  geom_tile() +
  geom_text(aes(label = ifelse(significant, "*", "")), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Pairwise Differences in log(Cell Density Change)",
       x = "Group 1", y = "Group 2")

# Add back-transformed columns and format them nicely
pairwise_summary <- pairwise_df %>%
  mutate(
    mean_diff_bt = sign(mean_diff) * (exp(abs(mean_diff)) - 1),
    lower_bt = exp(lower) - 1,
    upper_bt = exp(upper) - 1,
    mean_diff_bt_fmt = formatC(mean_diff_bt, format = "e", digits = 2),
    lower_bt_fmt = formatC(lower_bt, format = "e", digits = 2),
    upper_bt_fmt = formatC(upper_bt, format = "e", digits = 2),
    significant_label = ifelse(significant, "*", "")
  ) %>%
  select(
    group1, group2,
    mean_diff, lower, upper,
    mean_diff_bt_fmt, lower_bt_fmt, upper_bt_fmt,
    pMCMC, significant_label
  ) %>%
  rename(
    `Group 1` = group1,
    `Group 2` = group2,
    `Mean Diff (log)` = mean_diff,
    `Lower 95% CI (log)` = lower,
    `Upper 95% CI (log)` = upper,
    `Mean Diff (back-transformed)` = mean_diff_bt_fmt,
    `Lower 95% CI (back-transformed)` = lower_bt_fmt,
    `Upper 95% CI (back-transformed)` = upper_bt_fmt,
    `pMCMC` = pMCMC,
    `Significant` = significant_label
  )

write.csv(pairwise_summary, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/pairwise_summary_table_celldensity.csv", row.names = FALSE)

###############################################################
# Now with just Treatment and Cross

# Fit the model
model_tc <- MCMCglmm(
  sign_log_PercChangeCells ~ Treatment * Cross_2,
  random = ~ Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# New data grid for predictions
newdat_tc <- expand.grid(
  Treatment = levels(subset_df_cells$Treatment),
  Cross_2 = levels(subset_df_cells$Cross_2)
)

newdat_tc$Treatment <- factor(newdat_tc$Treatment, levels = levels(subset_df_cells$Treatment))
newdat_tc$Cross_2 <- factor(newdat_tc$Cross_2, levels = levels(subset_df_cells$Cross_2))

# Model matrix for fixed effects (match model columns)
X_tc <- model.matrix(~ Treatment * Cross_2, data = newdat_tc)

# Subset posterior samples for fixed effects
Sol_tc <- model_tc$Sol[, colnames(X_tc), drop = FALSE]

# Calculate predicted values per MCMC iteration
pred_mat_tc <- X_tc %*% t(Sol_tc)  # rows = groups, cols = MCMC samples

# Calculate pairwise differences for all combinations
pairwise_diff_tc <- combn(nrow(newdat_tc), 2, function(i) {
  diff_samples <- pred_mat_tc[i[1], ] - pred_mat_tc[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_tc$Treatment[i[1]]), as.character(newdat_tc$Cross_2[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_tc$Treatment[i[2]]), as.character(newdat_tc$Cross_2[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

# Add significance flag
pairwise_diff_tc <- pairwise_diff_tc %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_tc)

###############################################################
# Now with just Treatment and SymbiontTreatment
model_ts <- MCMCglmm(
  sign_log_PercChangeCells ~ Treatment * SymbiontTreatment,
  random = ~ Replicate,
  data = subset_df_cells,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

newdat_ts <- expand.grid(
  Treatment = levels(subset_df_cells$Treatment),
  SymbiontTreatment = levels(subset_df_cells$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(subset_df_cells$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(subset_df_cells$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
Sol_ts <- model_ts$Sol[, colnames(X_ts), drop = FALSE]
pred_mat_ts <- X_ts %*% t(Sol_ts)

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()


pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)

save.image(file = "my_workspace_15_07_2025.RData")
```
Larval Size with Survivors only
```{r}
#Larval Size #####################################

# Ensure factors are ordered
subset_df$Treatment <- factor(subset_df$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
subset_df$Cross_2 <- factor(subset_df$Cross_2, 
                                     levels = c("BxB", "TxT"))
subset_df$SymbiontTreatment <- factor(subset_df$SymbiontTreatment, 
                                     levels = c("C", "D"))

subset_df <- subset_df %>% 
  filter(Treatment != "35.5") %>%
  droplevels()

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment

# Fit the full model
model_full <- MCMCglmm(
  fixed = full_formula,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_full)

# Fit single fixed effect models
mod_size_treatment <- MCMCglmm(PercChangeSize ~ Treatment, 
                          random = ~ Replicate , 
                          data = subset_df, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_size_symbiont <- MCMCglmm(PercChangeSize ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = subset_df, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_size_family <- MCMCglmm(PercChangeSize ~ Cross_2, 
                       random = ~ Replicate , 
                       data = subset_df, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_R2(mod_size_treatment, subset_df, PercChangeSize ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_size_symbiont, subset_df, PercChangeSize ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_size_family, subset_df, PercChangeSize ~ Cross_2)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross_2 only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Example: model with SymbiontTreatment:Treatment interaction only
model_interaction <- MCMCglmm(
  fixed = PercChangeSize ~ SymbiontTreatment:Treatment,
  random = ~Replicate,
  data = subset_df,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

r2_interaction <- calc_marginal_conditional_R2(model_interaction, subset_df, PercChange ~ SymbiontTreatment:Treatment)
print(r2_interaction)

library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, subset_df, full_formula)
r2_treatment <- calc_marginal_conditional_R2(mod_size_treatment, subset_df, PercChange ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_size_symbiont, subset_df, PercChange ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_size_family, subset_df, PercChange ~ Cross_2)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_interaction) <- c("mean", "lower", "upper")
colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")


# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross_2", "Interaction"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"],
    r2_interaction["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"],
    r2_interaction["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"],
    r2_interaction["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"],
    r2_interaction["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"],
    r2_interaction["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"],
    r2_interaction["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

##########
# Pairwise comparisons for survivors (Percent Change)
##########

# Step 1: Identify larvae that survived at Timepoint 22
survivors <- subset_df %>%
  filter(Timepoint == 22 & Status == 0) %>%
  pull(UniqueID)

# Step 2: Subset the full dataset to only include those larvae
subset_survived_to_22 <- subset_df %>%
  filter(UniqueID %in% survivors)

model_log <- MCMCglmm(
  fixed = PercChangeSize ~ SymbiontTreatment * Cross_2 * Treatment,
  random = ~Replicate,
  data = subset_survived_to_22,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Create new data frame of combinations
newdat <- expand.grid(
  SymbiontTreatment = levels(subset_survived_to_22$SymbiontTreatment),
  Cross_2 = levels(subset_survived_to_22$Cross_2),
  Treatment = levels(subset_survived_to_22$Treatment)
)

# Ensure same factor levels as in model
newdat$SymbiontTreatment <- factor(newdat$SymbiontTreatment, levels = levels(subset_survived_to_22$SymbiontTreatment))
newdat$Cross_2 <- factor(newdat$Cross_2, levels = levels(subset_survived_to_22$Cross_2))
newdat$Treatment <- factor(newdat$Treatment, levels = levels(subset_survived_to_22$Treatment))

# For clarity in output
newdat$group <- with(newdat, paste(SymbiontTreatment, Cross_2, Treatment, sep = "_"))

# Design matrix must match the fixed effects structure in the full model
X <- model.matrix(~ SymbiontTreatment * Cross_2 * Treatment, data = newdat)

# Match columns exactly
X <- X[, colnames(model_log$Sol), drop = FALSE]

# Get posterior predictions
pred_matrix <- X %*% t(model_log$Sol)

# All pairwise group combinations
group_combos <- combn(1:nrow(newdat), 2, simplify = FALSE)

# Compute posterior difference, 95% CI, and pMCMC
pairwise_results <- lapply(group_combos, function(idx) {
  i <- idx[1]
  j <- idx[2]
  diff <- pred_matrix[i, ] - pred_matrix[j, ]
  ci <- quantile(diff, probs = c(0.025, 0.975))
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  
  data.frame(
    group1 = newdat$group[i],
    group2 = newdat$group[j],
    mean_diff = mean(diff),
    lower = ci[1],
    upper = ci[2],
    pMCMC = pMCMC,
    significant = ci[1] > 0 | ci[2] < 0
  )
})

pairwise_df <- do.call(rbind, pairwise_results)

ggplot(pairwise_df, aes(group1, group2, fill = mean_diff)) +
  geom_tile() +
  geom_text(aes(label = ifelse(significant, "*", "")), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Pairwise Differences in log(Cell Density Change)",
       x = "Group 1", y = "Group 2")

# Add back-transformed columns and format them nicely
pairwise_summary <- pairwise_df %>%
  mutate(
    mean_diff_bt = exp(mean_diff) - 1,
    lower_bt = exp(lower) - 1,
    upper_bt = exp(upper) - 1,
    mean_diff_bt_fmt = formatC(mean_diff_bt, format = "e", digits = 2),
    lower_bt_fmt = formatC(lower_bt, format = "e", digits = 2),
    upper_bt_fmt = formatC(upper_bt, format = "e", digits = 2),
    significant_label = ifelse(significant, "*", "")
  ) %>%
  select(
    group1, group2,
    mean_diff, lower, upper,
    mean_diff_bt_fmt, lower_bt_fmt, upper_bt_fmt,
    pMCMC, significant_label
  ) %>%
  rename(
    `Group 1` = group1,
    `Group 2` = group2,
    `Mean Diff (log)` = mean_diff,
    `Lower 95% CI (log)` = lower,
    `Upper 95% CI (log)` = upper,
    `Mean Diff (back-transformed)` = mean_diff_bt_fmt,
    `Lower 95% CI (back-transformed)` = lower_bt_fmt,
    `Upper 95% CI (back-transformed)` = upper_bt_fmt,
    `pMCMC` = pMCMC,
    `Significant` = significant_label
  )

write.csv(pairwise_summary, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/pairwise_summary_table_size_raw.csv", row.names = FALSE)

###############################################################
# Now with just Treatment and Cross

# Fit the model
model_tc <- MCMCglmm(
  PercChangeSize ~ Treatment * Cross_2,
  random = ~ Replicate,
  data = subset_survived_to_22,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# New data grid for predictions
newdat_tc <- expand.grid(
  Treatment = levels(subset_survived_to_22$Treatment),
  Cross_2 = levels(subset_survived_to_22$Cross_2)
)

newdat_tc$Treatment <- factor(newdat_tc$Treatment, levels = levels(subset_survived_to_22$Treatment))
newdat_tc$Cross_2 <- factor(newdat_tc$Cross_2, levels = levels(subset_survived_to_22$Cross_2))

# Model matrix for fixed effects (match model columns)
X_tc <- model.matrix(~ Treatment * Cross_2, data = newdat_tc)

# Subset posterior samples for fixed effects
Sol_tc <- model_tc$Sol[, colnames(X_tc), drop = FALSE]

# Calculate predicted values per MCMC iteration
pred_mat_tc <- X_tc %*% t(Sol_tc)  # rows = groups, cols = MCMC samples

# Calculate pairwise differences for all combinations
pairwise_diff_tc <- combn(nrow(newdat_tc), 2, function(i) {
  diff_samples <- pred_mat_tc[i[1], ] - pred_mat_tc[i[2], ]
  data.frame(
    group1 = paste(newdat_tc[i[1], ], collapse = "_"),
    group2 = paste(newdat_tc[i[2], ], collapse = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

# Add significance flag
pairwise_diff_tc <- pairwise_diff_tc %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_tc)

###############################################################
# Now with just Treatment and SymbiontTreatment
model_ts <- MCMCglmm(
  PercChangeSize ~ Treatment * SymbiontTreatment,
  random = ~ Replicate,
  data = subset_survived_to_22,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

newdat_ts <- expand.grid(
  Treatment = levels(subset_survived_to_22$Treatment),
  SymbiontTreatment = levels(subset_survived_to_22$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(subset_survived_to_22$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(subset_survived_to_22$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
Sol_ts <- model_ts$Sol[, colnames(X_ts), drop = FALSE]
pred_mat_ts <- X_ts %*% t(Sol_ts)

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()


pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)


```

##Get temp data
```{r}
install.packages("rerddap")
library(rerddap)
library(httr)
library(readr)
library(utils)
library(dplyr)
library(lubridate)
library(ggplot2)
library(tidyr)

dataset_id <- "NOAA_DHW_monthly"

# Info object
sstInfo <- info(dataset_id)

# Define bounding box around Tantabiddi, ~0.02° (~2 km)
lat_range <- c(-21.95, -21.93)
lon_range <- c(113.95, 113.97)

# Date range (dataset starts 1985-01-16)
time_range <- c("1985-01-16", "2024-12-16")

# Grab SST variable ('sst' per dataset docs)
tantabiddi_sst <- griddap(sstInfo,
                          latitude = lat_range,
                          longitude = lon_range,
                          fields = "sea_surface_temperature")

# Brubdjoo coordinates ~ -23.63 S, 113.88 E
brubdjoo_sst <- griddap(sstInfo,
  latitude = c(-22.9744, -22.9244),
  longitude = c(113.7525, 113.8025),
  fields = "sea_surface_temperature"
)

tantabiddi_data <- tantabiddi_sst$data
bruboodjoo_data <- brubdjoo_sst$data

# Add a site column
tantabiddi_data <- tantabiddi_data %>% mutate(site = "Tantabiddi")
bruboodjoo_data  <- bruboodjoo_data  %>% mutate(site = "Bruboodjoo")

# Combine data
all_data <- bind_rows(tantabiddi_data, bruboodjoo_data)

# Convert time to Date
all_data <- all_data %>%
  mutate(time = as.Date(time))

# Extract year and month
all_data <- all_data %>%
  mutate(year = year(time),
         month = month(time, label = TRUE, abbr = TRUE))

# Average SST over lat/lon for each site x time
site_monthly <- all_data %>%
  group_by(site, time) %>%
  summarize(mean_sst = mean(sea_surface_temperature, na.rm = TRUE), .groups = "drop")

# Calculate mean monthly SST (averaged across years) for each site
mean_monthly <- site_monthly %>%
  mutate(month = month(time)) %>%
  group_by(site, month) %>%
  summarize(mean_sst = mean(mean_sst, na.rm = TRUE), .groups = "drop")

# Calculate mean annual SST for each site and year
mean_annual <- site_monthly %>%
  mutate(year = year(time)) %>%
  group_by(site, year) %>%
  summarize(mean_sst = mean(mean_sst, na.rm = TRUE), .groups = "drop")

ggplot(mean_monthly, aes(x = month, y = mean_sst, color = site, group = site)) +
  geom_line(size = 1.2) +
  geom_point() +
  labs(title = "Mean Monthly SST (1985–2024)",
       x = "Month",
       y = "SST (°C)",
       color = "Site") +
  theme_minimal()

# Add site column
tantabiddi <- tantabiddi_sst$data %>% mutate(site = "Tantabiddi")
bruboodjoo <- brubdjoo_sst$data %>% mutate(site = "Bruboodjoo")


# Define all_sst correctly for use in DHW and plotting
all_sst <- bind_rows(tantabiddi, bruboodjoo)

# Ensure time is Date format
all_sst <- all_sst %>%
  mutate(
    time = as.Date(time),
    year = year(time),
    month = month(time, label = TRUE, abbr = TRUE),
    month_num = month(time)
  )

monthly_per_year <- all_sst %>%
  group_by(site, year, month, month_num) %>%
  summarise(
    monthly_mean = mean(sea_surface_temperature, na.rm = TRUE),
    .groups = "drop"
  )

monthly_summary <- monthly_per_year %>%
  group_by(site, month, month_num) %>%
  summarise(
    mean_sst = mean(monthly_mean, na.rm = TRUE),
    sd_sst = sd(monthly_mean, na.rm = TRUE),
    se_sst = sd_sst / sqrt(n()),
    .groups = "drop"
  )

overall_mean_sst <- all_sst %>%
  group_by(site) %>%
  summarise(overall_mean = mean(sea_surface_temperature, na.rm = TRUE))


plot_monthly_sst <- ggplot(monthly_summary, aes(x = reorder(month, month_num), y = mean_sst, color = site, group = site)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean_sst - se_sst, ymax = mean_sst + se_sst), width = 0.2) +
  geom_hline(data = overall_mean_sst, aes(yintercept = overall_mean, color = site), linetype = "dashed") +
  scale_color_manual(
  values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")  
  )+ 
  labs(
    title = "Mean Monthly SST with Error Bars (1985–2025)",
    x = "Month",
    y = "SST (°C)",
    color = "Site"
  ) +
  theme_minimal()

#Annual mean plots
annual_means <- all_sst %>%
  mutate(year = lubridate::year(time)) %>%
  filter(year < 2025) %>%  # remove partial year
  group_by(site, year) %>%
  summarise(mean_annual_sst = mean(sea_surface_temperature, na.rm = TRUE), .groups = "drop")

plot_annual_sst <- ggplot(annual_means, aes(x = site, y = mean_annual_sst, fill = site)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  geom_jitter(width = 0.1, alpha = 0.4) +  # optional: show individual years
  geom_boxplot(width = 0.1, outlier.shape = NA, color = "black", fill = "white") +  # optional: summary inside violin
  scale_fill_manual(values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")) +
  labs(
    title = "Mean Annual SST (1985–2025)",
    x = "Site",
    y = "Mean Annual SST (°C)"
  ) +
  theme_minimal()

# Calculate MMM per site and year (max monthly mean SST for each year)
mmm_annual <- all_sst %>%
  filter(year(time) >= 2004 & year(time) <= 2024) %>%
  mutate(year = year(time), month = month(time)) %>%
  group_by(site, year, month) %>%
  summarise(monthly_mean = mean(sea_surface_temperature, na.rm = TRUE), .groups = "drop") %>%
  group_by(site, year) %>%
  summarise(mmm = max(monthly_mean, na.rm = TRUE), .groups = "drop")

sst_with_dhw <- all_sst %>%
  mutate(year = year(time)) %>%
  filter(year >= 2004 & year <= 2024) %>%
  left_join(mmm_annual, by = c("site", "year")) %>%
  arrange(site, time) %>%
  group_by(site) %>%
  mutate(
    hotspot = ifelse(sea_surface_temperature > (mmm + 1), sea_surface_temperature - mmm, 0),
    dhw = rollapply(hotspot, width = 84, FUN = function(x) sum(x) / 7, align = "right", fill = NA)
  ) %>%
  ungroup()


dhw_summary <- sst_with_dhw %>%
  mutate(year = year(time)) %>%
  filter(year >= 2004 & year <= 2024) %>%    # Restrict to desired years
  group_by(site, year) %>%
  filter(!all(is.na(dhw))) %>%                # Remove groups with all NA dhw
  summarise(max_dhw = max(dhw, na.rm = TRUE), .groups = "drop")

# Count years over 8 DHW
dhw_gt8_summary <- dhw_summary %>%
  group_by(site) %>%
  summarise(years_over_8 = sum(max_dhw > 8, na.rm = TRUE))

# Cumulative DHW per site over all years
cumulative_dhw <- dhw_summary %>%
  group_by(site) %>%
  summarise(total_dhw = sum(max_dhw, na.rm = TRUE))

```

## Site Map
```{r}
# Load required libraries
#install.packages("rnaturalearth")
#install.packages("rnaturalearthdata")
#install.packages("ggspatial")
library(rnaturalearth)
library(rnaturalearthdata)
library(ggplot2)
library(dplyr)
library(sf)
library(ggspatial)

# Load world map and ocean shapefiles
worldmap <- st_as_sf(ne_countries(scale = "medium", returnclass = "sf"))
ocean_data <- st_as_sf(ne_download(scale = "medium", type = "ocean", category = "physical"))

# Define map extent for Ningaloo Reef
lon_bounds <- c(112, 115)
lat_bounds <- c(-25, -20)

# Create data frame for site coordinates
sites <- data.frame(
  site = factor(c("Tantabiddi", "Bruboodjoo"), levels = c("Tantabiddi", "Bruboodjoo")),
  lon = c(113.957373, 113.777517),
  lat = c(-21.918595, -22.949383)
)

# Convert to sf object
sites_sf <- st_as_sf(sites, coords = c("lon", "lat"), crs = 4326)

# Install if you haven't already
if (!requireNamespace("remotes")) install.packages("remotes")
remotes::install_github("ropensci/rnaturalearthhires")

# Load countries at scale 10 (highest detail)
worldmap_hi <- ne_countries(scale = 10, returnclass = "sf")

australia <- worldmap_hi %>% dplyr::filter(admin == "Australia")

ocean <- ne_download(scale = 10, type = "ocean", category = "physical", returnclass = "sf")

# Read the shapefile (adjust path and file name as needed)
reef_layer <- st_read("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/worldheritagemarineprogramme.shp")

st_crs(reef_layer)  # check current CRS
reef_layer <- st_transform(reef_layer, crs = 4326)  # reproject if needed


ningaloo <- ggplot() +
  # 1. Ocean background — goes in the back
  geom_sf(data = ocean, fill = "aliceblue", color = NA) +

  # 2. Reef layer — now on top of ocean
  geom_sf(data = reef_layer, fill = "lightgreen", color = NA, alpha = 0.6) +

  # 3. Land on top of reef + ocean
  geom_sf(data = australia, fill = "cornsilk", color = "black") +

  # 4. Site points on top of everything
  geom_sf(data = sites_sf, aes(color = site), size = 3) +

  # Zoom to Ningaloo
  coord_sf(xlim = c(113, 115), ylim = c(-24, -21), expand = FALSE) +

  # Site colors and legend
  scale_color_manual(
    name = "Collection Site",
    values = c("Tantabiddi" = "#ff7f0e", "Bruboodjoo" = "#1f77b4")
  ) +
  annotation_north_arrow(
  location = "tr",         # "tr" = top right
  which_north = "true",    # "true" = geographic north
  style = north_arrow_fancy_orienteering,  # or choose other styles
  height = unit(1.2, "cm"),
  width = unit(1.2, "cm")
) +

  theme_minimal() +
  theme(
    panel.background = element_blank(),
    plot.background = element_blank(),
    panel.border = element_rect(color = "black", fill = NA),
    axis.text = element_text(color = "black"),
    axis.title = element_text(color = "black")
  ) +
  xlab("Longitude") +
  ylab("Latitude")

ggsave("Ningaloo_Map.png", plot = ningaloo, device = "png")
```
## Combine plots
```{r}
library(patchwork)

combined_plot <- 
  ningaloo + 
  plot_monthly_sst + 
  plot_annual_sst + 
  plot_layout(ncol = 3, guides = "collect") & 
  theme(legend.position = "bottom")

combined_plot

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Ningaloo_Site_Map_SST.png", plot = combined_plot, device = "png", width = 10, height = 5, dpi = 300)
```
##Save environment
```{r}
save.image(file = "C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/my_environment_13_6_25.RData")
```
Daily SST for DHW
```{r}
library(ncdf4)     # for reading NetCDF
library(dplyr)
library(lubridate)
library(zoo)
library(tidyr)

nc <- nc_open("C:/Users/jc980786/Downloads/NingalooReef_1985-2022SST_new.nc")

# Check variables
print(nc)

# Extract variables
lon <- ncvar_get(nc, "lon")          # length 10
lat <- ncvar_get(nc, "lat")          # length 35
time <- ncvar_get(nc, "time")        # length 13872
sst_raw <- ncvar_get(nc, "analysed_sst")  # 3D array lon x lat x time

# Convert time to Date
time_origin <- as.Date("1985-01-01")  # ignoring 12:00 noon difference
dates <- time_origin + time

nc_close(nc)

# Apply scale factor
sst <- sst_raw * 0.01

# Create a data frame with all combinations and sst values
grid <- expand.grid(lon = lon, lat = lat)

# For memory efficiency, process in chunks or just example for one time point:
# But here: reshape full 3D array into long format

# Permute sst array to time x lon x lat for easier reshaping
sst_perm <- aperm(sst, c(3,1,2))  # now dim: time x lon x lat

# Convert to data frame:
df_list <- lapply(1:length(dates), function(i) {
  temp_df <- expand.grid(lon = lon, lat = lat)
  temp_df$sst <- as.vector(sst_perm[i,,])
  temp_df$date <- dates[i]
  temp_df
})

sst_long <- bind_rows(df_list)

# Filter coordinates for your sites
tantabiddi_coords <- list(lon_min = 113.95, lon_max = 113.97, lat_min = -21.95, lat_max = -21.93)
bruboodjoo_coords <- list(lon_min = 113.75, lon_max = 113.80, lat_min = -22.98, lat_max = -22.92)

sst_filtered <- sst_long %>%
  filter(
    (lon >= tantabiddi_coords$lon_min & lon <= tantabiddi_coords$lon_max & lat >= tantabiddi_coords$lat_min & lat <= tantabiddi_coords$lat_max) |
    (lon >= bruboodjoo_coords$lon_min & lon <= bruboodjoo_coords$lon_max & lat >= bruboodjoo_coords$lat_min & lat <= bruboodjoo_coords$lat_max)
  ) %>%
  mutate(site = case_when(
    lon >= tantabiddi_coords$lon_min & lon <= tantabiddi_coords$lon_max &
      lat >= tantabiddi_coords$lat_min & lat <= tantabiddi_coords$lat_max ~ "Tantabiddi",
    lon >= bruboodjoo_coords$lon_min & lon <= bruboodjoo_coords$lon_max &
      lat >= bruboodjoo_coords$lat_min & lat <= bruboodjoo_coords$lat_max ~ "Bruboodjoo",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(site))

# Average daily SST per site
daily_sst <- sst_filtered %>%
  group_by(site, date) %>%
  summarise(daily_sst = mean(sst, na.rm = TRUE), .groups = "drop")

# Add year and month columns
daily_sst <- daily_sst %>%
  mutate(year = year(date), month = month(date))

# Calculate monthly mean SST per site/year/month
monthly_means <- daily_sst %>%
  group_by(site, year, month) %>%
  summarise(monthly_mean_sst = mean(daily_sst, na.rm = TRUE), .groups = "drop")

# Calculate annual MMM = max monthly mean SST per site/year
mmm_annual <- monthly_means %>%
  group_by(site, year) %>%
  summarise(mmm = max(monthly_mean_sst, na.rm = TRUE), .groups = "drop")

sst_with_mmm <- daily_sst %>%
  left_join(mmm_annual, by = c("site", "year")) %>%
  arrange(site, date) %>%
  mutate(
    hotspot = ifelse(daily_sst > (mmm + 1), daily_sst - mmm, 0)
  )

library(zoo)

# Rolling window width = 84 days
window_days <- 84

sst_with_dhw <- sst_with_mmm %>%
  group_by(site) %>%
  arrange(date) %>%
  mutate(
    dhw = rollapply(hotspot, width = window_days, FUN = function(x) sum(x) / 7, align = "right", fill = NA)
  ) %>%
  ungroup()

dhw_summary <- sst_with_dhw %>%
  group_by(site, year) %>%
  summarise(max_dhw = max(dhw, na.rm = TRUE), .groups = "drop")

dhw_years_gt8 <- dhw_summary %>%
  group_by(site) %>%
  summarise(years_dhw_over_8 = sum(max_dhw > 8, na.rm = TRUE))

print(dhw_years_gt8)



```

```{r}
# Load packages
library(ncdf4)
library(dplyr)
library(lubridate)
library(zoo)
library(tidyr)
library(ggplot2)

# --- Step 1: Load and Prepare SST Data ---
nc <- nc_open("C:/Users/jc980786/Downloads/NingalooReef_1985-2022SST_new.nc")

lon <- ncvar_get(nc, "lon")
lat <- ncvar_get(nc, "lat")
time <- ncvar_get(nc, "time")
sst_raw <- ncvar_get(nc, "analysed_sst")  # lon x lat x time
nc_close(nc)

# Convert time
time_origin <- as.Date("1985-01-01")
dates <- time_origin + time

# Scale SST
sst <- sst_raw

# Reshape to long format
sst_perm <- aperm(sst, c(3, 1, 2))  # time x lon x lat
df_list <- lapply(1:length(dates), function(i) {
  temp_df <- expand.grid(lon = lon, lat = lat)
  temp_df$sst <- as.vector(sst_perm[i, , ])
  temp_df$date <- dates[i]
  temp_df
})
sst_long <- bind_rows(df_list)

# --- Step 2: Filter for Study Sites ---
# Helper function to find nearest lon/lat grid point
find_nearest_point <- function(target_lon, target_lat, lon_vec, lat_vec) {
  dist <- outer(lon_vec, lat_vec, FUN = function(x, y) sqrt((x - target_lon)^2 + (y - target_lat)^2))
  which_min <- which(dist == min(dist), arr.ind = TRUE)
  list(lon = lon_vec[which_min[1]], lat = lat_vec[which_min[2]])
}

# Target site centers (you can adjust if needed)
tantabiddi_target <- list(lon = 113.96, lat = -21.94)
bruboodjoo_target <- list(lon = 113.775, lat = -22.95)

# Find closest grid points
tantabiddi_nearest <- find_nearest_point(tantabiddi_target$lon, tantabiddi_target$lat, lon, lat)
bruboodjoo_nearest <- find_nearest_point(bruboodjoo_target$lon, bruboodjoo_target$lat, lon, lat)

# Combine into site dataframe
site_coords <- data.frame(
  site = c("Tantabiddi", "Bruboodjoo"),
  lon = c(tantabiddi_nearest$lon, bruboodjoo_nearest$lon),
  lat = c(tantabiddi_nearest$lat, bruboodjoo_nearest$lat)
)

# Filter SST data to those exact grid points
sst_filtered <- sst_long %>%
  inner_join(site_coords, by = c("lon", "lat"))

# --- Step 3: Calculate Daily and Monthly Means ---
daily_sst <- sst_filtered %>%
  group_by(site, date) %>%
  summarise(daily_sst = mean(sst, na.rm = TRUE), .groups = "drop") %>%
  mutate(year = year(date), month = month(date))

monthly_means <- daily_sst %>%
  group_by(site, year, month) %>%
  summarise(monthly_mean_sst = mean(daily_sst, na.rm = TRUE), .groups = "drop")

# --- Step 4: Calculate Climatological MMM (1985–2015) ---
baseline_mmm <- monthly_means %>%
  filter(year >= 1985 & year <= 2015) %>%
  group_by(site, month) %>%
  summarise(clim_monthly_mean = mean(monthly_mean_sst, na.rm = TRUE), .groups = "drop") %>%
  group_by(site) %>%
  summarise(mmm = max(clim_monthly_mean, na.rm = TRUE), .groups = "drop")

# --- Step 5: Calculate HotSpot and DHW ---
#Calculates the Coral Bleaching HotSpot as defined:
#SST - MMM, but only when SST > MMM + 1°C.
sst_with_mmm <- daily_sst %>%
  left_join(baseline_mmm, by = "site") %>%
  arrange(site, date) %>%
  mutate(
    hotspot = ifelse(daily_sst > (mmm + 1), daily_sst - mmm, 0)
  )

# Apply rolling 84-day window (DHW = sum of HotSpots / 7), Sums only HotSpot values ≥ 1°C
sst_with_dhw <- sst_with_mmm %>%
  group_by(site) %>%
  arrange(date) %>%
  mutate(
    dhw = rollapply(hotspot, width = 84, FUN = function(x) sum(x) / 7, align = "right", fill = NA),
    bleaching_alert = case_when(
      dhw > 8 ~ "Alert Level 2",
      dhw > 4 ~ "Alert Level 1",
      hotspot > 1 ~ "Watch",
      TRUE ~ "None"
    )
  ) %>%
  ungroup()

# --- Step 6: Summarise & Print DHW Over Threshold ---
dhw_summary <- sst_with_dhw %>%
  group_by(site, year = year(date)) %>%
  summarise(max_dhw = max(dhw, na.rm = TRUE), .groups = "drop")

dhw_years_gt8 <- dhw_summary %>%
  group_by(site) %>%
  summarise(years_dhw_over_8 = sum(max_dhw > 8, na.rm = TRUE))

print(dhw_years_gt8)

# --- Step 7: Plotting DHW Time Series ---
DWHplot <- ggplot(sst_with_dhw, aes(x = date, y = dhw, color = site)) +
  geom_line() +
  geom_hline(yintercept = 4, linetype = "dashed", color = "#fee08b") +
  geom_hline(yintercept = 8, linetype = "dashed", color = "#d53e4f") +
  facet_wrap(~site, scales = "fixed") +  # <-- FIXED y-axis
  scale_y_continuous(name = "Degree Heating Weeks (°C-weeks)") +
  scale_color_manual(
    values = c(
      "Tantabiddi" = "#ff7f0e",
      "Bruboodjoo" = "#1f77b4"
    )
  ) +
  labs(
    title = "Degree Heating Weeks (DHW) Over Time at Two Ningaloo Reef Sites",
    subtitle = "Dashed lines show Alert Level 1 (4°C-weeks) and Alert Level 2 (8°C-weeks)",
    x = "Date",
    color = "Site"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")


#save
ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/dhwplot.png", plot = DWHplot, width = 15, height = 5, dpi = 300)

#Calculate annual MMM per year (i.e., warmest monthly mean per year)
annual_mmm <- monthly_means %>%
  group_by(site, year) %>%
  summarise(yearly_mmm = max(monthly_mean_sst, na.rm = TRUE), .groups = "drop") %>%
  filter(year >= 1985 & year <= 2022)  # restrict to desired range

#Summary stats
mmm_summary <- annual_mmm %>%
  group_by(site) %>%
  summarise(
    mean_mmm = mean(yearly_mmm, na.rm = TRUE),
    sd_mmm = sd(yearly_mmm, na.rm = TRUE),
    n = n()
  )

#Paird t-test
mmm_wide <- annual_mmm %>%
  pivot_wider(names_from = site, values_from = yearly_mmm)

t_test_mmm <- t.test(mmm_wide$Tantabiddi, mmm_wide$Bruboodjoo, paired = TRUE)

#Years with DHW > 8 + Fisher's Exact Test or Chi-square
dhw_years_gt8 <- dhw_summary %>%
  group_by(site) %>%
  summarise(years_dhw_over_8 = sum(max_dhw > 8, na.rm = TRUE))

# Create 2x2 contingency table
dhw_contingency <- dhw_summary %>%
  mutate(over_8 = max_dhw > 8) %>%
  count(site, over_8) %>%
  pivot_wider(names_from = over_8, values_from = n, values_fill = 0)

fisher_test <- fisher.test(dhw_contingency[,-1])

chisq_test <- chisq.test(as.matrix(dhw_contingency[,-1]))

#Compute annual SD per site and then compare with a t-test
sst_variability <- daily_sst %>%
  filter(year >= 1985 & year <= 2022) %>%
  group_by(site, year) %>%
  summarise(temp_sd = sd(daily_sst, na.rm = TRUE), .groups = "drop")

# Summary stats
variability_summary <- sst_variability %>%
  group_by(site) %>%
  summarise(mean_sd = mean(temp_sd), sd_sd = sd(temp_sd))

# Paired t-test
sst_sd_wide <- sst_variability %>%
  pivot_wider(names_from = site, values_from = temp_sd)

t_test_variability <- t.test(sst_sd_wide$Tantabiddi, sst_sd_wide$Bruboodjoo, paired = TRUE)


```

Load in data from Fv/Fm to get percentage of larvae with symbiont cells

```{r}
#install.packages("MCMCglmm")
library(MCMCglmm)
#install.packages("lsmeans")
library(emmeans)

totaldf = read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_FINAL2.csv", header = TRUE)
str(totaldf)

library(tidyr)

# Convert No.Cells1 to numeric
totaldf$No.Cells1 <- as.numeric(totaldf$No.Cells1)

# Reshape the data to long format so all of the cell densities are in one column
totaldf_long <- totaldf %>%
  pivot_longer(cols = c(No.Cells1, No.Cells2, No.Cells3), 
               names_to = "Cell_Measurement", 
               values_to = "Cell_Density")

# Check the structure of the reshaped data
str(totaldf_long)

# Replace empty strings with NA
totaldf_long$Cell_Density[totaldf_long$Cell_Density == ""] <- NA

# Convert the Cell_Density column to numeric 
totaldf_long$Cell_Density <- as.numeric(totaldf_long$Cell_Density)

# Check for missing values in each of the predictor columns
sum(is.na(totaldf_long$SymbiontTreatment))
sum(is.na(totaldf_long$Family))
sum(is.na(totaldf_long$Treatment))
sum(is.na(totaldf_long$Timepoint))  

# Keep rows up to 8316. After that they are just blank rows that got imported.
totaldf_long_subset <- totaldf_long[1:8316, ]

# Check the structure of the subset data frame
str(totaldf_long_subset)

totaldf_long_clean <- totaldf_long_subset %>%
  filter(!is.na(totaldf_long_subset$SymbiontTreatment) & !is.na(totaldf_long_subset$Family) & !is.na(totaldf_long_subset$Treatment) & !is.na(totaldf_long_subset$Timepoint))

# df is the main dataframe we'll be using
df <- totaldf_long_clean

# Assign Temp values based on Treatment
df_clean <- df %>%
  mutate(Temp = case_when(
    Treatment == "Ambient" ~ "T1",
    Treatment == "31" ~ "T2",
    Treatment == "35.5" ~ "T3",
    TRUE ~ NA_character_  # Handle other cases explicitly
  ))

# Create a UniqueID column by combining Temp and tube.ID columns
df_clean$UniqueID <- paste0(df_clean$Temp, "V", df_clean$tube.ID.1)

#load in Fv/Fm dataset and merge with metadata
ipam <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/Metadata_NingSpawn2024_iPAM.csv")
str(ipam)

library(dplyr)
library(tidyr)
library(stringr)
library(lubridate)

ipam <- ipam %>%
  # Assign treatment labels
  mutate(TREATMENT = case_when(
    TEMP == 27.5 ~ "T1",
    TEMP == 31 ~ "T2",
    TEMP == 35.5 ~ "T3",
    TRUE ~ NA_character_
  )) %>%
  # Create UniqueID
  mutate(UniqueID = paste0(TREATMENT, "V", VIAL)) %>%
  # Add missing REP rows per UniqueID × TIMEPOINT
  group_by(UniqueID, TIMEPOINT) %>%
  complete(REP = 1:5, fill = list(FvFm = 0)) %>%
  # Fill metadata values downward and upward within group
  fill(TEMP, SYMBIONT_TREATMENT, .direction = "downup") %>%
  ungroup() %>%
  # Recalculate VIAL from UniqueID if still missing
  mutate(
    VIAL = ifelse(is.na(VIAL), as.integer(str_extract(UniqueID, "(?<=V)\\d+")), VIAL),
    TREATMENT = ifelse(is.na(TREATMENT), str_extract(UniqueID, "^T\\d"), TREATMENT)
  ) %>%
  # Add Dates for TIMEPOINTs
  mutate(
    Days = case_when(
      TIMEPOINT == 1 ~ as.Date("2024-04-11"),
      TIMEPOINT == 4 ~ as.Date("2024-04-14"),
      TIMEPOINT == 22 ~ as.Date("2024-05-02"),
      TRUE ~ as.Date(NA)
    )
  )

# Load metadata summary
perc_larvae_summary <- read.csv("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/perc_larvae_summary.csv")

# Make sure TIMEPOINT is the same type in both dataframes (numeric or integer)
perc_larvae_summary <- perc_larvae_summary %>%
  rename(TIMEPOINT = Days) %>%
  rename(UniqueID = rep.ID)
perc_larvae_summary$TIMEPOINT <- as.numeric(perc_larvae_summary$TIMEPOINT)
ipam$TIMEPOINT <- as.numeric(ipam$TIMEPOINT)

# Merge metadata
ipam <- ipam %>%
  left_join(perc_larvae_summary, by = c("UniqueID", "TIMEPOINT"))

#Clean up
ipam <- ipam %>%
  dplyr::select(-POINT, -SYMBIONT_TREATMENT, -PAR, -AVERAGE_FvFm)

#Calculate the percentage of larvae with cells per vial:
epsilon <- 1e-8  # Avoid division by zero

ipam <- ipam %>%
  group_by(UniqueID) %>%
  arrange(TIMEPOINT) %>%
  mutate(
    CellsInitial = first(na.omit(perc.larv)),
    CellsFinal = last(na.omit(perc.larv)),
    PercChangeCells = ((CellsFinal - CellsInitial))
  ) %>%
  ungroup()

#Calculate the percentage of larvae with cells per vial for summary plot. Assuming that FvFm > 0 indicates larvae with cells:
summary_df <- ipam %>%
  group_by(Timepoint, TREATMENT) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100)

#create figure
ggplot(ipam, aes(x = Timepoint, y = PercChangeCells, color = TREATMENT)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage of Larvae with Cells"
  ) +
  theme_minimal() +
  theme(
    text = element_text(size = 14),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  ) +
  scale_color_manual(values = c("T1" = "blue", "T2" = "orange", "T3" = "red"))

#Now we want to view differences in symbiont taxa
# Subset totaldf_long to UniqueID and SymbiontTreatment and remove duplicates
df_clean_subset <- df_clean %>%
  dplyr::select(UniqueID, SymbiontTreatment, ReefMom) %>%
  distinct(UniqueID, .keep_all = TRUE)

# Merge the SymbiontTreatment column from totaldf_long to ipam by UniqueID
ipam_taxa <- ipam %>%
  left_join(df_clean_subset %>% dplyr::select(UniqueID, SymbiontTreatment), by = "UniqueID")

# Summarize data to include SymbiontTreatment
ipam_taxa <- ipam_taxa %>%
  rename(SymbiontTreatment = zoox)

summary_df2 <- ipam_taxa %>%
  group_by(Timepoint, Treatment, SymbiontTreatment) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100, .groups = "drop")

# Define custom colors for SymbiontTreatment
custom_colors <- c("C" = "green", "D" = "red")  # Example: red-orange for "C" and blue for "D"

#make timepoint numeric
summary_df2$Timepoint <- as.numeric(as.character(summary_df2$Timepoint))

#plot
ggplot(summary_df2, aes(x = Timepoint, y = PercentageWithCells, color = SymbiontTreatment)) +
  geom_point(alpha = 0.6, size = 2) +  # Scatter plot
  geom_line(aes(group = SymbiontTreatment), alpha = 0.6) +  # Line connecting points
  facet_wrap(~ Treatment, scales = "fixed") +  # Facets by TREATMENT with free y-axes
  scale_color_manual(values = custom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0,2,4,6,8,10,12,14,16,18,20,22),  # Add breaks for specific days
    labels = c("0","2","4","6","8","10","12","14","16","18","20","22")  # Label days
  ) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage with Cells (%)",
    color = "Symbiont Treatment"
  ) +
  theme_classic() +  # Clean theme
  theme(
    strip.text = element_text(size = 12),  # Facet label size
    axis.text = element_text(size = 10),  # Axis text size
    legend.title = element_text(size = 12),  # Legend title size
    legend.text = element_text(size = 10)   # Legend text size
  )

#Plot only survivors
#gives basically the same output as the original
# Step 1: Identify UniqueIDs present in all three timepoints (1, 4, 22)
filtered_ipam <- ipam %>%
  filter(Timepoint %in% c(1, 4, 22))

# Step 3: Merge SymbiontTreatment for surviving larvae
filtered_ipam <- filtered_ipam %>%
  left_join(df_clean_subset %>% dplyr::select(UniqueID, SymbiontTreatment, ReefMom), by = "UniqueID")

# Step 4: Create the summary dataframe for larvae that survived until timepoint 22
filtered_ipam <- filtered_ipam %>%
  rename(SymbiontTreatment = zoox)

ipam_taxa_survived <- filtered_ipam %>%
  group_by(Timepoint, Treatment, ReefMom, SymbiontTreatment, UniqueID) %>%
  summarize(PercentageWithCells = mean(FvFm > 0, na.rm = TRUE) * 100, .groups = "drop")

# Step 6: Map days to numeric day values
summary_df2_survived <- ipam_taxa_survived %>%
  mutate(DayNumber = as.numeric(date_to_day[as.character(Timepoint)]))

# Step 7: Plot the data for only larvae that survived until timepoint 22 and have data for all three timepoints
summary_df2_survived$Timepoint <- as.numeric(as.character(summary_df2_survived$Timepoint))

ggplot(summary_df2_survived, aes(x = Timepoint, y = PercentageWithCells,
                               color = ReefMom, shape = SymbiontTreatment)) +
  geom_point(alpha = 0.6, size = 2) +  # Scatter plot
  geom_line(aes(group = interaction(ReefMom, SymbiontTreatment)), alpha = 0.6) +  # Line connecting points
  facet_wrap(~ Treatment) +  # Facets by TREATMENT
  scale_color_manual(values = custom_ReefMom_colors) +  # Apply custom colors
  scale_x_continuous(
    breaks = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22),
    labels = c("0", "2", "4", "6", "8", "10", "12", "14", "16", "18", "20", "22")
  ) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Percentage with Cells (%)",
    color = "ReefMom",
    shape = "Symbiont Treatment"
  ) +
  theme_classic() +
  theme(
    strip.text = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )


#plot with summary stats for Cross
# Add Cross column based on ReefMom
ipam_taxa_survived <- ipam_taxa_survived %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

# Then summarize including Cross instead of ReefMom
summary_stats <- ipam_taxa_survived %>%
  group_by(Timepoint, SymbiontTreatment, Treatment) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se = sd(PercentageWithCells, na.rm = TRUE) / sqrt(sum(!is.na(PercentageWithCells))),
    ci_lower = mean_pct - qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    ci_upper = mean_pct + qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    .groups = "drop"
  )


plot1_perc <- ggplot(summary_stats, aes(x = Timepoint, y = mean_pct, 
                                        color = Cross, shape = SymbiontTreatment)) +
  geom_point(size = 3, stroke = 1, fill = "white") +   # black border around points
  geom_line(aes(group = SymbiontTreatment), size = 1) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper, group = SymbiontTreatment), width = 0.3) +
  facet_wrap(~Treatment, ncol = 3) +
  scale_color_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +
  labs(
    title = "Percentage of Larvae with Cells Over Time",
    x = "Days",
    y = "Mean Percentage with Cells (%)",
    color = "Population of Origin"
  ) +
  theme_classic()

plot1_perc

summary_stats <- summary_stats %>%
  mutate(Timepoint = as.numeric(as.character(Timepoint)))


plot1_perc <- ggplot(summary_stats, 
                     aes(x = Timepoint, y = mean_pct, 
                         group = interaction(Cross, SymbiontTreatment))) +

  # error bars (grouped same as lines/points)
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper,
                    group = interaction(Cross, SymbiontTreatment),
                    color = Cross),
                width = 0.3) +

  # lines colored by Cross
  geom_line(aes(color = Cross), size = 1) +

  # points: fill maps to Cross, shape to SymbiontTreatment, border (color) fixed black
  geom_point(aes(fill = Cross, shape = SymbiontTreatment),
             color = "black",    # border color
             size = 3,
             stroke = 0.8) +     # border thickness

  # facets
  facet_wrap(~ Treatment, ncol = 3) +

  # scales: same palette for fill and line color
  scale_fill_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +
  scale_color_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +

  # shapes must be in 21:25 to allow fill + border
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +
  
  scale_x_continuous(breaks = seq(0, 22, 2)) +   # every day 1–22

  labs(title = "Percentage of Larvae with Cells Over Time",
       x = "Days",
       y = "Mean Larvae with Symbionts (%)",
       color = "Population of Origin",
       fill  = "Population of Origin",
       shape = "Symbiont") +
  theme_classic()

plot1_perc 

#summary collapsing symbiont and host population
summary_stats_means <- ipam_taxa_survived %>%
  group_by(Timepoint, Treatment) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se = sd(PercentageWithCells, na.rm = TRUE) / sqrt(sum(!is.na(PercentageWithCells))),
    ci_lower = mean_pct - qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    ci_upper = mean_pct + qt(0.975, df = sum(!is.na(PercentageWithCells)) - 1) * se,
    .groups = "drop"
  )
```
Combine PercentageWithCells and Cell Density
```{r}
# Load patchwork library
library(patchwork)

# 1. Create all combinations of grouping variables
day0_dummy <- cells_long %>%
  distinct(TubeID, CellType, Cross, Treatment, Reef) %>%   # get unique groups
  mutate(
    T.End = 0,
    CellDensity = 0
  )

# 2. Combine with end-of-experiment data
cells_combined <- bind_rows(day0_dummy, cells_long %>% filter(T.End == 23))

# 3. Optional: reorder by TubeID, CellType, etc.
cells_combined <- cells_combined %>%
  arrange(TubeID, CellType, Cross, Treatment, T.End)

summary_df_cells_grouped <- cells_combined %>%
  mutate(
    Reef = if_else(Cross %in% c("B.T.2xB.T.4", "B.T.4xB.T.2", "B.T.8xB.T.2"), "CC", "WW"),
    DayNumber = T.End
  ) %>%
  group_by(DayNumber, Reef, CellType, Treatment) %>%
  summarise(
    mean_CellDensity = mean(CellDensity, na.rm = TRUE),
    sd_CellDensity = sd(CellDensity, na.rm = TRUE),
    n = n(),
    se = sd_CellDensity / sqrt(n),
    ci_lower = mean_CellDensity - qt(0.975, df = n - 1) * se,
    ci_upper = mean_CellDensity + qt(0.975, df = n - 1) * se,
    .groups = "drop"
  )

# plot
plot_cells <- ggplot(summary_df_cells_grouped, 
                     aes(x = DayNumber, y = mean_CellDensity, 
                         group = interaction(Reef, CellType))) +

  # error bars colored by Reef
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper,
                    group = interaction(Reef, CellType),
                    color = Reef),
                width = 0.3) +

  # lines colored by Reef
  geom_line(aes(color = Reef), size = 1) +

  # points with fill = Reef, shape = CellType, black border
  geom_point(aes(fill = Reef, shape = CellType),
             color = "black",
             size = 3,
             stroke = 0.8) +

  # facets by Treatment
  facet_wrap(~ Treatment, ncol = 3) +

  # color/fill scales
  scale_fill_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +
  scale_color_manual(values = c("CC" = "#1f77b4", "WW" = "#ff7f0e")) +

  # shape scale (21-25 to allow fill + border)
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  # x axis as numeric days
  scale_x_continuous(breaks = seq(0, 23, 2)) +

  labs(title = "Larval Cell Density Over Time",
       x = "Days",
       y = "Mean Cell Density",
       color = "Population of Origin",
       fill  = "Population of Origin",
       shape = "Cell Type") +

  theme_classic()

plot_cells 

# Combine plots using patchwork
combined_plot <- plot1_perc / plot_cells  # Stack vertically
# Alternatively, to place them side by side:
# combined_plot <- plot1 + plot2

# Display combined plot
combined_plot

# Save the combined plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_percentcells_density_by_Reef2.png", plot = combined_plot, width = 10, height = 8, dpi = 300)


```
Plot of mean size at T22

```{r}
# Replace NA values with zeros in the Area..mm.2. column
df_clean$Area..mm.2.[is.na(df_clean$Area..mm.2.)] <- 0

# Group by UniqueID and calculate initial and final cell densities
df_clean <- df_clean %>%
  group_by(UniqueID) %>%
  arrange(Timepoint) %>%  # Ensure the dataframe is arranged by Timepoint
  mutate(
    Sizeinitial = first(Area..mm.2.),  # First recorded value of size for each UniqueID
    Sizefinal = last(Area..mm.2.)      # Last recorded value of size for each UniqueID
  ) %>%
  ungroup()

# Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  Cross_2 = unique(df_clean$Cross_2),
  SymbiontTreatment = unique(df_clean$SymbiontTreatment),
  stringsAsFactors = FALSE
)

final_timepoint_df_full <- all_combos %>%
  left_join(final_timepoint_df, by = c("Treatment", "Cross_2", "SymbiontTreatment")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_area), 0, mean_area),
    se_area = ifelse(is.na(se_area), 0, se_area),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e") # Modify colors as needed

# Plot the mean area with error bars and custom colors
area_plot <- ggplot(final_timepoint_df, aes(x = Treatment, y = mean_area)) +
  geom_point(aes(fill = Cross_2, shape = SymbiontTreatment), 
             color = "black", size = 4, stroke = 1.5) +  # black border around points
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area, 
                    color = Cross_2), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 24)) +  # use shapes that support fill (adjust as needed)
  labs(x = "Temperature Treatment", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )



# Display the plot
print(area_plot)

# Create inset for the above plot
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df_inset <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_df_inset <- final_timepoint_df_inset %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_area_plot <- ggplot(final_timepoint_df_inset, aes(x = Treatment, y = mean_area)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_area_plot)

# Create inset for the above plot seperated by Treatment and Symbiont treatment
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_df_inset2 <- df_clean %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_area = mean(Area..mm.2., na.rm = TRUE),
            se_area = sd(Area..mm.2., na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_df_inset2 <- final_timepoint_df_inset2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_area_plot2 <- ggplot(final_timepoint_df_inset2, aes(x = Treatment, y = mean_area, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_area - se_area, ymax = mean_area + se_area), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Area (mm² ± s.e.)",
       title = "Mean Larval Area at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_area_plot2)

# Combine the two plots side by side
combined_plot_mean_area <- mean_area_plot + mean_area_plot2 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_mean_area)

# Save the combined plot as a PNG file
ggsave("combined_plot_mean_area_inset.png", plot = combined_plot_mean_area, width = 6, height = 3, dpi = 300)

```

Plot of percent change in size

```{r}

# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_perc_change = mean(PercChangeSize, na.rm = TRUE),
            se_perc_change = sd(PercChangeSize, na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  Cross_2 = unique(totaldf_long$Cross_2),
  SymbiontTreatment = unique(totaldf_long$SymbiontTreatment),
  stringsAsFactors = FALSE
)

perc_change_summary <- all_combos %>%
  left_join(perc_change_summary, by = c("Treatment", "Cross_2", "SymbiontTreatment")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_area = ifelse(is.na(se_perc_change), 0, se_perc_change),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot the percent change in area with error bars and custom colors
perc_change_plot <- ggplot(perc_change_summary, aes(x = Treatment, y = mean_perc_change, 
                                                    fill = Cross_2, shape = SymbiontTreatment)) +
  geom_point(size = 4, color = "black", stroke = 1.5) +  # Point border is black
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change,
                    color = Cross_2),  # Match error bars to fill color
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +   # Fill = group color
  scale_color_manual(values = custom_colors) +  # Color = same as fill (for error bars)
  scale_shape_manual(values = c(21, 24)) +      # Shapes that allow fill and border
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the plot
print(perc_change_plot)

# Create inset just for treatment
# Group by Treatment and calculate mean and standard error for percent change
perc_change_summary2 <- df_clean %>%
  group_by(Treatment) %>%
  summarise(mean_perc_change = mean(PercChangeArea, na.rm = TRUE),
            se_perc_change = sd(PercChangeArea, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary2 <- perc_change_summary2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot2 <- ggplot(perc_change_summary2, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot2)

# Create inset for treatment and symbiont treatment
# Group by Treatment and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary3 <- df_clean %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_perc_change = mean(PercChangeArea, na.rm = TRUE),
            se_perc_change = sd(PercChangeArea, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
perc_change_summary3 <- perc_change_summary3 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
perc_change_plot3 <- ggplot(perc_change_summary3, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change, ymax = mean_perc_change + se_perc_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area from Timepoint 1 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(perc_change_plot3)

# Combine the two plots side by side
combined_plot_perc_area <- perc_change_plot2 + perc_change_plot3 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_perc_area)

# Save the combined plot as a PNG file
ggsave("combined_plot_perc_area_inset.png", plot = combined_plot_perc_area, width = 6, height = 3, dpi = 300)
```
Combine area and perc change area plots
```{r}
# Install patchwork if you haven't already
install.packages("patchwork")

# Load patchwork
library(patchwork)

# Combine the two plots side by side
combined_plot <- area_plot + perc_change_plot + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot)

# Save the combined plot as a PNG file
ggsave("combined_plot.png", plot = combined_plot, width = 12, height = 6, dpi = 300)

```

Percent change in size for survivors

```{r}
# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
perc_change_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment, ReefMom) %>%
  summarise(mean_perc_change = mean(PercChangeSize, na.rm = TRUE),
            se_perc_change = sd(PercChangeSize, na.rm = TRUE) / sqrt(n()))

all_combos <- expand.grid(
  Treatment = c("Ambient", "31"),
  Cross_2 = unique(totaldf_long$Cross_2),
  SymbiontTreatment = unique(totaldf_long$SymbiontTreatment),
  ReefMom = unique (totaldf_long$ReefMom),
  stringsAsFactors = FALSE
)

perc_change_summary <- all_combos %>%
  left_join(perc_change_summary, by = c("Treatment", "Cross_2", "SymbiontTreatment", "ReefMom")) %>%
  mutate(
    mean_area = ifelse(is.na(mean_perc_change), 0, mean_perc_change),
    se_area = ifelse(is.na(se_perc_change), 0, se_perc_change),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))  # Re-set factor levels
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot percent change in area with colors assigned to Cross_2 and separate panels for Family
survivors_perc_change <- ggplot(perc_change_summary, aes(x = Treatment, y = mean_perc_change, 
                                                        fill = Cross_2, shape = SymbiontTreatment)) +
  geom_line(aes(group = interaction(Cross_2, SymbiontTreatment), color = Cross_2), size = 0.7) +  # connecting lines
  geom_point(size = 4, color = "black", stroke = 1.5) +  # points with black border
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change,
                    color = Cross_2), width = 0.2) +  # error bars matching fill color
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +  # fill for points
  scale_color_manual(values = custom_colors) + # color for error bars and lines
  scale_shape_manual(values = c(21, 24)) + # shapes that support fill + border
  facet_wrap(~ ReefMom, nrow = 7) +
  labs(x = "Temperature (Treatment)", y = "Percent Change in Area (mm² ± s.e.)",
       title = "Percent Change in Larval Area (Survived to Timepoint 22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.ticks = element_line(color = "black")
  )


print(survivors_perc_change)

# Save the plot to a file
ggsave("percent_change_area_plot.png", 
       plot = survivors_perc_change,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```

Combine the 3 plots for size into one figure

```{r}
# Combine the three plots into one figure
combined_plot2 <- area_plot +  theme(legend.position = "none") +
  perc_change_plot +  theme(legend.position = "none") +
  survivors_perc_change +  theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot2)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_size.png", 
       plot = combined_plot2,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  

```

Plot of mean FV/FM at T22
(first measurements taken at T4)

```{r}

# Filter the dataframe to get data for the final timepoint (22)
final_timepoint_fvfm_df <- totaldf_long %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
final_timepoint_fvfm_df <- final_timepoint_fvfm_df %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(final_timepoint_fvfm_df$SymbiontTreatment),
  Cross_2 = unique(final_timepoint_fvfm_df$Cross_2)
)

# Join with existing data
final_timepoint_fvfm_df <- all_combos %>%
  left_join(final_timepoint_fvfm_df, by = c("Treatment", "SymbiontTreatment", "Cross_2")) %>%
  mutate(
    Timepoint = 22,
    mean_fvfm = ifelse(is.na(mean_fvfm), 0, mean_fvfm),
    se_fvfm = ifelse(is.na(se_fvfm), 0, se_fvfm)
  )

# Define a custom color palette
custom_colors <- c("BxB" = "#1f77b4", "TxT" = "#ff7f0e") # Modify colors as needed

# Plot the mean area with error bars and custom colors
fvfm_plot <- ggplot(final_timepoint_fvfm_df, aes(x = Treatment, y = mean_fvfm, 
                                                 fill = Cross_2, shape = SymbiontTreatment)) +
  # Error bars match fill color
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm,
                    color = Cross_2), 
                width = 0.2) +
  
  # Reference line
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Points with fill and black border
  geom_point(size = 4, stroke = 1.2, color = "black") +

  # Manual color settings
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  # Labels and theme
  labs(x = "Temperature Treatment", 
       y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (22)") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

fvfm_plot

# Create inset for the above plot
# Step 1: Filter the dataframe to get data for the final timepoint (22)

# Reorder the Treatment factor in the desired order
totaldf_long <- totaldf_long %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

final_timepoint_fvfm_df_inset <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Step 2: Create the plot
mean_fvfm_plot <- ggplot(final_timepoint_fvfm_df_inset, aes(x = Treatment, y = mean_fvfm)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_fvfm_plot)

# Create inset for the above plot seperated by Treatment and Symbiont treatment
# Step 1: Filter the dataframe to get data for the final timepoint (22)
final_timepoint_fvfm_df_inset2 <- totaldf_long %>%
  filter(Treatment != "35.5") %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_fvfm = mean(FvFm, na.rm = TRUE),
            se_fvfm = sd(FvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
totaldf_long <- totaldf_long %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Step 2: Create the plot
mean_fvfm_plot2 <- ggplot(final_timepoint_fvfm_df_inset2, aes(x = Treatment, y = mean_fvfm, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +  # Adjust point size as needed
  geom_errorbar(aes(ymin = mean_fvfm - se_fvfm, ymax = mean_fvfm + se_fvfm), 
                width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Mean Fv/Fm (± s.e.)",
       title = "Mean Larval Fv/Fm at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black", linewidth = 0.5)  # Keep axis lines
  )

# Step 4: Display the plot
print(mean_fvfm_plot2)

# Combine the two plots side by side
combined_plot_mean_fvfm <- mean_fvfm_plot + mean_fvfm_plot2 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_mean_fvfm)

# Save the combined plot as a PNG file
ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_mean_fvfm_inset.png", plot = combined_plot_mean_fvfm, width = 6, height = 3, dpi = 300)

```


Plot of raw change in Fv/Fm (% change has too large of error margins for survivors GLMM)

```{r}

# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
raw_change_fvfm_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment) %>%
  summarise(
    mean_raw_change = mean(RawChangeFvFm, na.rm = TRUE),
    se_raw_change = sd(RawChangeFvFm, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder the Treatment factor in the desired order
raw_change_fvfm_summary <- raw_change_fvfm_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(raw_change_fvfm_summary$SymbiontTreatment),
  Cross_2 = unique(raw_change_fvfm_summary$Cross_2)
)

# Join with existing data
raw_change_fvfm_summary <- all_combos %>%
  left_join(raw_change_fvfm_summary, by = c("Treatment", "SymbiontTreatment", "Cross_2")) %>%
  mutate(
    Timepoint = 22,
    raw_pct = ifelse(is.na(mean_raw_change), 0, mean_raw_change),
    se_raw_change = ifelse(is.na(se_raw_change), 0, se_raw_change)
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot the percent change in area with error bars and custom colors
raw_change_fvfm_plot <- ggplot(raw_change_fvfm_summary, aes(
  x = Treatment,
  y = mean_raw_change,
  fill = Cross_2,
  shape = SymbiontTreatment
)) +
  # Error bars colored by Cross_2 (same as fill)
  geom_errorbar(
    aes(
      ymin = mean_raw_change - se_raw_change,
      ymax = mean_raw_change + se_raw_change,
      color = Cross_2
    ),
    width = 0.2
  ) +
  # Points with colored fill and black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +   # fill for points
  scale_color_manual(values = custom_colors) +  # color for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # circle and triangle
  labs(
    x = "Temperature (Treatment)",
    y = "Raw Change in Fv/Fm (± s.e.)",
    title = "Raw Change in Larval Fv/Fm from Timepoint 4 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the plot
print(raw_change_fvfm_plot)

# Create inset just for treatment
# Group by Treatment and calculate mean and standard error for percent change
raw_change_summary2 <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment) %>%
  summarise(mean_raw_change = mean(RawChangeFvFm, na.rm = TRUE),
            se_raw_change = sd(RawChangeFvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
raw_change_summary2 <- raw_change_summary2 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
raw_change_plot2 <- ggplot(raw_change_summary2, aes(x = Treatment, y = mean_raw_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_raw_change - se_raw_change, ymax = mean_raw_change + se_raw_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Raw Change in Fv/Fm (± s.e.)",
       title = "Raw Change in Larval Fv/Fm from Timepoint 4 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(raw_change_plot2)

# Create inset for treatment and symbiont treatment
# Group by Treatment and SymbiontTreatment, and calculate mean and standard error for percent change
raw_change_summary3 <- totaldf_long %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(mean_raw_change = mean(RawChangeFvFm, na.rm = TRUE),
            se_raw_change = sd(RawChangeFvFm, na.rm = TRUE) / sqrt(n()))

# Reorder the Treatment factor in the desired order
raw_change_summary3 <- raw_change_summary3 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot the percent change in area with error bars and custom colors
raw_change_plot3 <- ggplot(raw_change_summary3, aes(x = Treatment, y = mean_raw_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_raw_change - se_raw_change, ymax = mean_raw_change + se_raw_change), 
                width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +  # Add dashed line at y = 0
  labs(x = "Temperature (Treatment)", y = "Raw Change in Fv/Fm (± s.e.)",
       title = "Raw Change in Larval Fv/Fm from Timepoint 4 to 22") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    axis.line = element_line(color = "black"),  # Keep x and y axis lines
    axis.ticks = element_line(color = "black")  # Add axis ticks
  )

# Display the plot
print(raw_change_plot3)

library(patchwork)

# Combine the two plots side by side
combined_plot_raw_fvfm <- raw_change_plot2 + raw_change_plot3 + plot_layout(ncol = 2)

# Display the combined plot
print(combined_plot_raw_fvfm)

# Save the combined plot as a PNG file
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_raw_fvfm_inset.png", plot = combined_plot_raw_fvfm, width = 6, height = 3, dpi = 300)
```

Raw change in FVFM for survivors

```{r}
# Group by Treatment, Cross_2, and SymbiontTreatment, and calculate mean and standard error for percent change
raw_change_fvfm_summary <- totaldf_long %>%
  filter(Timepoint == 22, Status == 0) %>%
  group_by(Treatment, Cross_2, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_raw_change = mean(RawChangeFvFm, na.rm = TRUE),
    se_raw_change = sd(RawChangeFvFm, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder the Treatment factor in the desired order
raw_change_fvfm_summary <- raw_change_fvfm_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31"),
  SymbiontTreatment = unique(raw_change_fvfm_summary$SymbiontTreatment),
  Cross_2 = unique(raw_change_fvfm_summary$Cross_2),
  ReefMom = unique(raw_change_fvfm_summary$ReefMom)
)

# Join with existing data
raw_change_fvfm_summary <- all_combos %>%
  left_join(raw_change_fvfm_summary, by = c("Treatment", "SymbiontTreatment", "Cross_2", "ReefMom")) %>%
  mutate(
    Timepoint = 22,
    mean_raw = ifelse(is.na(mean_raw_change), 0, mean_raw_change),
    se_raw_change = ifelse(is.na(se_raw_change), 0, se_raw_change)
  )

# Define a custom color palette (same as before)
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")  # Modify colors as needed

# Plot percent change in area with colors assigned to Cross_2 and separate panels for Family
survivors_raw_change <- ggplot(raw_change_fvfm_summary, aes(
  x = Treatment,
  y = mean_raw_change,
  fill = Cross_2,
  shape = SymbiontTreatment,
  group = interaction(Cross_2, SymbiontTreatment)
)) +
  # Colored lines connecting points
  geom_line(aes(color = Cross_2), linewidth = 0.8) +

  # Error bars colored by fill
  geom_errorbar(aes(
    ymin = mean_raw_change - se_raw_change,
    ymax = mean_raw_change + se_raw_change,
    color = Cross_2
  ), width = 0.2) +

  # Points with black border and colored fill
  geom_point(size = 4, stroke = 1.2, color = "black") +

  # Reference line at 0
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual color and shape control
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  # Labels and faceting
  labs(
    x = "Temperature (Treatment)",
    y = "Raw Change in Fv/Fm (± s.e.)",
    title = "Raw Change in Larval Fv/Fm (Survived to Timepoint 22)"
  ) +
  facet_wrap(~ ReefMom, nrow = 7) +

  # Theme styling
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.ticks = element_line(color = "black")
  )


print(survivors_raw_change)

# Save the plot to a file
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/survivors_raw_change_plot.png", 
       plot = survivors_raw_change,  
       width = 10,          
       height = 7,          
       dpi = 300)           

```

Combine the 3 plots for size into one figure

```{r}
# Combine the three plots into one figure
combined_plot3 <- fvfm_plot + theme(legend.position = "none") + 
  raw_change_fvfm_plot + theme(legend.position = "none") +
  survivors_raw_change + theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot3)

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_fvfm_raw.png", 
       plot = combined_plot3,  
       width = 10,          
       height = 7,          
       dpi = 300)           

```
Percentage of Larvae with Cells: line graphs
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)  # for plot_layout()

# Replace NA values with zeros in PercentageWithCells column
summary_df2_survived$PercentageWithCells[is.na(summary_df2_survived$PercentageWithCells)] <- 0

summary_df2_survived <- summary_df2_survived %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

summary_df2_survived %>%
  group_by(Timepoint, SymbiontTreatment, Treatment) %>%
  summarise(n = sum(!is.na(PercentageWithCells))) %>%
  print(n = Inf)

str(summary_df2_survived$PercentageWithCells)

# Filter the dataframe to get data for the final timepoint (22)
summary_stats_day22 <- summary_df2_survived %>%
  filter(Timepoint == 22) %>%
  group_by(Timepoint, SymbiontTreatment, Treatment, Cross) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    n = sum(!is.na(PercentageWithCells)),
    sd_pct = ifelse(n > 1, sd(PercentageWithCells, na.rm = TRUE), NA_real_),
    se = ifelse(n > 1, sd_pct / sqrt(n), NA_real_),
    ci_lower = ifelse(n > 1, mean_pct - qt(0.975, df = n - 1) * se, NA_real_),
    ci_upper = ifelse(n > 1, mean_pct + qt(0.975, df = n - 1) * se, NA_real_)
  ) %>%
  ungroup()

# Set factor levels BEFORE plotting, to retain all x-axis categories
summary_stats_day22 <- summary_stats_day22 %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Make a full combination of all groups you'd expect at Timepoint 22
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(summary_stats_day22$SymbiontTreatment),
  Cross = unique(summary_stats_day22$Cross)
)

# Merge with your summary data
summary_stats_day22 <- all_combos %>%
  left_join(summary_stats_day22, by = c("Treatment", "SymbiontTreatment", "Cross")) %>%
  mutate(
    Timepoint = 22,
    mean_pct = ifelse(is.na(mean_pct), 0, mean_pct),
    se = ifelse(is.na(se), 0, se),
    TREATMENT = factor(Treatment, levels = c("Ambient", "31", "35.5"))
  )

summary_stats_day22$SymbiontTreatment <- factor(
  summary_stats_day22$SymbiontTreatment,
  levels = c("C", "D")  # or whatever levels you actually have
)

# Reorder the Treatment factor in the desired order
#final_timepoint_df <- final_timepoint_df %>%
#  mutate(TREATMENT = factor(TREATMENT, levels = c("Ambient", "31", "35.5")))

# Define a custom color palette
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e") # Modify as needed

# Plot mean PercentageWithCells with error bars and custom colors
pct_plot <- ggplot(summary_stats_day22, aes(
  x = Treatment,
  y = mean_pct,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Error bars take the fill color
  geom_errorbar(
    aes(ymin = mean_pct - se, ymax = mean_pct + se, color = Cross),
    width = 0.2
  ) +

  # Points with black outlines and colored fill
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +

  labs(
    x = "Temperature Treatment",
    y = "Mean % With Cells (± s.e.)",
    title = "Mean Percentage With Cells at Final Timepoint (22)"
  ) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

print(pct_plot)

# Create inset plot by Treatment only
final_timepoint_df_inset <- summary_df2_survived %>%
  filter(TIMEPOINT == 22) %>%
  group_by(TREATMENT) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se_pct = sd(PercentageWithCells, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2", "T3")))

mean_pct_plot <- ggplot(final_timepoint_df_inset, aes(x = TREATMENT, y = mean_pct)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_pct - se_pct, ymax = mean_pct + se_pct), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean % With Cells (± s.e.)",
       title = "Mean Percentage With Cells at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

print(mean_pct_plot)

# Create inset plot separated by Treatment and SymbiontTreatment
final_timepoint_df_inset2 <- summary_df3_survived %>%
  filter(DayNumber == 22) %>%
  group_by(TREATMENT, SymbiontTreatment) %>%
  summarise(
    mean_pct = mean(PercentageWithCells, na.rm = TRUE),
    se_pct = sd(PercentageWithCells, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("Ambient", "31", "35.5")))

mean_pct_plot2 <- ggplot(final_timepoint_df_inset2, aes(x = TREATMENT, y = mean_pct, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_pct - se_pct, ymax = mean_pct + se_pct), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean % With Cells (± s.e.)",
       title = "Mean Percentage With Cells at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

print(mean_pct_plot2)

# Combine the two inset plots side by side
library(patchwork)

combined_pct_plot <- mean_pct_plot + mean_pct_plot2 + plot_layout(ncol = 2)
print(combined_pct_plot)

# Save combined plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_mean_percentage_with_cells_inset.png", plot = combined_pct_plot, width = 6, height = 3, dpi = 300)

```
PercentageWithCells from Day 1 to Day 22
```{r}
summary_df2_survived <- summary_df2_survived %>%
  group_by(SymbiontTreatment, Treatment, Cross) %>%
  mutate(PercentageWithCells_adj = PercentageWithCells + 0.01)

# Extract PercentageWithCells at Day 1
cells_day1 <- summary_df2_survived %>%
  filter(Timepoint == 1) %>%
  dplyr::select(Treatment, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay1 = PercentageWithCells_adj)

# Extract PercentageWithCells at Day 22
cells_day22 <- summary_df2_survived %>%
  filter(Timepoint == 22) %>%
  dplyr::select(Treatment, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay22 = PercentageWithCells_adj)

# Join Day 1 and Day 22 data
cells_change_df <- left_join(cells_day1, cells_day22,
                             by = c("Treatment", "ReefMom", "SymbiontTreatment", "Cross"))

# Calculate change
cells_change_df <- cells_change_df <- cells_change_df %>%
  mutate(AcquisitionChangeCells = (CellsDay22) - (CellsDay1))


# Summarize percent change by Treatment, Cross, SymbiontTreatment
perc_change_summary <- cells_change_df %>%
  group_by(Treatment, Cross, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder treatment levels
perc_change_summary <- perc_change_summary %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot
log_change_plot2 <- ggplot(perc_change_summary, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,  # use fill instead of color
  shape = SymbiontTreatment
)) +
  # Colored error bars based on Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross  # error bar matches fill
  ), width = 0.2) +

  # Points: colored fill, black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black outline
  ) +

  # Add reference line
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual color scales
  scale_fill_manual(values = custom_colors) +   # for fill in points
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c(21, 24)) +      # use filled shapes

  # Labels & styling
  labs(
    x = "Temperature (Treatment)",
    y = "Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Show plot
print(log_change_plot2)

# Summarize log change by TREATMENT only
perc_change_inset1 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot_inset1 <- ggplot(perc_change_inset1, aes(x = Treatment, y = mean_perc_change)) +
  geom_point(size = 4, shape = 1, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change), width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Change in % With Cells (± s.e.)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

perc_change_inset2 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT, SymbiontTreatment) %>%
  summarise(
    mean_perc_change = mean(AcquisitionChangeCells, na.rm = TRUE),
    se_perc_change = sd(AcquisitionChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot_inset2 <- ggplot(perc_change_inset2, aes(x = Treatment, y = mean_perc_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_perc_change - se_perc_change,
                    ymax = mean_perc_change + se_perc_change), width = 0.2) +
  labs(x = "Temperature (Treatment)", y = "Log Change in % With Cells (± s.e.)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )


library(patchwork)

# Combine the insets
combined_perc_change_insets <- perc_change_plot_inset1 + perc_change_plot_inset2 + plot_layout(ncol = 2)

# Print
print(combined_perc_change_insets)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_perc_change_insets_pct.png", plot = combined_perc_change_insets,
       width = 6, height = 3, dpi = 300)

```

```{r}
summary_df2_survived <- summary_df2_survived %>%
  group_by(SymbiontTreatment, TREATMENT, Cross, ReefMom) %>%
  mutate(PercentageWithCells_adj = PercentageWithCells + 0.01)

# Extract PercentageWithCells at Day 1
cells_day1 <- summary_df2_survived %>%
  filter(TIMEPOINT == 1) %>%
  dplyr::select(TREATMENT, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay1 = PercentageWithCells_adj)

# Extract PercentageWithCells at Day 22
cells_day22 <- summary_df2_survived %>%
  filter(TIMEPOINT == 22) %>%
  dplyr::select(TREATMENT, ReefMom, SymbiontTreatment, Cross, PercentageWithCells_adj) %>%
  rename(CellsDay22 = PercentageWithCells_adj)

# Join Day 1 and Day 22 data
cells_change_df <- left_join(cells_day1, cells_day22,
                             by = c("TREATMENT", "ReefMom", "SymbiontTreatment", "Cross"))

# Calculate log change
cells_change_df <- cells_change_df <- cells_change_df %>%
  mutate(PercChangeCells_Acq = (CellsDay22) - (CellsDay1))

perc_change_summary2 <- cells_change_df %>%
  filter(TREATMENT != "T3") %>%  # Remove T3 before summary
  group_by(TREATMENT, Cross, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_perc_change = mean(PercChangeCells_Acq, na.rm = TRUE),
    se_perc_change = sd(PercChangeCells_Acq, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

# Reorder treatment levels
perc_change_summary2 <- perc_change_summary2 %>%
  mutate(Treatment = factor(TREATMENT, levels = c("T1", "T2")))

perc_change_plot3 <- ggplot(perc_change_summary2, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Error bars colored by Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross
  ), width = 0.2) +

  # Points with black border and colored fill
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black outline
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Manual scales for fill and shape
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 22)) +

  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +

  facet_wrap(~ ReefMom, nrow = 7) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


# Display the faceted plot
print(perc_change_plot3)

perc_change_plot3 <- ggplot(perc_change_summary2, aes(
  x = Treatment,
  y = mean_perc_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  # Lines connecting points of same Cross and SymbiontTreatment
  geom_line(aes(
    group = interaction(Cross, SymbiontTreatment),
    color = Cross
  ), linewidth = 0.8) +

  # Error bars colored by Cross
  geom_errorbar(aes(
    ymin = mean_perc_change - se_perc_change,
    ymax = mean_perc_change + se_perc_change,
    color = Cross
  ), width = 0.2) +

  # Points with colored fill and black border
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"
  ) +

  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +

  # Scales and labels
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c(21, 24)) +

  labs(
    x = "Temperature (Treatment)",
    y = "Percent Change in % Larvae With Cells (± s.e.)",
    title = "Change in Symbiotic Larvae from Day 1 to 22"
  ) +

  facet_wrap(~ ReefMom, nrow = 7) +

  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )

```
Combine all of the plots
```{r}
# Combine the three plots into one figure
combined_plot_pct <- 
  pct_plot + 
    theme(legend.position = "none") +
  log_change_plot2 + 
    theme(legend.position = "none") +
  perc_change_plot3 + 
    theme(legend.position = "none") +
  plot_layout(ncol = 3)


# Display the combined plot
print(combined_plot_pct)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_pct_updated.png", 
       plot = combined_plot_pct,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```
Line graphs of Cell Density
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

# Replace NA values with zeros in Cell_Density
df_subset$Cell_Density[is.na(df_subset$Cell_Density)] <- 0

# Define crosses (adjust as needed)
df_subset <- df_subset %>%
  mutate(Cross = case_when(
    ReefMom %in% c("BT2", "BT4", "BT8") ~ "CC",
    TRUE ~ "WW"
  ))

# Set factor levels BEFORE plotting, to retain all x-axis categories
df_subset <- df_subset %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Filter for Day 22 and summarize
summary_stats_day22_cd <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Timepoint, SymbiontTreatment, Treatment, Cross) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    n = sum(!is.na(Cell_Density)),
    sd_cd = ifelse(n > 1, sd(Cell_Density, na.rm = TRUE), NA_real_),
    se = ifelse(n > 1, sd_cd / sqrt(n), NA_real_),
    ci_lower = ifelse(n > 1, mean_cd - qt(0.975, df = n - 1) * se, NA_real_),
    ci_upper = ifelse(n > 1, mean_cd + qt(0.975, df = n - 1) * se, NA_real_)
  ) %>%
  ungroup()

# Identify all combinations that should be present
all_combos <- expand.grid(
  Treatment = c("Ambient", "31", "35.5"),
  SymbiontTreatment = unique(summary_stats_day22_cd$SymbiontTreatment),
  Cross = unique(summary_stats_day22_cd$Cross)
)

# Join with existing data
summary_stats_day22_cd <- all_combos %>%
  left_join(summary_stats_day22_cd, by = c("Treatment", "SymbiontTreatment", "Cross")) %>%
  mutate(
    Timepoint = 22,
    mean_cd = ifelse(is.na(mean_cd), 0, mean_cd),
    se = ifelse(is.na(se), 0, se)
  )

# Define custom colors
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")

# Plot main Cell Density plot
cd_plot <- ggplot(summary_stats_day22_cd, aes(
  x = Treatment,
  y = mean_cd,
  fill = Cross,                    # fill color by Cross
  shape = SymbiontTreatment        # shape by symbiont
)) +
  geom_errorbar(
    aes(ymin = mean_cd - se, ymax = mean_cd + se, color = Cross), 
    width = 0.2
  ) +
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"                # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +
  labs(
    x = "Temperature Treatment",
    y = "Mean Cell Density (± s.e.)",
    title = "Mean Cell Density at Final Timepoint (22)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


print(cd_plot)

ggsave("C:/Users/bellb/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/cell_density_mean_plot.png", plot = cd_plot,
       width = 6, height = 3, dpi = 300)

#Mean cell density by Treatment
final_timepoint_df_inset_cd <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    se_cd = sd(Cell_Density, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

mean_cd_plot <- ggplot(final_timepoint_df_inset_cd, aes(x = Treatment, y = mean_cd)) +
  geom_point(size = 4, shape = 1, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_cd - se_cd, ymax = mean_cd + se_cd), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean Cell Density (± s.e.)",
       title = "Mean Cell Density at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )
print(mean_cd_plot)

#Inset by Treatment x SymbiontTreatment
final_timepoint_df_inset_cd2 <- df_subset %>%
  filter(Timepoint == 22) %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(
    mean_cd = mean(Cell_Density, na.rm = TRUE),
    se_cd = sd(Cell_Density, na.rm = TRUE) / sqrt(n())
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

mean_cd_plot2 <- ggplot(final_timepoint_df_inset_cd2, aes(x = Treatment, y = mean_cd, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_cd - se_cd, ymax = mean_cd + se_cd), width = 0.2) +
  labs(x = "Temperature Treatment", y = "Mean Cell Density (± s.e.)",
       title = "Mean Cell Density at Final Timepoint (All Crosses and Symbiont Treatments)") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5)
  )

combined_cd_plot <- mean_cd_plot + mean_cd_plot2 + plot_layout(ncol = 2)
print(combined_cd_plot)

# Save combined inset plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_cell_density_inset.png", plot = combined_cd_plot,
       width = 6, height = 3, dpi = 300)

```
Percent change difference between T0 and T22
```{r}
library(dplyr)
library(ggplot2)
library(patchwork)

# Make sure Cross is added and standardized at the beginning
class(df_subset$Cross)
df_subset$Cross <- factor(df_subset$Cross, levels = c("CC", "WW"))
levels(df_subset$Cross)

#add sign-log
df_subset$sign_log_PercChangeCells <- sign(df_subset$PercChangeCells) * 
                                            log1p(abs(df_subset$PercChangeCells))


# Define custom colors
custom_colors <- c("CC" = "#1f77b4", "WW" = "#ff7f0e")

df_subset$Treatment[is.na(df_subset$Treatment)] <- "Ambient"


df_subset$Treatment <- factor(df_subset$Treatment, levels = c("Ambient", "31", "35.5"))

# Summarize percent change by Treatment, Cross, SymbiontTreatment
log_change_summary <- df_subset %>%
  group_by(Treatment, Cross, SymbiontTreatment) %>%
  summarise(
    mean_log_change = mean(sign_log_PercChangeCells, na.rm = TRUE),
    se_log_change = sd(sign_log_PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  complete(Treatment, Cross, SymbiontTreatment)  # adds missing combinations as NA


# Main plot
log_change_plot_cells <- ggplot(log_change_summary, aes(
  x = Treatment,
  y = mean_log_change,
  fill = Cross,
  shape = SymbiontTreatment
)) +
  geom_errorbar(
    aes(ymin = mean_log_change - se_log_change,
        ymax = mean_log_change + se_log_change,
        color = Cross),
    width = 0.2
  ) +
  geom_point(
    size = 4,
    stroke = 1.2,
    color = "black"  # black border
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +  # for error bars
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # shape for symbionts
  labs(
    x = "Temperature (Treatment)",
    y = "Log Change in Cell Density (± s.e.)",
    title = "Log Change in Cell Density from Timepoint 1 to 22"
  ) +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  )


print(log_change_plot_cells)

#Log change by Treatment only
inset1_df <- df_subset %>%
  filter(Treatment != "35.5") %>% 
  group_by(Treatment) %>%
  summarise(
    mean_log_change = mean(sign_log_PercChangeCells, na.rm = TRUE),
    se_log_change = sd(sign_log_PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

inset1_plot <- ggplot(inset1_df, aes(x = Treatment, y = mean_log_change)) +
  geom_point(size = 4, shape = 1, color = "black", fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_log_change - se_log_change, ymax = mean_log_change + se_log_change), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  labs(title = "Mean Log Change by Treatment", y = "Log Change (± s.e.)", x = NULL) +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    axis.title.y = element_text(size = 10),
    plot.title = element_text(size = 10, hjust = 0.5),
    axis.title.x = element_blank()
  )


# Inset 2: Mean log change by Treatment and SymbiontTreatment (point + error bars)
inset2_df <- df_subset %>%
  filter(Treatment != "35.5") %>%
  group_by(Treatment, SymbiontTreatment) %>%
  summarise(
   mean_log_change = mean(sign_log_PercChangeCells, na.rm = TRUE),
    se_log_change = sd(sign_log_PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

inset2_plot <- ggplot(inset2_df, aes(x = Treatment, y = mean_log_change, shape = SymbiontTreatment)) +
  geom_point(size = 4, fill = NA, stroke = 1.5) +
  geom_errorbar(aes(ymin = mean_log_change - se_log_change, ymax = mean_log_change + se_log_change), width = 0.2) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  labs(x = NULL, y = "Log Change (± s.e.)", title = "Log Change by Treatment × Symbiont") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black", linewidth = 0.5),
    plot.title = element_text(size = 10, hjust = 0.5),
    axis.title.x = element_blank()
  )


combined_cd_plot2 <- inset1_plot + inset2_plot + plot_layout(ncol = 2)
print(combined_cd_plot2)

# Save combined inset plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_plot_cell_density_percchange_inset_log.png", plot = combined_cd_plot2,
       width = 6, height = 3, dpi = 300)


```
Cell Density by ReefMom (Log transformed)
```{r}
# Summarize perc change including ReefMom
log_change_summary_by_reef <- df_subset %>%
  filter(Treatment != "35.5") %>%
  group_by(Treatment, Cross, SymbiontTreatment, ReefMom) %>%
  summarise(
    mean_log_change = mean(sign_log_PercChangeCells, na.rm = TRUE),
    se_log_change = sd(sign_log_PercChangeCells, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5")))

# Plot faceted by ReefMom
log_change_plot_faceted <- ggplot(log_change_summary_by_reef, 
                                   aes(x = Treatment, y = mean_log_change,
                                       fill = Cross, shape = SymbiontTreatment)) +
  # Connect points with same color as fill
  geom_line(aes(group = interaction(Cross, SymbiontTreatment), color = Cross), 
            size = 0.8) +
  
  # Error bars with Cross color
  geom_errorbar(aes(ymin = mean_log_change - se_log_change,
                    ymax = mean_log_change + se_log_change,
                    color = Cross), 
                width = 0.2) +
  
  # Points with black border and colored fill
  geom_point(size = 4, stroke = 1.2, color = "black") +
  
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  
  scale_fill_manual(values = custom_colors) +
  scale_color_manual(values = custom_colors) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # triangle and circle

  labs(x = "Temperature (Treatment)", 
       y = "Log Change in Cell Density (± s.e.)",
       title = "Log Change in Cell Density from Timepoint 1 to 22") +
  
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(color = "black"),
    axis.ticks = element_line(color = "black")
  ) +
  facet_wrap(~ ReefMom, nrow = 7)

print(log_change_plot_faceted)


```

Combine all of the plots
```{r}
# Combine the three plots into one figure
combined_plot_cd <- cd_plot + 
    theme(legend.position = "none") +
  log_change_plot_cells + 
    theme(legend.position = "none") + log_change_plot_faceted + 
    theme(legend.position = "none") +
  plot_layout(ncol = 3)  # Stack them vertically (1 column)

# Display the combined plot
print(combined_plot_cd)

ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/combined_plot_cd_log.png", 
       plot = combined_plot_cd,  # Save the most recent plot
       width = 10,          # Set the width of the plot (in inches)
       height = 7,          # Set the height of the plot (in inches)
       dpi = 300)           # Set the resolution (300 dpi is good for publications)  
```

##Percentage of Larvae that Acquired Cells with Source Reef
```{r}
#Percentage with Cells ############################################

# Ensure factors are ordered
library(dplyr)

ipam <- ipam %>%
  mutate(
    TEMP_num = as.numeric(as.character(TEMP)),  # convert TEMP to numeric safely
    TEMP = case_when(
      near(TEMP_num, 27.5) ~ "Ambient",
      near(TEMP_num, 31)   ~ "31",
      near(TEMP_num, 35.5) ~ "35.5",
      TRUE ~ as.character(TEMP_num)
    ),
    Reef = recode(Reef, "Bruboodjoo" = "CC", "Tantabiddi" = "WW"),
    SymbiontTreatment = factor(zoox, levels = c("C", "D")),
    Treatment = factor(TEMP, levels = c("Ambient", "31", "35.5")),
    Cross = factor(Reef, levels = c("CC", "WW"))
  ) %>%
  dplyr::select(-TEMP_num)  # optional: remove temporary numeric column

#df_subset$logChangeCells <- log(df_subset$PercChangeCells + 1)

#check how many observations per group
table(ipam$SymbiontTreatment, ipam$Cross, ipam$Treatment)

#include replicates
ipam <- ipam %>%
  rename(Timepoint = TIMEPOINT)

ipam <- ipam %>%
  mutate(Timepoint = as.character(Timepoint)) %>%
  left_join(
    df_with_extremes %>%
      mutate(Timepoint = as.character(Timepoint)) %>%
      dplyr::select(UniqueID, Timepoint, Replicate) %>%
      distinct(),
    by = c("UniqueID", "Timepoint")
  )

summary(ipam[, c("PercChangeCells", "SymbiontTreatment", "Cross", "Treatment")])

#set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)

#model
model_perc <- MCMCglmm(
  PercChangeCells ~ SymbiontTreatment * Cross * Treatment,
  random = ~ Replicate,
  data = ipam,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_perc)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_perc$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

# 1. Create prediction grid
newdat_perc <- expand.grid(
  SymbiontTreatment = levels(ipam$SymbiontTreatment),
  Cross = levels(ipam$Cross),
  Treatment = levels(ipam$Treatment)  
)

newdat_perc$SymbiontTreatment <- factor(newdat_perc$SymbiontTreatment, levels = levels(ipam$SymbiontTreatment))
newdat_perc$Cross <- factor(newdat_perc$Cross, levels = levels(ipam$Cross))
newdat_perc$Treatment <- factor(newdat_perc$Treatment, levels = levels(ipam$Treatment))

lapply(newdat_perc[, c("SymbiontTreatment", "Cross", "Treatment")], function(x) length(unique(x)))

# 2. Generate model matrix
X_full_subset <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat_perc)
X_subset <- X_full_subset[, colnames(model_perc$Sol), drop = FALSE]

# 3. Posterior predictions
pred_matrix_subset <- X_subset %*% t(model_perc$Sol)
newdat_perc$pred_mean <- rowMeans(pred_matrix_subset)
newdat_perc$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat_perc$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat_perc$significant <- !(newdat_perc$lower < 0 & newdat_perc$upper > 0)
newdat_perc$label_combined <- paste0(round(newdat_perc$pred_mean, 2),
                                       ifelse(newdat_perc$significant, "*", ""))

# 4. Calculate pMCMC values: two-tailed test for each posterior distribution
newdat_perc$pMCMC <- apply(pred_matrix_subset, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

# 5. Compare to control (Ambient x CC x C)
control_post <- pred_matrix_subset[1, ]  # 1st row = control

diff_matrix_control <- sweep(pred_matrix_subset, 2, control_post, FUN = "-")

pMCMC_control <- apply(diff_matrix_control, 1, function(x) {
  2 * min(mean(x > 0), mean(x < 0))
})

diff_summary_control <- t(apply(diff_matrix_control, 1, function(x) {
  q <- quantile(x, probs = c(0.025, 0.975))
  c(mean_diff = mean(x), lower = q[1], upper = q[2])
}))

diff_summary_control <- as.data.frame(diff_summary_control)
colnames(diff_summary_control) <- c("mean_control", "lower_control", "upper_control")
diff_summary_control$pMCMC_control <- pMCMC_control

diff_summary_control$signif_label_control <- case_when(
  pMCMC_control < 0.005 ~ "**",
  pMCMC_control < 0.05  ~ "*",
  TRUE                  ~ ""
)

diff_summary_control$label_combined_control <- paste0(
  round(diff_summary_control$mean_control, 2),
  diff_summary_control$signif_label_control
)

diff_summary_control$significant_vs_control <- with(
  diff_summary_control,
  lower_control > 0 | upper_control < 0
)

# 6. Combine and plot
newdat_perc <- cbind(newdat_perc, diff_summary_control)

ggplot(newdat_perc, aes(x = Treatment, y = Cross, fill = mean_control)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined_control), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted cell change %") +
  theme_minimal() +
  labs(title = "Predicted Change in Cell Density (No 35.5)",
       x = "Treatment", y = "Host Genotype")

# 7. Posterior predictions for each Treatment
pred_matrix_subset <- X_s %*% t(model_perc$Sol)
rownames(pred_matrix_subset) <- newdat_perc$Treatment

# All pairwise comparisons
treatments <- levels(ipam$Treatment)
pairwise_comparisons <- t(combn(treatments, 2))  # all unique pairs

pairwise_results <- apply(pairwise_comparisons, 1, function(pair) {
  t1 <- pair[1]
  t2 <- pair[2]
  diff <- pred_matrix_subset[t2, ] - pred_matrix_subset[t1, ]
  
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  q <- quantile(diff, probs = c(0.025, 0.975))
  
  data.frame(
    contrast = paste(t2, "–", t1),
    mean_diff = mean(diff),
    lower = q[1],
    upper = q[2],
    pMCMC = pMCMC,
    signif = case_when(
      pMCMC < 0.005 ~ "**",
      pMCMC < 0.05  ~ "*",
      TRUE          ~ ""
    )
  )
})

pairwise_results <- do.call(rbind, pairwise_results)

# 8. Now just restrict to T1-T4
ipam_subset <- ipam %>%
  filter(Timepoint >= 1 & Timepoint <= 4)

model_perc <- MCMCglmm(
  PercChangeCells ~ SymbiontTreatment * Cross * Treatment,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)
pred_matrix_subset <- X_s %*% t(model_perc$Sol)
rownames(pred_matrix_subset) <- newdat_perc$Treatment

# All pairwise comparisons
treatments <- levels(ipam$Treatment)
pairwise_comparisons <- t(combn(treatments, 2))  # all unique pairs

pairwise_results <- apply(pairwise_comparisons, 1, function(pair) {
  t1 <- pair[1]
  t2 <- pair[2]
  diff <- pred_matrix_subset[t2, ] - pred_matrix_subset[t1, ]
  
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  q <- quantile(diff, probs = c(0.025, 0.975))
  
  data.frame(
    contrast = paste(t2, "–", t1),
    mean_diff = mean(diff),
    lower = q[1],
    upper = q[2],
    pMCMC = pMCMC,
    signif = case_when(
      pMCMC < 0.005 ~ "**",
      pMCMC < 0.05  ~ "*",
      TRUE          ~ ""
    )
  )
})

pairwise_results <- do.call(rbind, pairwise_results)

#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = ipam,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_perc_Treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = ipam, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_perc_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = ipam, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_perc_family <- MCMCglmm(PercChangeCells ~ Cross, 
                       random = ~ Replicate , 
                       data = ipam, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, ipam, full_formula)
r2_Treatment <- calc_marginal_R2(mod_perc_Treatment, ipam, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_perc_symbiont, ipam, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_perc_family, ipam, PercChangeCells ~ Cross)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_Treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, ipam, full_formula)
r2_Treatment <- calc_marginal_conditional_R2(mod_perc_Treatment, ipam, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_perc_symbiont, ipam, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_perc_family, ipam, PercChangeCells ~ Cross)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_Treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_Treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")

# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_Treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_Treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_Treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_Treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_Treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_Treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)
```

##ONLY SURVIVORS: Percentage of Larvae that Acquired Cells with Source Cross
```{r}
#Percentage with Cells ############################################

# Step 1: Get UniqueIDs present at Timepoint 22
ids_at_22 <- ipam %>%
  filter(Timepoint == 22) %>%
  pull(UniqueID) %>%
  unique()

# Step 2: Subset ipam to include only those UniqueIDs
ipam_subset <- ipam %>%
  filter(UniqueID %in% ids_at_22)

# Ensure factors are ordered
ipam_subset$Treatment <- factor(ipam_subset$Treatment, 
                                     levels = c("Ambient", "31", "35.5"))
ipam_subset$Cross <- factor(ipam_subset$Cross, 
                                     levels = c("CC", "WW"))
ipam_subset$SymbiontTreatment <- factor(ipam_subset$SymbiontTreatment, 
                                     levels = c("C", "D"))

#Remove 35.5 because larvae didn't survive
ipam_subset <- ipam_subset %>% 
  filter(Treatment != "35.5") %>%
  droplevels()

#check how many observations per group
table(ipam_subset$SymbiontTreatment, ipam_subset$Cross, ipam_subset$Treatment)

#set prior
prior <- list(
  R = list(V = 1, nu = 0.002),  # Residual variance (Gaussian default)
  G = list(
    G1 = list(V = 1, nu = 0.002)  # Random effect for Replicate
  )
)

#model
model_perc <- MCMCglmm(
  PercChangeCells ~ SymbiontTreatment * Cross * Treatment,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

summary(model_perc)

#Check chain convergence and mixing
library(coda)
mcmc_obj <- as.mcmc(model_perc$Sol)
plot(mcmc_obj)              # Trace and density plots
autocorr.diag(mcmc_obj)     # Autocorrelation
effectiveSize(mcmc_obj)     # Effective sample size

newdat_perc2 <- expand.grid(
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment),
  Cross = levels(ipam_subset$Cross),
  Treatment = levels(ipam_subset$Treatment)  
)

newdat_perc2$SymbiontTreatment <- factor(newdat_perc2$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))
newdat_perc2$Cross <- factor(newdat_perc2$Cross, levels = levels(ipam_subset$Cross))
newdat_perc2$Treatment <- factor(newdat_perc2$Treatment, levels = levels(ipam_subset$Treatment))

lapply(newdat_perc2[, c("SymbiontTreatment", "Cross", "Treatment")], function(x) length(unique(x)))


X_full_subset <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat_perc2)
X_subset <- X_full_subset[, colnames(model_perc$Sol), drop = FALSE]

pred_matrix_subset <- X_subset %*% t(model_perc$Sol)
newdat_perc2$pred_mean <- rowMeans(pred_matrix_subset)
newdat_perc2$lower <- apply(pred_matrix_subset, 1, quantile, probs = 0.025)
newdat_perc2$upper <- apply(pred_matrix_subset, 1, quantile, probs = 0.975)
newdat_perc2$significant <- !(newdat_perc2$lower < 0 & newdat_perc2$upper > 0)
newdat_perc2$label_combined <- paste0(round(newdat_perc2$pred_mean, 2),
                                       ifelse(newdat_perc2$significant, "*", ""))

ggplot(newdat_perc2, aes(x = Treatment, y = Cross, fill = pred_mean)) +
  geom_tile(color = "white") +
  geom_text(aes(label = label_combined), color = "black", size = 4) +
  facet_wrap(~ SymbiontTreatment) +
  scale_fill_viridis_c(name = "Predicted cell change %") +
  theme_minimal() +
  labs(title = "Predicted Change in Cell Density (No 35.5)",
       x = "Treatment", y = "Host Genotype")


#############################
### Modeling variables separate for each health metric to get relative contributions ###
#PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Load MCMCglmm if not already loaded
library(MCMCglmm)

# Your prior (make sure it's defined appropriately)
# Example placeholder:
prior <- list(R = list(V = 1, nu = 0.002), G = list(G1 = list(V = 1, nu = 0.002)))

# Full model formula
full_formula <- PercChangeCells ~ SymbiontTreatment * Cross * Treatment

# Fit the full model
model_full <- MCMCglmm(full_formula,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# Fit single fixed effect models
mod_perc_Treatment <- MCMCglmm(PercChangeCells ~ Treatment, 
                          random = ~ Replicate , 
                          data = ipam_subset, 
                          family = "gaussian", 
                          prior = prior, 
                          nitt = 50000, 
                          burnin = 10000, 
                          thin = 20)

mod_perc_symbiont <- MCMCglmm(PercChangeCells ~ SymbiontTreatment, 
                         random = ~ Replicate , 
                         data = ipam_subset, 
                         family = "gaussian", 
                         prior = prior, 
                         nitt = 50000, 
                         burnin = 10000, 
                         thin = 20)

mod_perc_family <- MCMCglmm(PercChangeCells ~ Cross, 
                       random = ~ Replicate , 
                       data = ipam_subset, 
                       family = "gaussian", 
                       prior = prior, 
                       nitt = 50000, 
                       burnin = 10000, 
                       thin = 20)

# Helper function to calculate marginal R²
calc_marginal_R2 <- function(model, data, fixed_formula) {
  # Build model matrix for fixed effects (includes intercept)
  X <- model.matrix(fixed_formula, data = data)
  
  # Extract posterior samples of fixed effects
  Sol <- model$Sol
  
  # Identify which columns in Sol correspond to fixed effects (including intercept)
  fixed_effect_names <- colnames(Sol)
  
  # Align columns of X and Sol by name
  # Remove any columns in X not present in Sol (unlikely, but safe)
  cols_to_keep <- colnames(X) %in% fixed_effect_names
  X_sub <- X[, cols_to_keep, drop = FALSE]
  
  # Subset Sol to columns matching X_sub
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  # Now dimensions should align for multiplication: X_sub (n x p), t(Sol_sub) (p x samples)
  
  if (ncol(X_sub) != ncol(Sol_sub)) {
    stop("Mismatch between fixed effect columns in design matrix and posterior samples.")
  }
  
  # Calculate linear predictor samples: each row = one observation,
  # each column = one MCMC iteration sample
  linpred_samples <- X_sub %*% t(Sol_sub)  # dimensions: nrow(X_sub) x nrow(Sol_sub)
  
  # Variance of predicted values for each MCMC iteration
  var_fixed <- apply(linpred_samples, 2, var)
  
  # Variance components for random effects and residual
  # Here, adjust grep pattern if you have multiple random effects or different names
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  # Marginal R² per iteration
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  
  # Return mean and 95% credible interval
  c(
    mean = mean(R2_marginal),
    lower = quantile(R2_marginal, 0.025),
    upper = quantile(R2_marginal, 0.975)
  )
}

# Calculate marginal R2 for all models
r2_full <- calc_marginal_R2(model_full, ipam_subset, full_formula)
r2_Treatment <- calc_marginal_R2(mod_perc_Treatment, ipam_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_R2(mod_perc_symbiont, ipam_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_R2(mod_perc_family, ipam_subset, PercChangeCells ~ Cross)

# Print results
cat("Marginal R² for full model (all fixed effects + interactions):\n")
print(r2_full)
cat("\nMarginal R² for Treatment only model:\n")
print(r2_Treatment)
cat("\nMarginal R² for SymbiontTreatment only model:\n")
print(r2_symbiont)
cat("\nMarginal R² for Cross only model:\n")
print(r2_cross2)


calc_marginal_conditional_R2 <- function(model, data, fixed_formula) {
  X <- model.matrix(fixed_formula, data = data)
  Sol <- model$Sol
  
  cols_to_keep <- colnames(X) %in% colnames(Sol)
  X_sub <- X[, cols_to_keep, drop = FALSE]
  Sol_sub <- Sol[, colnames(X_sub), drop = FALSE]
  
  if (ncol(X_sub) != ncol(Sol_sub)) stop("Mismatch in fixed effect columns.")
  
  linpred_samples <- X_sub %*% t(Sol_sub)
  var_fixed <- apply(linpred_samples, 2, var)
  
  var_random <- rowSums(model$VCV[, grep("Replicate", colnames(model$VCV)), drop = FALSE])
  var_resid <- model$VCV[, "units"]
  
  R2_marginal <- var_fixed / (var_fixed + var_random + var_resid)
  R2_conditional <- (var_fixed + var_random) / (var_fixed + var_random + var_resid)
  
  result <- rbind(
    marginal = c(mean = mean(R2_marginal), lower = quantile(R2_marginal, 0.025), upper = quantile(R2_marginal, 0.975)),
    conditional = c(mean = mean(R2_conditional), lower = quantile(R2_conditional, 0.025), upper = quantile(R2_conditional, 0.975))
  )
  
  print(result)  # <--- add this line for debugging
  return(result)
}


library(ggplot2)

# Calculate and store results once
r2_full <- calc_marginal_conditional_R2(model_full, ipam_subset, full_formula)
r2_Treatment <- calc_marginal_conditional_R2(mod_perc_Treatment, ipam_subset, PercChangeCells ~ Treatment)
r2_symbiont <- calc_marginal_conditional_R2(mod_perc_symbiont, ipam_subset, PercChangeCells ~ SymbiontTreatment)
r2_cross2 <- calc_marginal_conditional_R2(mod_perc_family, ipam_subset, PercChangeCells ~ Cross)

# Check if they have the expected rownames
print(rownames(r2_full))      # Should be: "marginal" "conditional"
print(rownames(r2_Treatment)) # Same
print(rownames(r2_symbiont))  # Same
print(rownames(r2_cross2))    # Same

colnames(r2_full) <- c("mean", "lower", "upper")
colnames(r2_Treatment) <- c("mean", "lower", "upper")
colnames(r2_symbiont) <- c("mean", "lower", "upper")
colnames(r2_cross2) <- c("mean", "lower", "upper")

# Now build the dataframe using the stored results
results_df <- data.frame(
  Effect = c("Full Model", "Treatment", "SymbiontTreatment", "Cross"),

  Marginal_Mean = c(
    r2_full["marginal", "mean"],
    r2_Treatment["marginal", "mean"],
    r2_symbiont["marginal", "mean"],
    r2_cross2["marginal", "mean"]
  ),
  Marginal_Lower = c(
    r2_full["marginal", "lower"],
    r2_Treatment["marginal", "lower"],
    r2_symbiont["marginal", "lower"],
    r2_cross2["marginal", "lower"]
  ),
  Marginal_Upper = c(
    r2_full["marginal", "upper"],
    r2_Treatment["marginal", "upper"],
    r2_symbiont["marginal", "upper"],
    r2_cross2["marginal", "upper"]
  ),

  Conditional_Mean = c(
    r2_full["conditional", "mean"],
    r2_Treatment["conditional", "mean"],
    r2_symbiont["conditional", "mean"],
    r2_cross2["conditional", "mean"]
  ),
  Conditional_Lower = c(
    r2_full["conditional", "lower"],
    r2_Treatment["conditional", "lower"],
    r2_symbiont["conditional", "lower"],
    r2_cross2["conditional", "lower"]
  ),
  Conditional_Upper = c(
    r2_full["conditional", "upper"],
    r2_Treatment["conditional", "upper"],
    r2_symbiont["conditional", "upper"],
    r2_cross2["conditional", "upper"]
  )
)

print(results_df)


# Calculate relative contributions based on Marginal R² Mean
results_df$Relative_Contribution <- results_df$Marginal_Mean / results_df$Marginal_Mean[results_df$Effect == "Full Model"]
results_df$Relative_Contribution_Percent <- round(100 * results_df$Relative_Contribution, 1)

# Display selected columns, including Conditional R²
summary_df <- results_df[, c("Effect", 
                             "Marginal_Mean", 
                             "Conditional_Mean", 
                             "Relative_Contribution_Percent")]

# Print
print(summary_df)

##########
# Pairwise comparisons for survivors (Percent Change)
##########

# Create new data frame of combinations
newdat <- expand.grid(
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment),
  Cross = levels(ipam_subset$Cross),
  Treatment = levels(ipam_subset$Treatment)
)

# Ensure same factor levels as in model
newdat$SymbiontTreatment <- factor(newdat$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))
newdat$Cross <- factor(newdat$Cross, levels = levels(ipam_subset$Cross))
newdat$Treatment <- factor(newdat$Treatment, levels = levels(ipam_subset$Treatment))

# For clarity in output
newdat$group <- with(newdat, paste(SymbiontTreatment, Cross, Treatment, sep = "_"))

# Design matrix must match the fixed effects structure in the full model
X <- model.matrix(~ SymbiontTreatment * Cross * Treatment, data = newdat)

# Match columns exactly
X <- X[, colnames(model_perc$Sol), drop = FALSE]

# Get posterior predictions
pred_matrix <- X %*% t(model_perc$Sol)

# All pairwise group combinations
group_combos <- combn(1:nrow(newdat), 2, simplify = FALSE)

# Compute posterior difference, 95% CI, and pMCMC
pairwise_results <- lapply(group_combos, function(idx) {
  i <- idx[1]
  j <- idx[2]
  diff <- pred_matrix[i, ] - pred_matrix[j, ]
  ci <- quantile(diff, probs = c(0.025, 0.975))
  pMCMC <- 2 * min(mean(diff > 0), mean(diff < 0))
  
  data.frame(
    group1 = newdat$group[i],
    group2 = newdat$group[j],
    mean_diff = mean(diff),
    lower = ci[1],
    upper = ci[2],
    pMCMC = pMCMC,
    significant = ci[1] > 0 | ci[2] < 0
  )
})

pairwise_df <- do.call(rbind, pairwise_results)

ggplot(pairwise_df, aes(group1, group2, fill = mean_diff)) +
  geom_tile() +
  geom_text(aes(label = ifelse(significant, "*", "")), color = "white") +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(title = "Pairwise Differences in log(Cell Density Change)",
       x = "Group 1", y = "Group 2")

# Add back-transformed columns and format them nicely
pairwise_summary <- pairwise_df %>%
  mutate(
    mean_diff_bt = exp(mean_diff) - 1,
    lower_bt = exp(lower) - 1,
    upper_bt = exp(upper) - 1,
    mean_diff_bt_fmt = formatC(mean_diff_bt, format = "e", digits = 2),
    lower_bt_fmt = formatC(lower_bt, format = "e", digits = 2),
    upper_bt_fmt = formatC(upper_bt, format = "e", digits = 2),
    significant_label = ifelse(significant, "*", "")
  ) %>%
  select(
    group1, group2,
    mean_diff, lower, upper,
    mean_diff_bt_fmt, lower_bt_fmt, upper_bt_fmt,
    pMCMC, significant_label
  ) %>%
  rename(
    `Group 1` = group1,
    `Group 2` = group2,
    `Mean Diff (log)` = mean_diff,
    `Lower 95% CI (log)` = lower,
    `Upper 95% CI (log)` = upper,
    `Mean Diff (back-transformed)` = mean_diff_bt_fmt,
    `Lower 95% CI (back-transformed)` = lower_bt_fmt,
    `Upper 95% CI (back-transformed)` = upper_bt_fmt,
    `pMCMC` = pMCMC,
    `Significant` = significant_label
  )

write.csv(pairwise_summary, "C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/pairwise_summary_table_perc_with_cells.csv", row.names = FALSE)

###############################################################
# Now with just Treatment and Cross

# Fit the model
model_tc <- MCMCglmm(
  PercChangeCells ~ Treatment * Cross,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

# New data grid for predictions
newdat_tc <- expand.grid(
  Treatment = levels(ipam_subset$Treatment),
  Cross = levels(ipam_subset$Cross)
)

newdat_tc$Treatment <- factor(newdat_tc$Treatment, levels = levels(ipam_subset$Treatment))
newdat_tc$Cross <- factor(newdat_tc$Cross, levels = levels(ipam_subset$Cross))

# Model matrix for fixed effects (match model columns)
X_tc <- model.matrix(~ Treatment * Cross, data = newdat_tc)

# Subset posterior samples for fixed effects
common_cols <- intersect(colnames(model_tc$Sol), colnames(X_tc))
X_tc_aligned <- X_tc[, common_cols, drop = FALSE]
Sol_tc <- model_tc$Sol[, common_cols, drop = FALSE]

# Calculate predicted values per MCMC iteration
pred_mat_tc <- X_tc_aligned %*% t(Sol_tc)  # rows = groups, cols = MCMC samples

# Calculate pairwise differences for all combinations
pairwise_diff_tc <- combn(nrow(newdat_tc), 2, function(i) {
  diff_samples <- pred_mat_tc[i[1], ] - pred_mat_tc[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_tc$Treatment[i[1]]), as.character(newdat_tc$Cross[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_tc$Treatment[i[2]]), as.character(newdat_tc$Cross[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()

# Add significance flag
pairwise_diff_tc <- pairwise_diff_tc %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_tc)

###############################################################
# Now with just Treatment and SymbiontTreatment
model_ts <- MCMCglmm(
  PercChangeCells ~ Treatment * SymbiontTreatment,
  random = ~ Replicate,
  data = ipam_subset,
  family = "gaussian",
  prior = prior,
  nitt = 50000,
  burnin = 10000,
  thin = 20
)

newdat_ts <- expand.grid(
  Treatment = levels(ipam_subset$Treatment),
  SymbiontTreatment = levels(ipam_subset$SymbiontTreatment)
)

newdat_ts$Treatment <- factor(newdat_ts$Treatment, levels = levels(ipam_subset$Treatment))
newdat_ts$SymbiontTreatment <- factor(newdat_ts$SymbiontTreatment, levels = levels(ipam_subset$SymbiontTreatment))

X_ts <- model.matrix(~ Treatment * SymbiontTreatment, data = newdat_ts)
common_cols <- intersect(colnames(model_ts$Sol), colnames(X_ts))
X_ts_aligned <- X_ts[, common_cols, drop = FALSE]
Sol_ts <- model_ts$Sol[, common_cols, drop = FALSE]

pred_mat_ts <- X_ts_aligned %*% t(Sol_ts) 

# Pairwise differences same approach as above
pairwise_diff_ts <- combn(nrow(newdat_ts), 2, function(i) {
  diff_samples <- pred_mat_ts[i[1], ] - pred_mat_ts[i[2], ]
  data.frame(
    group1 = paste(as.character(newdat_ts$Treatment[i[1]]), as.character(newdat_ts$SymbiontTreatment[i[1]]), sep = "_"),
    group2 = paste(as.character(newdat_ts$Treatment[i[2]]), as.character(newdat_ts$SymbiontTreatment[i[2]]), sep = "_"),
    mean_diff = mean(diff_samples),
    lower = quantile(diff_samples, 0.025),
    upper = quantile(diff_samples, 0.975),
    pMCMC = 2 * min(mean(diff_samples > 0), mean(diff_samples < 0))
  )
}, simplify = FALSE) %>% bind_rows()


pairwise_diff_ts <- pairwise_diff_ts %>%
  mutate(significant = (lower > 0 | upper < 0))

head(pairwise_diff_ts)
```
### Get CIs of Hazard Ratios ###
```{r}
library(ggplot2)
library(dplyr)

# Time grid and model coefficients
time_grid <- 1:22
coefs <- coef(cox_td_3way)
vcov_mat <- vcov(cox_td_3way)

# Define all combination
combinations <- expand.grid(
  SymbiontTreatment = c("C", "D"),
  Temperature = c("31", "35.5"),
  Cross_2 = c("BxB", "TxT")
)

# Function to compute HR + 95% CI
compute_hr_ci <- function(symbiont, temp, cross, coefs, vcov_mat, time_grid) {
  
  tt_term <- if(temp == "31") "tt(Treat31)" else "tt(Treat35.5)"
  
  coef_vec <- rep(0, length(coefs))
  names(coef_vec) <- names(coefs)
  
  coef_vec[tt_term] <- 1
  
  sym_tt <- paste0("SymbiontTreatmentD:", tt_term)
  if(symbiont == "D" & sym_tt %in% names(coefs)) coef_vec[sym_tt] <- 1
  
  cross_tt <- paste0("Cross_2TxT:", tt_term)
  if(cross == "TxT" & cross_tt %in% names(coefs)) coef_vec[cross_tt] <- 1
  
  threeway <- paste0("SymbiontTreatmentD:Cross_2TxT:", tt_term)
  if(symbiont == "D" & cross == "TxT" & threeway %in% names(coefs)) coef_vec[threeway] <- 1
  
  idx <- which(coef_vec != 0)
  
  log_hr <- sapply(time_grid, function(t) sum(coef_vec[idx] * log(t)))
  se_log_hr <- sapply(time_grid, function(t) sqrt(sum((log(t)^2) * diag(vcov_mat[idx, idx]))))
  
  data.frame(
    Day = time_grid,
    HR = exp(log_hr),
    Lower = exp(log_hr - 1.96 * se_log_hr),
    Upper = exp(log_hr + 1.96 * se_log_hr)
  )
}

# --- 4️⃣ Compute HR + CIs for all combinations ---
df_hr_ci <- bind_rows(lapply(1:nrow(combinations), function(i) {
  df <- compute_hr_ci(
    symbiont = combinations$SymbiontTreatment[i],
    temp = combinations$Temperature[i],
    cross = combinations$Cross_2[i],
    coefs = coefs,
    vcov_mat = vcov_mat,
    time_grid = time_grid
  )
  
  # Find last observed death for this group
 max_day <- max(metadata_clean$Timepoint[
  as.character(metadata_clean$SymbiontTreatment) == combinations$SymbiontTreatment[i] &
  as.character(metadata_clean$Treatment) == combinations$Temperature[i] &
  as.character(metadata_clean$Cross_2) == combinations$Cross_2[i] &
  metadata_clean$Status == 1
])
  
  df <- df %>% filter(Day <= max_day)
  df$Group <- paste(combinations$Temperature[i], combinations$SymbiontTreatment[i], combinations$Cross_2[i], sep = "°C ")
  df
}))

# Remove rows corresponding to 35.5°C beyond day 6
df_hr_ci_trim <- df_hr_ci[-c(51:66, 73:88, 139:154, 161:176), ]

# --- 5️⃣ Plot ---
ggplot(df_hr_ci_trim, aes(x = Day, y = HR, color = Group, fill = Group)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = Lower, ymax = Upper), alpha = 0.2, color = NA) +
  labs(x = "Time (days)", y = "Hazard Ratio vs Ambient") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1") +
  scale_fill_brewer(palette = "Set1")

# Recode 0% survival as Dead and ensure column is character
metadata_clean_T6 <- metadata_clean %>%
  mutate(
    Alive..Dead..Sampled = as.character(Alive..Dead..Sampled),
    Alive..Dead..Sampled = ifelse(Percent_Survival_atend == 0, "Dead", Alive..Dead..Sampled),
    Alive..Dead..Sampled = ifelse(Alive..Dead..Sampled == "Alive", "Alive", "Dead")
  )

# Subset to 35.5°C and first 5 days
subset_35 <- metadata_clean_T6 %>%
  filter(Treatment == "35.5", Timepoint <= 5)

# Summarize percent survival at each timepoint
survival_timecourse <- subset_35 %>%
  group_by(SymbiontTreatment, Cross_2, Timepoint) %>%
  summarise(
    n_total = n(),
    n_alive = sum(Alive..Dead..Sampled == "Alive"),
    survival_prop = n_alive / n_total
  ) %>%
  ungroup()

survival_timecourse


```

### Experimental DHW Barplot ###
```{r}
library(ggplot2)
library(dplyr)

# Site info
sites <- data.frame(
  Site = c("B", "T"),
  SiteName = c("Bruboodjoo", "Tantabiddi"),
  MMM = c(27, 28)
)

# Experimental temperatures
exp_temps <- c(31, 35.5)
days <- 1:22

# Function to compute DHW at each day
compute_dhw <- function(temp, mmm, day) {
  anomaly <- temp - mmm
  dhw <- ifelse(anomaly > 0, anomaly * (day/7), 0)
  return(dhw)
}

# Create all combinations
df_dhw <- expand.grid(
  Site = sites$Site,
  Temp = exp_temps,
  Day = days
) %>%
  left_join(sites, by = "Site") %>%
  rowwise() %>%
  mutate(DHW = compute_dhw(Temp, MMM, Day)) %>%
  ungroup() %>%
  mutate(Label = paste(SiteName, "×", Temp, "°C"))

df_dhw <- df_dhw %>%
  mutate(
    Site = recode(Site, "B" = "Bruboodjoo", "T" = "Tantabiddi"),
    HotSpot = pmax(Temp - MMM, 0),  # HotSpot definition
    Category = case_when(
      HotSpot <= 0 ~ "No Stress",
      HotSpot > 0 & HotSpot < 1 & DHW == 0 ~ "Bleaching Watch",
      HotSpot >= 1 & DHW < 4 ~ "Bleaching Warning",
      HotSpot >= 1 & DHW >= 4 & DHW < 8 ~ "Bleaching Alert Level 1",
      HotSpot >= 1 & DHW >= 8 & DHW < 12 ~ "Bleaching Alert Level 2",
      HotSpot >= 1 & DHW >= 12 & DHW < 16 ~ "Bleaching Alert Level 3",
      HotSpot >= 1 & DHW >= 16 & DHW < 20 ~ "Bleaching Alert Level 4",
      HotSpot >= 1 & DHW >= 20 ~ "Bleaching Alert Level 5",
      TRUE ~ "Unclassified"
    ),
    # Force factor levels to match fill order
    Category = factor(Category, levels = c(
      "No Stress",
      "Bleaching Watch",
      "Bleaching Warning",
      "Bleaching Alert Level 1",
      "Bleaching Alert Level 2",
      "Bleaching Alert Level 3",
      "Bleaching Alert Level 4",
      "Bleaching Alert Level 5"
    ))
  )

df_final <- df_dhw %>%
  filter(Day == max(Day))

ggplot(df_dhw, aes(x = Day, y = DHW, fill = Category)) +
  # facet-specific rectangle for 31 °C
  geom_rect(data = df_dhw %>% filter(Temp == 31),
            inherit.aes = FALSE,
            aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf),
            color = "#fee08b", fill = NA, linewidth = 1.2) +
  # facet-specific rectangle for 35.5 °C
  geom_rect(data = df_dhw %>% filter(Temp == 35.5),
            inherit.aes = FALSE,
            aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf),
            color = "#d53e4f", fill = NA, linewidth = 1.2) +
  geom_col(position = "dodge") +
  facet_grid(Site ~ Temp) +
  labs(x = "Days at Experimental Temperature",
       y = "Degree Heating Weeks (DHW)",
       fill = "NOAA Category") +
  scale_fill_manual(values = c(
    "No Stress" = "grey90",
    "Bleaching Watch" = "#a6cee3",
    "Bleaching Warning" = "#1f78b4",
    "Bleaching Alert Level 1" = "#fee08b",
    "Bleaching Alert Level 2" = "#f46d43",
    "Bleaching Alert Level 3" = "#d73027",
    "Bleaching Alert Level 4" = "#7f0000",
    "Bleaching Alert Level 5" = "black"
  ), drop = FALSE) +
  theme_minimal(base_size = 14)

ggsave("C:/Users/jc980786/OneDrive - James Cook University/GitHub/Larval.Infect.Exp/figures/DHW_plot.png", width = 8, height = 6, dpi = 300)
```
########## Summary figure #############
Line graphs of all traits (means)
```{r}

###  Size  ###
summary_df_size_grouped <- df_with_extremes %>%
  mutate(
    Reef = Cross_2,
    DayNumber = Timepoint
  ) %>%
  group_by(DayNumber, SymbiontTreatment) %>%
  summarise(
    mean_Area = mean(Area..mm.2., na.rm = TRUE),
    sd_Area = sd(Area..mm.2., na.rm = TRUE),
    n = n(),
    se = sd_Area / sqrt(n),
    ci_lower = mean_Area - qt(0.975, df = n - 1) * se,
    ci_upper = mean_Area + qt(0.975, df = n - 1) * se,
    .groups = "drop"
  )

summary_df_size_grouped <- summary_df_size_grouped %>%
  mutate(DayNumber = as.numeric(as.character(DayNumber)))

summary_df_size_filtered <- summary_df_size_grouped %>%
  filter(DayNumber %in% c(1, 4, 7, 22))

all_days <- sort(unique(summary_df_size_grouped$DayNumber))

plot_size <- ggplot(summary_df_size_filtered, 
                    aes(x = DayNumber, y = mean_Area)) +
  geom_point(aes(fill = Reef, shape = SymbiontTreatment),
             color = "black",  # black border
             size = 3,
             stroke = 0.8) +
  geom_line(aes(color = Reef, group = interaction(Reef, SymbiontTreatment)),
            size = 1) +
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper, 
                    color = Reef, group = interaction(Reef, SymbiontTreatment)), 
                width = 0.3) +
  facet_wrap(~Treatment, ncol = 3) +
  scale_fill_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_color_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +
  scale_x_continuous(breaks = all_days) +
  labs(title = "Larval Size",
       x = "Days",
       y = "Mean Larval Size (mm^2)",
       fill = "Population of Origin",
       color = "Population of Origin",
       shape = "Symbiont Type") +
  theme_classic()


plot_size
plot_size <- plot_size +
  scale_x_continuous(limits = c(0, 22), breaks = seq(0, 22, 2))


###  Fv/Fm  ###
summary_df_FvFm_grouped <- df_with_extremes %>%
  mutate(
    Reef = Cross_2,
    DayNumber = Timepoint
  ) %>%
  group_by(DayNumber, Reef) %>%
  summarise(
    mean_FvFm = mean(FvFm, na.rm = TRUE),
    sd_FvFm = sd(FvFm, na.rm = TRUE),
    n = n(),
    se = sd_FvFm / sqrt(n),
    ci_lower = mean_FvFm - qt(0.975, df = n - 1) * se,
    ci_upper = mean_FvFm + qt(0.975, df = n - 1) * se,
    .groups = "drop"
  )

summary_df_FvFm_grouped <- summary_df_FvFm_grouped %>%
  mutate(DayNumber = as.numeric(as.character(DayNumber)))

summary_df_FvFm_filtered <- summary_df_FvFm_grouped %>%
  filter(DayNumber %in% c(1, 4, 22))

all_days <- sort(unique(summary_df_FvFm_grouped$DayNumber))

plot_FvFm <- ggplot(summary_df_FvFm_filtered, 
                     aes(x = DayNumber, y = mean_FvFm)) +
  # points with black border
  geom_point(aes(fill = Reef, shape = SymbiontTreatment),
             color = "black",
             size = 3,
             stroke = 0.8) +
  # lines colored by Reef
  geom_line(aes(color = Reef, group = interaction(Reef, SymbiontTreatment)),
            size = 1) +
  # error bars colored by Reef
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper,
                    color = Reef, group = interaction(Reef, SymbiontTreatment)),
                width = 0.3) +
  facet_wrap(~Treatment, ncol = 3) +
  scale_fill_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_color_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # must match levels
  scale_x_continuous(breaks = all_days) +
  labs(title = "Fv/Fm",
       x = "Days",
       y = "Mean Fv/Fm",
       fill = "Population of Origin",
       color = "Population of Origin",
       shape = "Symbiont Type") +
  theme_classic()


plot_FvFm
plot_FvFm <- plot_FvFm +
  scale_x_continuous(limits = c(0, 22), breaks = seq(0, 22, 2))


###  Survival  ###
summary_df_surv_grouped <- df_trimmed %>%
  mutate(
    Reef = Cross_2,
    DayNumber = Timepoint
  ) %>%
  group_by(DayNumber, Reef, SymbiontTreatment, Treatment) %>%
  summarise(
    mean_surv = mean(Percent_Survival_atend, na.rm = TRUE),
    sd_surv = sd(Percent_Survival_atend, na.rm = TRUE),
    n = n(),
    se = sd_surv / sqrt(n),
    ci_lower = mean_surv - qt(0.975, df = n - 1) * se,
    ci_upper = mean_surv + qt(0.975, df = n - 1) * se,
    .groups = "drop"
  )

summary_df_surv_grouped <- summary_df_surv_grouped %>%
  mutate(
    DayNumber = as.numeric(as.character(DayNumber)),
    Treatment = factor(Treatment, levels = c("Ambient", "31", "35.5"))
  )


summary_df_surv_filtered <- summary_df_surv_grouped %>%
  filter(DayNumber %in% c(1, 4, 22))

all_days <- sort(unique(summary_df_surv_grouped$DayNumber))

plot_surv <- ggplot(summary_df_surv_filtered, 
                    aes(x = DayNumber, y = mean_surv)) +
  # points with black border
  geom_point(aes(fill = Reef, shape = SymbiontTreatment),
             color = "black",
             size = 3,
             stroke = 0.8) +
  # lines colored by Reef
  geom_line(aes(color = Reef, group = interaction(Reef, SymbiontTreatment)),
            size = 1) +
  # error bars colored by Reef
  geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper,
                    color = Reef, group = interaction(Reef, SymbiontTreatment)),
                width = 0.3) +
  facet_wrap(~Treatment, ncol = 3) +
  scale_fill_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_color_manual(values = c("BxB" = "#1f77b4", "TxT" = "#ff7f0e")) +
  scale_shape_manual(values = c("C" = 21, "D" = 24)) +  # must match SymbiontTreatment levels
  scale_x_continuous(breaks = all_days) +
  labs(title = "Survival",
       x = "Days",
       y = "Mean Survival",
       fill = "Population of Origin",
       color = "Population of Origin",
       shape = "Symbiont Type") +
  theme_classic()

plot_surv
plot_surv <- plot_surv +
  scale_x_continuous(limits = c(0, 22), breaks = seq(0, 22, 2))


# Combine plots using patchwork
combined_mean_plots <- plot_surv / plot_cells / plot1_perc / plot_FvFm / plot_size  # Stack vertically
# Alternatively, to place them side by side:
# combined_plot <- plot1 + plot2

# Display combined plot
combined_mean_plots

# Save the combined plot
ggsave("C:/Users/jc980786/OneDrive - James Cook University/Australia/Ningaloo Spawning 2024/Larval Infection Experiment/combined_mean_plots_5_traits.png", plot = combined_mean_plots, width = 10, height = 15, dpi = 300)
```


